{"For the graph programming framework Stratimux generate a Document Object Model Concept":{"type":"project","content":"import { createConcept, Concept } from 'stratimux';\r\nimport { documentObjectModelPrinciple } from './documentObjectModel.principle';\r\nimport { UserInterfacePageBindings } from '../../model/userInterface';\r\nimport { documentObjectModelBindQuality } from './qualities/bind.quality';\r\nimport { documentObjectModelBindPayloadQuality } from './qualities/bindPayload.quality';\r\nimport { documentObjectModelClearBindingQueQuality } from './qualities/clearBindingQue.quality';\r\n\r\nexport const documentObjectModelName = 'documentObjectModel';\r\n\r\nexport type DocumentObjectModelState = {\r\n  bindingQue: UserInterfacePageBindings,\r\n  bound: boolean\r\n};\r\n\r\nconst createDocumentObjectModelState = (bindingQue?: UserInterfacePageBindings) : DocumentObjectModelState => {\r\n  return {\r\n    bindingQue: bindingQue ? bindingQue : {},\r\n    bound: false\r\n  };\r\n};\r\n\r\nexport const createDocumentObjectModelConcept = (bindingQue?: UserInterfacePageBindings): Concept =>  {\r\n  return createConcept(\r\n    documentObjectModelName,\r\n    createDocumentObjectModelState(bindingQue),\r\n    [\r\n      documentObjectModelBindQuality,\r\n      documentObjectModelBindPayloadQuality,\r\n      documentObjectModelClearBindingQueQuality\r\n    ],\r\n    [\r\n      documentObjectModelPrinciple\r\n    ]\r\n  );\r\n};"},"For the graph programming framework Stratimux and Document Object Model Concept, generate a principle that will bind the current page's preloaded document bindings.":{"type":"project","content":"import {\r\n  Action,\r\n  Concepts,\r\n  PrincipleFunction,\r\n  UnifiedSubject,\r\n  axiumKick,\r\n  axiumRegisterStagePlanner,\r\n  axiumSelectOpen,\r\n  createStage,\r\n  primeAction,\r\n  selectSlice,\r\n  selectState,\r\n  selectUnifiedState,\r\n  strategyBegin\r\n} from 'stratimux';\r\nimport { Subscriber } from 'rxjs';\r\nimport { DocumentObjectModelState, documentObjectModelName } from './documentObjectModel.concept';\r\nimport { documentObjectModelBindingStrategy } from './strategies/composeBindings.strategy';\r\nimport { documentObjectModelSelectBindingQue } from './documentObjectModel.selector';\r\n\r\nexport const documentObjectModelPrinciple: PrincipleFunction = (\r\n  _: Subscriber<Action>,\r\n  _concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  const pageID = document.querySelector('[id^=\"page#\"]')?.id;\r\n  const plan = concepts$.plan('Document Object Model initial page bindings plan', [\r\n    createStage((concepts, dispatch) => {\r\n      if (selectSlice(concepts, axiumSelectOpen) === true) {\r\n        dispatch(primeAction(concepts, axiumRegisterStagePlanner({conceptName: documentObjectModelName, stagePlanner: plan})), {\r\n          iterateStage: true,\r\n        });\r\n      }\r\n    }, { priority: 100 }),\r\n    createStage((concepts, dispatch) => {\r\n      const documentObjectModelState = selectUnifiedState<DocumentObjectModelState>(concepts, semaphore);\r\n      const userInterfaceState = selectState<any>(concepts, 'userInterfaceClient');\r\n      // console.log('Hello Document Object Model', documentObjectModelState, pageID, concepts);\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      if (documentObjectModelState?.bindingQue) {\r\n        let ready = false;\r\n        // userInterfaceState?.pages.forEach((page: {title: string}) => {\r\n        //   pageID && page.title === pageID ? ready = true : ready = false;\r\n        // });\r\n        for (const page of userInterfaceState.pages) {\r\n          if (pageID && page.title === pageID) {\r\n            ready = true;\r\n            break;\r\n          }\r\n        }\r\n        const binding = documentObjectModelState?.bindingQue;\r\n        // console.log('Hello Document Object Model', binding, pageID, ready);\r\n        if (binding && pageID && ready) {\r\n          dispatch(strategyBegin(documentObjectModelBindingStrategy(concepts, pageID.split('page#')[1], binding)), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }\r\n      if (documentObjectModelState?.bound) {\r\n        plan.conclude();\r\n      }\r\n    }, {beat: 100}),\r\n    createStage((__, ___) => {\r\n      plan.conclude();\r\n    })\r\n  ]);\r\n};"},"For the graph programming framework Stratimux and the huirth Project, generate a model that would enable all functionality required for the User Interface base concept.":{"type":"project","content":"import {\r\n  Action,\r\n  ActionNode,\r\n  ActionStrategy,\r\n  ActionStrategyStitch,\r\n  ActionType,\r\n  Concepts,\r\n  KeyedSelector,\r\n  Method,\r\n  MethodCreator,\r\n  Quality,\r\n  Reducer,\r\n  createAction,\r\n  createActionNode,\r\n  createQuality,\r\n  selectPayload,\r\n  strategyData_select,\r\n  ActionWithPayloadOptions,\r\n  ActionOptions,\r\n  ActionCreator,\r\n  ActionCreatorWithPayload\r\n} from 'stratimux';\r\nimport { elementEventBinding } from './html';\r\nimport { documentObjectModelName } from '../concepts/documentObjectModel/documentObjectModel.concept';\r\nimport { userInterfaceNext } from '../concepts/userInterface/qualities/next.quality';\r\nimport { Subject } from 'rxjs';\r\n\r\n/**\r\n * Should be ID as #string\r\n */\r\nexport type ElementIdentifier = string;\r\n\r\n// This is going to use DOM Strategies that bind the Event and creates an Action Node of ActionType to pass that Event TO\r\nexport type Binding = {\r\n  action: Action;\r\n  eventBinding: elementEventBinding | string;\r\n}\r\nexport type UserInterfaceBindings = Record<ElementIdentifier, Binding[]>;\r\nexport type UserInterfacePageBindings = Record<string, UserInterfaceBindings>;\r\nexport type PageStrategyCreators = (concepts?: Concepts, semaphore?: number) => ActionStrategyStitch;\r\nexport type ActionStrategyComponentStitch = (payload: ActionComponentPayload) => [ActionNode, ActionStrategy];\r\n\r\nexport type BrandState = {\r\n  pageStrategies: PageStrategyCreators[]\r\n};\r\n\r\nexport const createPageId = (pageName: string) => {\r\n  return `page#${pageName}`;\r\n};\r\n\r\nexport type PreBind = {\r\n  elementId: string,\r\n  eventBinding: elementEventBinding,\r\n  action: Action\r\n}\r\n\r\nexport const createBinding =\r\n  (bindings: PreBind[]): UserInterfaceBindings => {\r\n    const binding: UserInterfaceBindings = {};\r\n    bindings.forEach(bind => {\r\n      const possible = binding[bind.elementId];\r\n      if (possible !== undefined) {\r\n        binding[bind.elementId] = [...possible,{action: bind.action, eventBinding: bind.eventBinding}];\r\n      } else {\r\n        binding[bind.elementId] = [{action: bind.action, eventBinding: bind.eventBinding}];\r\n      }\r\n    });\r\n    return binding;\r\n  };\r\n\r\ntype ActionEventPayload = {\r\n  event: Event\r\n}\r\n\r\nexport const userInterface_selectInputTarget = (action: Action) => {\r\n  const payload = selectPayload<ActionEventPayload>(action).event;\r\n  return payload.target as HTMLInputElement;\r\n};\r\n\r\nexport const userInterface_isClient = (): boolean => {\r\n  return typeof window !== 'undefined';\r\n};\r\n\r\nexport const userInterface_pageBindingsToString = (pageBindings: UserInterfacePageBindings): string => {\r\n  let output = '{ ';\r\n  const bindingsKeys = Object.keys(pageBindings);\r\n  for (const key of bindingsKeys) {\r\n    output += `'${key}' : ${userInterface_bindingsToString(pageBindings[key])}`;\r\n    output += ',\\n';\r\n  }\r\n  output += '\\n}';\r\n  return output;\r\n};\r\n\r\nconst userInterface_bindingsToString = (bindings: UserInterfaceBindings): string => {\r\n  let output = '{ ';\r\n  const bindingsKeys = Object.keys(bindings);\r\n  for (const key of bindingsKeys) {\r\n    output += `'${key}' : [\\n`;\r\n    const bind = bindings[key];\r\n    for (const b of bind) {\r\n      output +=\r\n        `\\t{\\n\\t\\taction: ${JSON.stringify(b.action).replace(/\"/g,'\\'')},\\n\\t\\teventBinding: '${b.eventBinding}'\\n\\t},`;\r\n    }\r\n    output += '\\n],';\r\n  }\r\n  output += '\\n}';\r\n  return output;\r\n};\r\n\r\nexport type UserInterfacePageStrategies = Record<string, PageStrategyCreators>;\r\n\r\n/**\r\n * @param selector `optional` Creates a subscription that will dispatch the Action on value change\r\n * @param bindings `optional` Binds the elementIdentifier to the DOM Event Binding Strategy calling action last in sequence.\r\n * If the event emits a value, that will be passed as a payload to that Action's Node.\r\n * @param html The html of your composition\r\n * @param action The action that creates your composition\r\n */\r\n\r\nexport type BoundSelectors = {\r\n  id: string\r\n  action: Action,\r\n  selectors: KeyedSelector[],\r\n  semaphore: [number, number],\r\n}\r\n\r\nexport const createBoundSelectors =\r\n  (id: string, action: Action, selectors: KeyedSelector[]): BoundSelectors =>\r\n    ({id, action, selectors, semaphore: [-1, -1]});\r\n\r\nexport type Composition = {\r\n  id: string;\r\n  universal: boolean;\r\n  componentSemaphore?: number,\r\n  boundSelectors: BoundSelectors[],\r\n  bindings?: UserInterfaceBindings,\r\n  html: string,\r\n  action: Action;\r\n}\r\n\r\nexport type Page = {\r\n  title: string,\r\n  conceptAndProps: ConceptAndProperties[],\r\n  compositions: Composition[]\r\n  cachedSelectors: BoundSelectors[]\r\n  cachedComponentSelectors: BoundSelectors[]\r\n}\r\n\r\nexport type PrimedConceptAndProperties = {\r\n  name: string,\r\n  nameCapitalized: string,\r\n  properties?: string[]\r\n}\r\nexport type ConceptAndProperties = {\r\n  name: string,\r\n  properties?: string[]\r\n}\r\n\r\nexport const userInterface_createPage = (page?: Page): Page => (\r\n  page ? page : {\r\n    title: '',\r\n    conceptAndProps: [],\r\n    compositions: [],\r\n    cachedSelectors: [],\r\n    cachedComponentSelectors: []\r\n  });\r\n\r\nexport type ActionComponentPayload = {\r\n  pageTitle: string\r\n};\r\n\r\nexport const selectComponentPayload = <T extends Record<string, unknown>>(action: Action) => selectPayload<ActionComponentPayload & T>(action);\r\n\r\nexport type ActionComponentCreator<T extends Record<string, unknown>> = (\r\n    payload: ActionComponentPayload & T,\r\n    conceptSemaphore?: number,\r\n    keyedSelectors?: KeyedSelector[],\r\n    agreement?: number,\r\n    semaphore?: [number, number, number, number]\r\n  ) => Action;\r\n\r\nexport function prepareActionComponentCreator<T extends Record<string, unknown> & ActionComponentPayload>(actionType: ActionType): ActionCreatorWithPayload<T> {\r\n  return (\r\n    payload: T,\r\n    options?: ActionOptions\r\n  ) => {\r\n    const opts: ActionWithPayloadOptions<T> = {\r\n      ...options,\r\n      payload\r\n    };\r\n    return createAction(actionType, opts);\r\n  };\r\n}\r\n\r\nexport type ComponentCreator<T extends Record<string, unknown>> =\r\n  (action: ActionCreatorWithPayload<T>, concepts$?: Subject<Concepts>, semaphore?: number) => [Method, Subject<Action>];\r\n\r\nexport function createQualitySetComponent<T extends Record<string, unknown>>(q: {\r\n  type: string,\r\n  reducer: Reducer,\r\n  componentCreator: ComponentCreator<T & ActionComponentPayload>,\r\n  keyedSelectors?: KeyedSelector[],\r\n  meta?: Record<string,unknown>,\r\n  analytics?: Record<string,unknown>\r\n}): [ActionCreatorWithPayload<T & ActionComponentPayload>, ActionType, Quality] {\r\n  const action = prepareActionComponentCreator<T & ActionComponentPayload >(q.type);\r\n  return [\r\n    action,\r\n    q.type,\r\n    createQuality(\r\n      q.type,\r\n      q.reducer,\r\n      (concepts$?: Subject<Concepts>, semaphore?: number) => q.componentCreator(action, concepts$, semaphore),\r\n      q.keyedSelectors,\r\n      q.meta,\r\n      q.analytics\r\n    )\r\n  ];\r\n}\r\n\r\nexport const userInterface_appendCompositionToPage =\r\n  (strategy: ActionStrategy, composition: Composition): Page => {\r\n    const data = strategyData_select<Page>(strategy);\r\n    if (data) {\r\n      const page = data;\r\n      page.compositions.push(composition);\r\n      return page;\r\n    } else {\r\n      const newPage = userInterface_createPage();\r\n      newPage.compositions.push(composition);\r\n      return newPage;\r\n    }\r\n  };\r\n\r\nexport const userInterface_appendBindings = (strategy: ActionStrategy, bindings: UserInterfaceBindings[]): Page => {\r\n  const data = strategyData_select<Page>(strategy);\r\n  const newProps: string[] = [];\r\n  for (const bind of bindings) {\r\n    newProps.push(userInterface_bindingsToString(bind));\r\n  }\r\n  if (data) {\r\n    const page = data;\r\n    const pageConcepts = page.conceptAndProps;\r\n    let index = -1;\r\n    for (let i = 0; i < pageConcepts.length; i++) {\r\n      if (pageConcepts[i].name === documentObjectModelName) {\r\n        index = i;\r\n        break;\r\n      }\r\n    }\r\n    if (page.conceptAndProps[index].properties && index !== -1) {\r\n      page.conceptAndProps[index].properties = [\r\n        ...(page.conceptAndProps[index].properties as string[]),\r\n        ...newProps,\r\n      ];\r\n    } else {\r\n      page.conceptAndProps.push({\r\n        name: documentObjectModelName,\r\n        properties: newProps\r\n      });\r\n    }\r\n    return page;\r\n  } else {\r\n    const page = userInterface_createPage();\r\n    page.conceptAndProps.push({\r\n      name: documentObjectModelName,\r\n      properties: newProps\r\n    });\r\n    return userInterface_createPage();\r\n  }\r\n};\r\n\r\nexport const userInterface_selectPage = (strategy: ActionStrategy): Page => {\r\n  const data = strategyData_select<Page>(strategy);\r\n  if (data) {\r\n    return data;\r\n  } else {\r\n    return userInterface_createPage();\r\n  }\r\n};\r\n\r\nexport const userInterface_createComponent = (action: Action, success?: ActionNode): ActionNode => {\r\n  return createActionNode(action, {\r\n    successNode: success ? success : null,\r\n    failureNode: createActionNode(userInterfaceNext(), {\r\n      successNode: null,\r\n      failureNode: null\r\n    }),\r\n  });\r\n};\r\n\r\nexport const userInterface = {\r\n  selectPage: userInterface_selectPage,\r\n  appendCompositionToPage: userInterface_appendCompositionToPage,\r\n  appendBindings: userInterface_appendBindings,\r\n  bindingsToString: userInterface_bindingsToString,\r\n  createPage: userInterface_createPage,\r\n  createComponent: userInterface_createComponent,\r\n  isClient: userInterface_isClient,\r\n  pageBindingToString: userInterface_pageBindingsToString,\r\n  selectInputTarget: userInterface_selectInputTarget,\r\n};"},"For the graph programming framework Stratimux and Document Object Model Concept, generate a quality that will bind an action to an element.":{"type":"project","content":"import {\r\n  Action,\r\n  createMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  refreshAction,\r\n  selectPayload,\r\n  strategyBegin,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { Binding } from '../../../model/userInterface';\r\nimport { Subject } from 'rxjs';\r\nimport { documentObjectModelBindActionStrategy } from '../strategies/bindAction.strategy';\r\nimport { DocumentObjectModelState } from '../documentObjectModel.concept';\r\n\r\nconst setElementBinding = (element: HTMLElement, payload: DocumentObjectModelBindPayload) => {\r\n  const {\r\n    binding\r\n  } = payload;\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  (element as any)[binding.eventBinding] = (event: unknown) => {\r\n    payload.action$.next(strategyBegin(documentObjectModelBindActionStrategy({event}, refreshAction(payload.binding.action))));\r\n  };\r\n};\r\n\r\nexport type DocumentObjectModelBindPayload = {\r\n  action$: Subject<Action>,\r\n  id: string,\r\n  binding: Binding\r\n}\r\n\r\nexport const [\r\n  documentObjectModelBind,\r\n  documentObjectModelBindType,\r\n  documentObjectModelBindQuality\r\n] = createQualitySetWithPayload<DocumentObjectModelBindPayload>({\r\n  type: 'Document Object Model bind element',\r\n  reducer: (state: DocumentObjectModelState) : DocumentObjectModelState => {\r\n    return {\r\n      ...state,\r\n      bound: true\r\n    };\r\n  },\r\n  methodCreator: () => createMethod((action) => {\r\n    const payload = selectPayload<DocumentObjectModelBindPayload>(action);\r\n    const element = document.getElementById(payload.id);\r\n    if (element) {\r\n      setElementBinding(element, payload);\r\n    }\r\n    if (action.strategy) {\r\n      const success = strategySuccess(action.strategy);\r\n      return success;\r\n    } else {\r\n      return action;\r\n    }\r\n  })\r\n});"},"For the graph programming framework Stratimux and Document Object Model Concept, generate a quality that will attach a element event to the next action's payload.":{"type":"project","content":"import {\r\n  createMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategySuccess,\r\n} from 'stratimux';\r\n\r\nexport type DocumentObjectModelBindPayloadPayload = {\r\n  event: unknown\r\n};\r\n\r\nexport const [\r\n  documentObjectModelBindPayload,\r\n  documentObjectModelBindPayloadType,\r\n  documentObjectModelBindPayloadQuality\r\n] = createQualitySetWithPayload<DocumentObjectModelBindPayloadPayload>({\r\n  type: 'Document Object Model bind payload',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createMethod((action) => {\r\n    if (action.strategy) {\r\n      const payload = selectPayload<DocumentObjectModelBindPayloadPayload>(action);\r\n      const act = strategySuccess(action.strategy);\r\n      if (act.payload) {\r\n        act.payload = {\r\n          ...act.payload,\r\n          ...payload\r\n        };\r\n      } else {\r\n        act.payload = payload;\r\n      }\r\n      return act;\r\n    } else {\r\n      return action;\r\n    }\r\n  })\r\n});"},"For the graph programming framework Stratimux and Document Object Model Concept, generate a quality that will clear the Concept's bindingQue.":{"type":"project","content":"import {\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n} from 'stratimux';\r\nimport { DocumentObjectModelState } from '../documentObjectModel.concept';\r\n\r\nexport const [\r\n  documentObjectModelClearBindingQue,\r\n  documentObjectModelClearBindingQueType,\r\n  documentObjectModelClearBindingQueQuality\r\n] = createQualitySet({\r\n  type: 'Document Object Model clear binding que',\r\n  reducer: (state: DocumentObjectModelState): DocumentObjectModelState => {\r\n    return {\r\n      ...state,\r\n      bindingQue: {}\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and Document Object Model Concept, generate an ActionStrategy that will bind a event to a target action.":{"type":"project","content":"import { Action, createActionNode, createStrategy } from 'stratimux';\r\nimport { DocumentObjectModelBindPayloadPayload, documentObjectModelBindPayload } from '../qualities/bindPayload.quality';\r\n\r\nexport const documentObjectModelBindActionStrategyTopic = 'Document Object Model bind target Action with Payload';\r\nexport const documentObjectModelBindActionStrategy = (payload: DocumentObjectModelBindPayloadPayload, target: Action) => {\r\n  // Body\r\n  const stepAction = createActionNode(target);\r\n  const stepBinding = createActionNode(documentObjectModelBindPayload(payload), {\r\n    successNode: stepAction,\r\n  });\r\n  return createStrategy({\r\n    topic: `Bind payload to ${target.type}`,\r\n    initialNode: stepBinding,\r\n  });\r\n};"},"For the graph programming framework Stratimux and Document Object Model Concept, generate a strategy that will also generate a series of steps to bind each entry in the bindingQue..":{"type":"project","content":"import { ActionNode, AxiumState, Concepts, createActionNode, createStrategy } from 'stratimux';\r\nimport { UserInterfacePageBindings } from '../../../model/userInterface';\r\nimport { documentObjectModelClearBindingQue } from '../qualities/clearBindingQue.quality';\r\nimport { documentObjectModelBind } from '../qualities/bind.quality';\r\n\r\nexport const documentObjectModelBindingStrategyTopic = 'Document Object Model compose bind Page elements';\r\nexport const documentObjectModelBindingStrategy = (concepts: Concepts, pageName: string, bindingQue: UserInterfacePageBindings) => {\r\n  const bindings = bindingQue[pageName];\r\n  const bindingsKeys = Object.keys(bindings);\r\n  const action$ = (concepts[0].state as AxiumState).action$;\r\n  let start: null | ActionNode = null;\r\n  let previous: undefined | ActionNode;\r\n  for (const key of bindingsKeys) {\r\n    for (const binding of bindings[key]) {\r\n      const node = createActionNode(documentObjectModelBind({action$, binding, id: key}));\r\n      if (start === null) {\r\n        start = node;\r\n        previous = start;\r\n      } else if (previous) {\r\n        previous.successNode = node;\r\n        previous = node;\r\n      }\r\n    }\r\n  }\r\n\r\n  const stepBinding = createActionNode(documentObjectModelClearBindingQue(), {\r\n    successNode: start,\r\n  });\r\n  return createStrategy({\r\n    topic: 'Bind supplied bindingQue',\r\n    initialNode: stepBinding,\r\n  });\r\n};"},"For the graph programming framework Stratimux generate a File System Concept that will store the current projects root and concept directory map.":{"type":"project","content":"import { createConcept, Concept } from 'stratimux';\r\nimport { fileSystemGetDirectoriesQuality } from './qualities/getDirectories.quality';\r\nimport { fileSystemRemoveTargetDirectoryQuality } from './qualities/removeTargetDirectory.quality';\r\nimport { fileSystemCreateTargetDirectoryQuality } from './qualities/createTargetDirectory.quality';\r\nimport { fileSystemCopyMoveTargetDirectoryQuality } from './qualities/copyMoveDirectory.quality';\r\nimport { findRoot } from '../../model/findRoot';\r\nimport { fileSystemRecursivelyCopyMoveTargetDirectoriesQuality } from './qualities/recursivelyCopyMoveDirectories.quality';\r\nimport { fileSystemServerSetConceptDirectoriesFromDataQuality } from './qualities/setConceptDirectoriesFromData.quality';\r\nimport { fileSystemCreateFileWithContentsIndexQuality } from './qualities/createFileWithContents.quality';\r\nimport { fileSystemGetDirectoriesAndFilesQuality } from './qualities/getDirectoriesAndFiles.quality';\r\nimport { fileSystemReadDirectoryQuality } from './qualities/readDir.quality';\r\nimport { fileSystemFilterFilesAndDirectoriesQuality } from './qualities/filterFilesAndDirectories.quality';\r\nimport { fileSystemReadFileContentsAndAppendToDataQuality } from './qualities/readFileContentsAndAppendToData.quality';\r\n\r\nexport type FileSystemState = {\r\n  conceptDirectoryMap: string[],\r\n  root: string,\r\n}\r\n\r\nexport const fileSystemName = 'fileSystem';\r\n\r\nconst createFileSystemState = (): FileSystemState => {\r\n  return {\r\n    conceptDirectoryMap: [],\r\n    root: findRoot()\r\n  };\r\n};\r\n\r\nexport const createFileSystemConcept = (): Concept =>  {\r\n  return createConcept(\r\n    fileSystemName,\r\n    createFileSystemState(),\r\n    [\r\n      fileSystemGetDirectoriesQuality,\r\n      fileSystemRemoveTargetDirectoryQuality,\r\n      fileSystemCreateTargetDirectoryQuality,\r\n      fileSystemCopyMoveTargetDirectoryQuality,\r\n      fileSystemRecursivelyCopyMoveTargetDirectoriesQuality,\r\n      fileSystemServerSetConceptDirectoriesFromDataQuality,\r\n      fileSystemCreateFileWithContentsIndexQuality,\r\n      fileSystemGetDirectoriesAndFilesQuality,\r\n      fileSystemReadDirectoryQuality,\r\n      fileSystemFilterFilesAndDirectoriesQuality,\r\n      fileSystemReadFileContentsAndAppendToDataQuality,\r\n    ],\r\n    [],\r\n    []\r\n  );\r\n};"},"For the graph programming framework Stratimux and File System Concept, generate a model file with all types required for it to function.":{"type":"project","content":"import { Dirent } from 'fs';\r\n\r\nexport type FileDirent = {path: string} & Dirent;"},"For the graph programming framework Stratimux and File System Concept, generate a series of unified selectors to select the Concept's properties.":{"type":"project","content":"import { Concepts, createUnifiedKeyedSelector} from 'stratimux';\r\nimport { FileSystemState } from './fileSystem.concept';\r\n\r\nexport const selectUnifiedRoot = (concepts: Concepts, semaphore: number) =>\r\n  createUnifiedKeyedSelector<FileSystemState>(concepts, semaphore, 'root');"},"For the graph programming framework Stratimux and File System Concept, generate a quality that will copy move a target directory to a new location.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\n\r\nasync function copyDir(src: string, dest: string) {\r\n  await fs.mkdir(dest, { recursive: true });\r\n  const entries = await fs.readdir(src, { withFileTypes: true });\r\n\r\n  for (const entry of entries) {\r\n    if (entry.name) {\r\n      const srcPath = path.join(src, entry.name);\r\n      const destPath = path.join(dest, entry.name);\r\n      entry.isDirectory() ?\r\n        await copyDir(srcPath, destPath) :\r\n        await fs.copyFile(srcPath, destPath);\r\n    }\r\n  }\r\n}\r\n\r\nexport type CopyMoveTargetDirectoryPayload = {\r\n  target: string,\r\n  newLocation: string,\r\n};\r\n\r\nexport const [\r\n  fileSystemCopyMoveTargetDirectory,\r\n  fileSystemCopyMoveTargetDirectoryType,\r\n  fileSystemCopyMoveTargetDirectoryQuality\r\n] = createQualitySetWithPayload<CopyMoveTargetDirectoryPayload>({\r\n  type: 'File System copy move target Directory',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethod((controller, action) => {\r\n      const payload = selectPayload<CopyMoveTargetDirectoryPayload>(action);\r\n      if (action.strategy) {\r\n        copyDir(payload.target, payload.newLocation).then(() => {\r\n          const newStrategy =\r\n            strategySuccess(action.strategy as ActionStrategy);\r\n          controller.fire(newStrategy);\r\n        });\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and File System Concept, generate a quality that will create a file at a target location with the specified contents.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport fs from 'fs/promises';\r\n\r\nexport type CreateContextIndexPayload = {\r\n  target: string,\r\n  content: string,\r\n};\r\n\r\nexport const [\r\n  fileSystemCreateFileWithContentsIndex,\r\n  fileSystemCreateFileWithContentsIndexType,\r\n  fileSystemCreateFileWithContentsIndexQuality\r\n] = createQualitySetWithPayload<CreateContextIndexPayload>({\r\n  type: 'File System create File with Contents',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createAsyncMethod(\r\n    (controller, action) => {\r\n      const payload = selectPayload<CreateContextIndexPayload>(action);\r\n      if (action.strategy) {\r\n        fs.writeFile(payload.target, payload.content).then(() => {\r\n          const newStrategy =\r\n            strategySuccess(action.strategy as ActionStrategy);\r\n          controller.fire(newStrategy);\r\n        });\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and File System Concept, generate a quality the will create the target directory if it does not exist.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport fs from 'fs';\r\n\r\nexport type CreateTargetDirectoryPayload = {\r\n  path: string\r\n};\r\n\r\nexport const [\r\n  fileSystemCreateTargetDirectory,\r\n  fileSystemCreateTargetDirectoryType,\r\n  fileSystemCreateTargetDirectoryQuality\r\n] = createQualitySetWithPayload<CreateTargetDirectoryPayload>({\r\n  type: 'File System create target Directory',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethod((controller, action) => {\r\n      const path = selectPayload<CreateTargetDirectoryPayload>(action).path;\r\n      if (action.strategy) {\r\n        if (!fs.existsSync(path)) {\r\n          fs.mkdirSync(path);\r\n        }\r\n        const newStrategy =\r\n          strategySuccess(action.strategy as ActionStrategy);\r\n        controller.fire(newStrategy);\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and File System Concept, generate a quality that will filter an ActionStrategies supplied data's fileAndDirectories to both what is and is not specified.":{"type":"project","content":"import {\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyData_appendFailure,\r\n  strategyData_select,\r\n  strategyData_unifyData,\r\n  strategyFailed,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport { ReadDirectoryField } from './readDir.quality';\r\nimport path from 'path';\r\n\r\nconst isNot = (name: string, tokens: string[]): boolean => {\r\n  let pass = true;\r\n  for (const token of tokens) {\r\n    if (name.indexOf(token) !== -1) {\r\n      pass = false;\r\n      break;\r\n    }\r\n  }\r\n  return pass;\r\n};\r\n\r\nconst is = (name: string, tokens: string[]): boolean => {\r\n  let pass = false;\r\n  for (const token of tokens) {\r\n    if (name.indexOf(token) !== -1) {\r\n      pass = true;\r\n      break;\r\n    }\r\n  }\r\n  return pass;\r\n};\r\n\r\nexport type FilterFilesAndDirectoriesPayload = {\r\n  isTokens: string[];\r\n  notTokens: string[];\r\n};\r\n\r\nexport const [\r\n  fileSystemFilterFilesAndDirectories,\r\n  fileSystemFilterFilesAndDirectoriesType,\r\n  fileSystemFilterFilesAndDirectoriesQuality\r\n] = createQualitySetWithPayload<FilterFilesAndDirectoriesPayload>({\r\n  type: 'File System filter from Data Files and Directories field via token',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethod((controller, action) => {\r\n      if (action.strategy) {\r\n        const strategy = action.strategy;\r\n        const data = strategyData_select<ReadDirectoryField>(strategy);\r\n        const {isTokens, notTokens} = selectPayload<FilterFilesAndDirectoriesPayload>(action);\r\n        if (data && data.filesAndDirectories) {\r\n          data.filesAndDirectories = data?.filesAndDirectories.filter(dirent => {\r\n            const check = path.join(dirent.path + '/' + dirent.name);\r\n            return is(check, isTokens) && isNot(check, notTokens);\r\n          });\r\n          controller.fire(strategySuccess(strategy, strategyData_unifyData(strategy, data)));\r\n        } else {\r\n          controller.fire(strategyFailed(strategy, strategyData_appendFailure(strategy, 'No filesAndDirectories passed to quality')));\r\n        }\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and File System Concept, generate a quality that will store a target path's directories onto the provided ActionStrategy data field.":{"type":"project","content":"import {\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyData_unifyData,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport fs from 'fs';\r\n\r\nexport type GetDirectoriesPayload = {\r\n  path: string\r\n};\r\nexport type GetDirectoriesDataField = {\r\n  directories: string[]\r\n}\r\n\r\nexport const [\r\n  fileSystemGetDirectories,\r\n  fileSystemGetDirectoriesType,\r\n  fileSystemGetDirectoriesQuality\r\n] = createQualitySetWithPayload<GetDirectoriesPayload>({\r\n  type: 'File System get target Directories',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createAsyncMethod((controller, action) => {\r\n    const payload = selectPayload<GetDirectoriesPayload>(action);\r\n    const directories = fs.readdirSync(payload.path);\r\n    if (action.strategy) {\r\n      console.log('DIRECTORIES LENGTH', directories.length);\r\n      const newStrategy =\r\n        strategySuccess(action.strategy, strategyData_unifyData(action.strategy, {directories}));\r\n      controller.fire(newStrategy);\r\n    }\r\n    controller.fire(axiumConclude());\r\n  })\r\n});"},"For the graph programming framework Stratimux and File System Concept, generate a quality that will add Directories and Files from that target location to ActionStrategy data.":{"type":"project","content":"import {\r\n  createAsyncMethod,\r\n  createAsyncMethodDebounce,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyData_appendFailure,\r\n  strategyData_unifyData,\r\n  strategyFailed,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport fs  from 'fs/promises';\r\nimport { FileDirent } from '../fileSystem.model';\r\n\r\nexport type GetDirectoriesAndFilesPayload = {\r\n  path: string\r\n};\r\nexport type GetDirectoriesAndFilesDataField = {\r\n  directories: FileDirent[]\r\n}\r\n\r\nexport const [\r\n  fileSystemGetDirectoriesAndFiles,\r\n  fileSystemGetDirectoriesAndFilesType,\r\n  fileSystemGetDirectoriesAndFilesQuality\r\n] = createQualitySetWithPayload<GetDirectoriesAndFilesPayload>({\r\n  type: 'File System get target Directories and Files',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethodDebounce((controller, action) => {\r\n      const payload = selectPayload<GetDirectoriesAndFilesPayload>(action);\r\n      if (action.strategy) {\r\n        const strategy = action.strategy;\r\n        fs.readdir(payload.path, {\r\n          withFileTypes: true\r\n        }).then(directories => {\r\n          console.log('DIRECTORIES AND FILES LENGTH', directories.length);\r\n          const newStrategy =\r\n            strategySuccess(strategy, strategyData_unifyData(strategy, {directories}));\r\n          controller.fire(newStrategy);\r\n        }).catch(error => {\r\n          console.error('CHECK ERROR', error);\r\n          controller.fire(strategyFailed(strategy, strategyData_appendFailure(strategy, `${error}`)));\r\n        });\r\n      } else {\r\n        controller.fire(action);\r\n      }\r\n    }, 300)\r\n});"},"For the graph programming framework Stratimux and File System Concept, generate a quality that will add all Directories and Files from that target location to ActionStrategy data.":{"type":"project","content":"import {\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyData_appendFailure,\r\n  strategyData_unifyData,\r\n  strategyFailed,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport fs from 'fs/promises';\r\nimport { Dirent } from 'fs';\r\nimport path from 'path';\r\nimport { FileDirent } from '../fileSystem.model';\r\n\r\nasync function walk(target: string): Promise<({path: string} & Dirent)[]> {\r\n  const entries = await fs.readdir(target, {\r\n    withFileTypes: true\r\n  });\r\n  let ret: ({path: string} & Dirent)[] = [];\r\n  for (const entry of entries) {\r\n    if (entry.isDirectory() && entry.name !== '.git') {\r\n      ret = [...ret, ...(await walk(path.join((entry as {path: string} & Dirent).path) + '/' + entry.name))];\r\n    } else {\r\n      ret = [...ret, entry as {path: string} & Dirent];\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n\r\nexport type ReadDirectoryPayload = {\r\n  target: string;\r\n};\r\nexport type ReadDirectoryField = {\r\n  filesAndDirectories: FileDirent[]\r\n};\r\n\r\nexport const [\r\n  fileSystemReadDirectory,\r\n  fileSystemReadDirectoryType,\r\n  fileSystemReadDirectoryQuality\r\n] = createQualitySetWithPayload<ReadDirectoryPayload>({\r\n  type: 'File System read Directory and add to Strategy Data',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethod((controller, action) => {\r\n      const { target } = selectPayload<ReadDirectoryPayload>(action);\r\n      if (action.strategy) {\r\n        const strategy = action.strategy;\r\n        walk(target).then(data => {\r\n          controller.fire(strategySuccess(strategy, strategyData_unifyData(strategy, {\r\n            filesAndDirectories: data\r\n          })));\r\n        }).catch((error) => {\r\n          controller.fire(strategyFailed(strategy, strategyData_appendFailure(strategy, error)));\r\n        });\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and File System Concept, generate a quality that will read a file from a ReadDirectoryField data slice and unify the contents with the ActionStrategy's data.":{"type":"project","content":"import {\r\n  createAsyncMethod,\r\n  createQualitySet,\r\n  nullReducer,\r\n  strategyData_appendFailure,\r\n  strategyData_select,\r\n  strategyData_unifyData,\r\n  strategyFailed,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { FileDirent } from '../fileSystem.model';\r\nimport { ReadDirectoryField } from './readDir.quality';\r\n\r\nexport type ReadFileContentsAndAppendToDataField = {\r\n  dirent: FileDirent,\r\n  content: string,\r\n}\r\n\r\nexport const [\r\n  fileSystemReadFileContentsAndAppendToData,\r\n  fileSystemReadFileContentsAndAppendToDataType,\r\n  fileSystemReadFileContentsAndAppendToDataQuality\r\n] = createQualitySet({\r\n  type: 'File System read from File and Append to Data Field',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethod((controller, action) => {\r\n      if (action.strategy) {\r\n        const strategy = action.strategy;\r\n        const data = strategyData_select<ReadDirectoryField>(strategy);\r\n        if (data) {\r\n          const {filesAndDirectories} = data;\r\n          const dirent: FileDirent = filesAndDirectories[0];\r\n          fs.readFile(path.join(dirent.path + '/' + dirent.name)).then(contents => {\r\n            try {\r\n              const newData = {\r\n                dirent,\r\n                content: contents.toString()\r\n              };\r\n              controller.fire(strategySuccess(strategy, strategyData_unifyData(strategy, newData)));\r\n            } catch (error) {\r\n              controller.fire(strategyFailed(strategy, strategyData_appendFailure(\r\n                strategy,\r\n                `${error}`\r\n              )));\r\n            }\r\n          });\r\n        } else {\r\n          controller.fire(strategyFailed(strategy, strategyData_appendFailure(\r\n            strategy,\r\n            'No dirent provided in payload'\r\n          )));\r\n        }\r\n      } else {\r\n        controller.fire(action);\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and File System Concept, generate a quality that will recursively copy a target directory and its contents to a new location.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyRecurse,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\n\r\nasync function copyDir(src: string, dest: string) {\r\n  await fs.mkdir(dest, { recursive: true });\r\n  const entries = await fs.readdir(src, { withFileTypes: true });\r\n\r\n  for (const entry of entries) {\r\n    if (entry.name) {\r\n      const srcPath = path.join(src, entry.name);\r\n      const destPath = path.join(dest, entry.name);\r\n      entry.isDirectory() ?\r\n        await copyDir(srcPath, destPath) :\r\n        await fs.copyFile(srcPath, destPath);\r\n    }\r\n  }\r\n}\r\n\r\nexport type RecursivelyCopyMoveTargetDirectoriesPayload = {\r\n  directories: {\r\n    name: string,\r\n    target: string,\r\n    newLocation: string,\r\n  }[]\r\n};\r\n\r\nexport const [\r\n  fileSystemRecursivelyCopyMoveTargetDirectories,\r\n  fileSystemRecursivelyCopyMoveTargetDirectoriesType,\r\n  fileSystemRecursivelyCopyMoveTargetDirectoriesQuality\r\n] = createQualitySetWithPayload<RecursivelyCopyMoveTargetDirectoriesPayload>({\r\n  type: 'File System recursively copy move target Directories',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethod((controller, action) => {\r\n      const payload = selectPayload<RecursivelyCopyMoveTargetDirectoriesPayload>(action);\r\n      if (action.strategy) {\r\n        const directory = payload.directories.shift();\r\n        if (directory) {\r\n          copyDir(directory.target, directory.newLocation).then(() => {\r\n            if (payload.directories.length > 0) {\r\n              controller.fire(\r\n                strategyRecurse(action.strategy as ActionStrategy, {payload})\r\n              );\r\n            } else {\r\n              const newStrategy =\r\n                strategySuccess(action.strategy as ActionStrategy);\r\n              controller.fire(newStrategy);\r\n            }\r\n          });\r\n        } else {\r\n          controller.fire(\r\n            strategySuccess(action.strategy as ActionStrategy)\r\n          );\r\n        }\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and File System Concept, generate a quality that will remove a target directory.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyData_appendFailure,\r\n  strategyFailed,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport { rimraf } from 'rimraf';\r\n\r\nexport type RemoveTargetDirectoryPayload = {\r\n  path: string\r\n};\r\n\r\nexport const [\r\n  fileSystemRemoveTargetDirectory,\r\n  fileSystemRemoveTargetDirectoryType,\r\n  fileSystemRemoveTargetDirectoryQuality\r\n] = createQualitySetWithPayload<RemoveTargetDirectoryPayload>({\r\n  type: 'File System remove target Directory',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethod((controller, action) => {\r\n      const path = selectPayload<RemoveTargetDirectoryPayload>(action).path;\r\n      if (action.strategy) {\r\n        if (path.split('\\\\server\\\\src\\\\').length > 1) {\r\n          console.error('ERROR IN REMOVE TARGET DIR', action);\r\n          controller.fire(strategyFailed(action.strategy, strategyData_appendFailure(action.strategy, 'cannot delete server directory')));\r\n        } else {\r\n          rimraf(path).then((error) => {\r\n            if (error) {\r\n              console.error(error);\r\n            }\r\n            const newStrategy =\r\n              strategySuccess(action.strategy as ActionStrategy);\r\n            controller.fire(newStrategy);\r\n          });\r\n        }\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and File System Concept, generate a quality that will set the concept's concept directory map property from the supplied ActionStrategy data field.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n  strategyData_select,\r\n} from 'stratimux';\r\nimport { FileSystemState } from '../fileSystem.concept';\r\nimport { GetDirectoriesDataField } from './getDirectories.quality';\r\n\r\nexport const [\r\n  fileSystemServerSetConceptDirectoriesFromData,\r\n  fileSystemServerSetConceptDirectoriesFromDataType,\r\n  fileSystemServerSetConceptDirectoriesFromDataQuality\r\n] = createQualitySet({\r\n  type: 'File System set Concept Directories from Strategy Data',\r\n  reducer: (state: FileSystemState, action: Action): FileSystemState => {\r\n    if (action.strategy && action.strategy.data) {\r\n      const data = strategyData_select(action.strategy) as GetDirectoriesDataField;\r\n      if (data.directories) {\r\n        return {\r\n          ...state,\r\n          conceptDirectoryMap: data.directories\r\n        };\r\n      }\r\n    }\r\n    return {\r\n      ...state,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux generate a Hello World Concept.":{"type":"project","content":"import {\r\n  Action,\r\n  Concepts,\r\n  PrincipleFunction,\r\n  UnifiedSubject,\r\n  axiumRegisterStagePlanner,\r\n  axiumSelectOpen,\r\n  createStage,\r\n  primeAction,\r\n  stageWaitForOpenThenIterate\r\n} from 'stratimux';\r\nimport { Subscriber } from 'rxjs';\r\nimport { helloWorld } from './qualities/helloWorld.quality';\r\nimport { helloWorldName } from './helloWorld.concept';\r\n\r\nexport const helloWorldPrinciple: PrincipleFunction = (\r\n  _: Subscriber<Action>,\r\n  _concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  _semaphore: number\r\n) => {\r\n  const plan = concepts$.plan('Hello World Plan', [\r\n    stageWaitForOpenThenIterate(() => (axiumRegisterStagePlanner({conceptName: helloWorldName, stagePlanner: plan}))),\r\n    createStage((__, dispatch) => {\r\n      dispatch(helloWorld(), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((__, ___) => {\r\n      plan.conclude();\r\n    })\r\n  ]);\r\n};"},"For the graph programming framework Stratimux and Hello World Concept, generate a quality that will console log 'Hello World!'":{"type":"project","content":"import {\r\n  Action,\r\n  axiumConclude,\r\n  createMethod,\r\n  createQualitySet,\r\n  nullReducer,\r\n  strategySuccess,\r\n} from 'stratimux';\r\n\r\nexport const [\r\n  helloWorld,\r\n  helloWorldType,\r\n  helloWorldQuality,\r\n] = createQualitySet({\r\n  type: 'Hello World logs Hello World!',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createMethod((action: Action) => {\r\n      console.log('Hello World!');\r\n      if (action.strategy) {\r\n        return strategySuccess(action.strategy);\r\n      }\r\n      return axiumConclude();\r\n    })\r\n});"},"For the graph programming framework Stratimux generate a HTML Concept.":{"type":"project","content":"import { createConcept, Concept } from 'stratimux';\r\nimport { htmlHelloWorldQuality } from './qualities/helloWorld.quality';\r\nimport { htmlBeginQuality } from './qualities/htmlBegin.quality';\r\nimport { htmlEndQuality } from './qualities/htmlEnd';\r\nimport { htmlBodyBeginQuality } from './qualities/bodyBegin.quality';\r\nimport { htmlBodyEndQuality } from './qualities/bodyEnd.quality';\r\nimport { htmlHeadBeginQuality } from './qualities/headBegin.quality';\r\nimport { htmlHeadEndQuality } from './qualities/headEnd.quality';\r\n\r\nexport const htmlName = 'html';\r\n\r\nexport type HtmlState = {\r\n  //\r\n};\r\n\r\nconst createHtmlState = () : HtmlState => {\r\n  return {\r\n    //\r\n  };\r\n};\r\n\r\nexport const createHtmlConcept = (): Concept =>  {\r\n  return createConcept(\r\n    htmlName,\r\n    createHtmlState(),\r\n    [\r\n      htmlHelloWorldQuality,\r\n      htmlBeginQuality,\r\n      htmlEndQuality,\r\n      htmlBodyBeginQuality,\r\n      htmlBodyEndQuality,\r\n      htmlHeadBeginQuality,\r\n      htmlHeadEndQuality\r\n    ]\r\n  );\r\n};"},"For the graph programming framework Stratimux and Html Concept, generate a quality for a User Interface Concept that will add a html body element with the supplied page id.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport {\r\n  createPageId,\r\n  createQualitySetComponent,\r\n  selectComponentPayload,\r\n  userInterface_appendCompositionToPage\r\n} from '../../../model/userInterface';\r\n\r\nexport const [\r\n  htmlBodyBegin,\r\n  htmlBodyBeginType,\r\n  htmlBodyBeginQuality\r\n] = createQualitySetComponent({\r\n  type: 'Html create Body Begin',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(\r\n    (action) => {\r\n      const payload = selectComponentPayload(action);\r\n      if (action.strategy) {\r\n        const cont = strategySuccess(action.strategy, userInterface_appendCompositionToPage(action.strategy, {\r\n          id: '',\r\n          boundSelectors: [],\r\n          universal: false,\r\n          action: act(payload),\r\n          html: /*html*/`\r\n    <body id=\"${createPageId(payload.pageTitle)}\">\r\n      `\r\n        }));\r\n        return cont;\r\n      }\r\n      return action;\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and Html Concept, generate a quality to be used alongside a User Interface Concept that will add a body element closing tag to the current page composition.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../model/userInterface';\r\n\r\nexport const [\r\n  htmlBodyEnd,\r\n  htmlBodyEndType,\r\n  htmlBodyEndQuality\r\n] = createQualitySetComponent({\r\n  type: 'Html create Body End',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(\r\n    (action) => {\r\n      if (action.strategy) {\r\n        const payload = selectComponentPayload(action);\r\n        return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n          id: '',\r\n          boundSelectors: [],\r\n          universal: false,\r\n          action: act(payload),\r\n          html: /*html*/`\r\n    </body>\r\n      `\r\n        }));\r\n      }\r\n      return action;\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and Html Concept, generate a quality that will append a Html head element for a User Interface Concept and the supplied page composition.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../model/userInterface';\r\n\r\nexport const [\r\n  htmlHeadBegin,\r\n  htmlHeadBeginType,\r\n  htmlHeadBeginQuality\r\n] = createQualitySetComponent({\r\n  type: 'Html create Head Begin',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(\r\n    (action) => {\r\n      const payload = selectComponentPayload(action);\r\n      if (action.strategy) {\r\n        return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n          id: '',\r\n          boundSelectors: [],\r\n          universal: false,\r\n          action: act(payload),\r\n          html: /*html*/`\r\n    <head>\r\n      <meta charset=\"UTF-8\">\r\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n      <link rel=\"icon\" type=\"image/x-icon\" href=\"/static/favicon.ico\">\r\n      <script src=\"/static/scripts/index.mjs\"></script>\r\n      `\r\n        }));\r\n      }\r\n      return action;\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and Html Concept, generate a quality that will append a head element closing tag for a User Interface Concept and supplied page composition.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../model/userInterface';\r\n\r\nexport const [\r\n  htmlHeadEnd,\r\n  htmlHeadEndType,\r\n  htmlHeadEndQuality\r\n] = createQualitySetComponent({\r\n  type: 'Html create Head End',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(\r\n    (action) => {\r\n      const payload = selectComponentPayload(action);\r\n      if (action.strategy) {\r\n        return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n          id: '',\r\n          boundSelectors: [],\r\n          universal: false,\r\n          action: act(payload),\r\n          html: /*html*/`\r\n    </head>\r\n      `\r\n        }));\r\n      }\r\n      return action;\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and Html Concept, generate a quality that will add a Hello World composition for a User Interface Concept and a supplied page composition.":{"type":"project","content":"import {\r\n  Action,\r\n  axiumConcludeType,\r\n  createAction,\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../model/userInterface';\r\n\r\nexport const [\r\n  htmlHelloWorld,\r\n  htmlHelloWorldType,\r\n  htmlHelloWorldQuality,\r\n] = createQualitySetComponent({\r\n  type: 'Html create hello world composition',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) =>\r\n    createMethod((action: Action) => {\r\n      const payload = selectComponentPayload(action);\r\n      if (action.strategy) {\r\n        const helloWorldId = '#helloWorld';\r\n        return strategySuccess(action.strategy, userInterface_appendCompositionToPage(action.strategy, {\r\n          id: helloWorldId,\r\n          boundSelectors: [],\r\n          universal: false,\r\n          action: act(payload),\r\n          html: /*html*/`<h1 id=${helloWorldId}>Hello World</h1>`\r\n        }));\r\n      }\r\n      return createAction(axiumConcludeType);\r\n    })\r\n});"},"For the graph programming framework Stratimux and Html Concept, generate a quality that will append a html element to a page composition for a User Interface Concept.":{"type":"project","content":"import {\r\n  ActionType,\r\n  MethodCreator,\r\n  createMethod,\r\n  createQuality,\r\n  nullReducer,\r\n  prepareActionWithPayloadCreator,\r\n  selectPayload,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport {\r\n  createQualitySetComponent,\r\n  selectComponentPayload,\r\n  userInterface_appendCompositionToPage,\r\n} from '../../../model/userInterface';\r\n\r\nexport type HtmlBeginPayload = {\r\n  language?: string;\r\n}\r\n\r\nexport const [\r\n  htmlBegin,\r\n  htmlBeginType,\r\n  htmlBeginQuality\r\n] = createQualitySetComponent<HtmlBeginPayload>({\r\n  type: 'Create HTML Element',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(\r\n    (action) => {\r\n      if (action.strategy) {\r\n        const payload = selectComponentPayload<HtmlBeginPayload>(action);\r\n        return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n          id: '',\r\n          boundSelectors: [],\r\n          universal: false,\r\n          action: act(payload),\r\n          html: /*html*/`\r\n  <!DOCTYPE html>\r\n  <html lang=\"${payload.language ? payload.language : 'en'}\">\r\n      `\r\n        }));\r\n      }\r\n      return action;\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and Html Concept, generate a quality that will append a html closing element tag to a page composition for a User Interface Concept.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport {\r\n  createQualitySetComponent,\r\n  selectComponentPayload,\r\n  userInterface_appendCompositionToPage,\r\n} from '../../../model/userInterface';\r\n\r\nexport const [\r\n  htmlEnd,\r\n  htmlEndType,\r\n  htmlEndQuality\r\n] = createQualitySetComponent({\r\n  type: 'Create HTML End Element',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(\r\n    (action) => {\r\n      const payload = selectComponentPayload(action);\r\n      if (action.strategy) {\r\n        return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n          id: '',\r\n          boundSelectors: [],\r\n          universal: false,\r\n          action: act(payload),\r\n          html: /*html*/`\r\n  </html>\r\n      `\r\n        }));\r\n      }\r\n      return action;\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux generate a Brand Concept called huirth that will act as a Sidekick Application for the Stratimux Framework.":{"type":"project","content":"import { createConcept, Concept, unifyConcepts, createCounterConcept, PrincipleFunction, Quality } from 'stratimux';\r\nimport { BrandState } from '../../model/userInterface';\r\nimport { huirthErrorQuality } from './qualities/components/error/error.quality';\r\nimport { huirthHeadQuality } from './qualities/components/head.quality';\r\nimport { huirthStyleQuality } from './qualities/components/style.quality';\r\nimport { huirthFooterQuality } from './qualities/components/footer.quality';\r\nimport { huirthIndexHeroQuality } from './qualities/components/hero/indexHero.quality';\r\nimport { huirthIndexDialogBeginQuality } from './qualities/components/dialog/indexDialogBegin.quality';\r\nimport { huirthIndexDialogContentQuality } from './qualities/components/dialog/indexDialogContent.quality';\r\nimport { huirthIndexDialogEndQuality } from './qualities/components/dialog/indexDialogEnd.quality';\r\nimport { huirthAppendAxiumDialogQuality } from './qualities/appendAxiumDialog.quality';\r\nimport { huirthDialogPrinciple } from './huirth.principle';\r\nimport { huirthTrainingDataPagePrinciple } from './huirth.trainingDataPage.principle';\r\nimport { huirthIndexPageStrategy } from './strategies/pages/indexPage.strategy';\r\nimport { huirthErrorPageStrategy } from './strategies/pages/errorPage.strategy';\r\nimport { huirthIndexDPOBeginQuality } from './qualities/components/DPO/DPOBegin.quality';\r\nimport { huirthIndexDPOContentQuality } from './qualities/components/DPO/DPOContent.quality';\r\nimport { huirthIndexDPOEndQuality } from './qualities/components/DPO/DPOEnd.quality';\r\nimport { huirthUpdateFromPromptPayloadQuality } from './qualities/updateFromPromptPayload.quality';\r\nimport { huirthUpdateFromChosenPayloadQuality } from './qualities/updateFromChosenPayload.quality';\r\nimport { huirthUpdateFromRejectedPayloadQuality } from './qualities/updateFromRejectedPayload.quality';\r\nimport {\r\n  Active_DPO,\r\n  GeneralProjectStatuses,\r\n  ProjectStatus,\r\n  TrainingData,\r\n  generateDPOTrainingData,\r\n  generateDefaultTrainingData,\r\n  huirthVerboseAddingStrategySelect,\r\n  huirthVerboseAdditionAndSubtractionStrategySelect,\r\n  huirthVerboseSubtractionStrategySelect\r\n} from './huirth.model';\r\nimport { huirthNewDataSetEntryQuality } from './qualities/newDataSetEntry.quality';\r\nimport { huirthTriggerMinusCountingStrategyQuality } from './qualities/triggerMinusCounterStrategy.quality';\r\nimport { huirthTriggerPlusCountingStrategyQuality } from './qualities/triggerPlusCounterStrategy.quality';\r\nimport { huirthTriggerRandomCountingStrategyQuality } from './qualities/triggerRandomCounterStrategy.quality';\r\nimport { huirthDataManagerPageStrategy } from './strategies/pages/dataManagerPage.strategy';\r\nimport { huirthDataManagerBeginQuality } from './qualities/components/dataManager/dataManagerBegin.quality';\r\nimport { huirthDataManagerContentQuality } from './qualities/components/dataManager/dataManagerContent.quality';\r\nimport { huirthDataManagerEndQuality } from './qualities/components/dataManager/dataManagerEnd.quality';\r\nimport { huirthSideBarBeginQuality } from './qualities/components/sideBar/sideBarBegin.quality';\r\nimport { huirthSideBarContentQuality } from './qualities/components/sideBar/sideBarContent.quality';\r\nimport { huirthSideBarEndQuality } from './qualities/components/sideBar/sideBarEnd.quality';\r\nimport { huirthToggleSidebarQuality } from './qualities/toggleSidebar.quality';\r\nimport { huirthNewDPOEntryQuality } from './qualities/newDPOEntry.quality';\r\nimport { huirthNewDataSetQuality } from './qualities/newDataSet.quality';\r\nimport { huirthUpdateDataSetNameQuality } from './qualities/updateDataSetName.quality';\r\nimport { huirthDataSetBeginQuality } from './qualities/components/dataSet/dataSetBegin.quality';\r\nimport { huirthDataSetEndQuality } from './qualities/components/dataSet/dataSetEnd.quality';\r\nimport { huirthDataSetContentQuality } from './qualities/components/dataSet/dataSetContent.quality';\r\nimport { huirthUpdateDataSetContentsQuality } from './qualities/updateDataSetContents.quality';\r\nimport { huirthUpdateDataSetPromptQuality } from './qualities/updateDataSetPrompt.quality';\r\nimport { huirthUpdateProjectStatusQuality } from './qualities/updateProjectToStatus.quality';\r\nimport { huirthTriggerInstallGitRepositoryQuality } from './qualities/triggerInstallGitRepository.quality';\r\nimport { huirthUpdateParsedProjectDataSetQuality } from './qualities/updateParsedProjectDataSet.quality';\r\nimport { huirthUpdateDataSetSelectionQuality } from './qualities/updateDataSetSelection.quality';\r\nimport { huirthSendTriggerParseRepositoryStrategyQuality } from './qualities/sendTriggerParseRepositoryStrategy.quality';\r\nimport { huirthSendTriggerSaveDataSetSelectionStrategyQuality } from './qualities/sendTriggerSaveDataSetSelectionStrategy.quality';\r\nimport { huirthUpdateProjectStatusToSavedQuality } from './qualities/updateProjectToSaved.quality';\r\nimport { huirthRemoveDataSetSelectionQuality } from './qualities/removeDataSetSelection.quality';\r\nimport { huirthSendTriggerDeleteDataSetsStrategyQuality } from './qualities/sendTriggerDeleteDataSetsStrategy.quality';\r\nimport { huirthSetPossibleProjectQuality } from './qualities/setPossibleProject.quality';\r\nimport { huirthFilterTriggerInstallGitRepositoryQuality } from './qualities/filterTriggerInstallGitRepository.quality';\r\nimport { huirthSetDataSetQuality } from './qualities/setDataSet.quality';\r\nimport { huirthSetSelectedTransformationQuality } from './qualities/setSelectedTransformation.quality';\r\nimport { huirthSendTriggerSelectedTransformationStrategyQuality } from './qualities/sendTriggerSelectedTransformationStrategy.quality';\r\nimport { huirthClearDataSetSelectionQuality } from './qualities/clearDataSetSelection.quality';\r\nimport { huirthSetTrainingDataPageQuality } from './qualities/setTrainingDataPage.quality';\r\nimport { huirthFilterTrainingDataPageQuality } from './qualities/filterTrainingDataPage.quality';\r\nimport { huirthSetTrainingDataInitializedQuality } from './qualities/setTrainingDataInitialized.quality';\r\nimport { huirthTriggerAddTrainingDataPageQuality } from './qualities/triggerAddTrainingDataPageStrategy.quality';\r\nimport { huirthSendAddTrainingPageStrategyQuality } from './qualities/sendTriggerAddTrainingPageStrategy.quality';\r\nimport { huirthSendRemoveAddTrainingPageStrategyQuality } from './qualities/sendTriggerRemoveAddTrainingPageStrategy.quality';\r\nimport { huirthTriggerRemoveAddTrainingDataPageQuality } from './qualities/triggerRemoveAddTrainingDataPageStrategy.quality';\r\n\r\nexport const huirthName = 'huirth';\r\nexport type huirthState = {\r\n  mock: number;\r\n  dialog: string;\r\n  transformationStrategies: string[];\r\n  selectedTransformation: string;\r\n  possibleProject: string;\r\n  possibleProjectValid: boolean;\r\n  stratimuxStatus: ProjectStatus;\r\n  huirthStatus: ProjectStatus;\r\n  projectsStatuses: GeneralProjectStatuses;\r\n  dataSetSelection: boolean[];\r\n  sideBarExpanded: boolean;\r\n  trainingDataInitialized: boolean;\r\n  trainingData: TrainingData;\r\n  trainingDataPages: string[];\r\n  trainingDataCounter: number;\r\n  activeDPO: Active_DPO[];\r\n} & BrandState;\r\n\r\nconst createHuirthState = (): huirthState => {\r\n  return {\r\n    mock: 0,\r\n    dialog: '',\r\n    transformationStrategies: [\r\n      huirthVerboseAddingStrategySelect,\r\n      huirthVerboseSubtractionStrategySelect,\r\n      huirthVerboseAdditionAndSubtractionStrategySelect\r\n    ],\r\n    selectedTransformation: 'Some Strategy',\r\n    possibleProject: '',\r\n    possibleProjectValid: false,\r\n    stratimuxStatus: ProjectStatus.notInstalled,\r\n    huirthStatus: ProjectStatus.notInstalled,\r\n    projectsStatuses: [],\r\n    dataSetSelection: [],\r\n    sideBarExpanded: true,\r\n    trainingDataInitialized: false,\r\n    trainingData: generateDefaultTrainingData(),\r\n    trainingDataPages: [],\r\n    trainingDataCounter: -1,\r\n    activeDPO: [generateDPOTrainingData()],\r\n    pageStrategies: [huirthIndexPageStrategy, huirthDataManagerPageStrategy, huirthErrorPageStrategy]\r\n  };\r\n};\r\n\r\nexport const createHuirthConcept = (): Concept =>  {\r\n  const principles: PrincipleFunction[] = [\r\n    huirthDialogPrinciple,\r\n    huirthTrainingDataPagePrinciple\r\n  ];\r\n  const qualities: Quality[] = [\r\n    huirthHeadQuality,\r\n    huirthStyleQuality,\r\n    huirthFooterQuality,\r\n    huirthSideBarBeginQuality,\r\n    huirthSideBarContentQuality,\r\n    huirthSideBarEndQuality,\r\n    huirthIndexHeroQuality,\r\n    huirthIndexDialogBeginQuality,\r\n    huirthIndexDialogContentQuality,\r\n    huirthIndexDialogEndQuality,\r\n    huirthErrorQuality,\r\n    huirthAppendAxiumDialogQuality,\r\n    huirthIndexDPOBeginQuality,\r\n    huirthIndexDPOContentQuality,\r\n    huirthIndexDPOEndQuality,\r\n    huirthClearDataSetSelectionQuality,\r\n    huirthDataManagerBeginQuality,\r\n    huirthDataManagerContentQuality,\r\n    huirthDataManagerEndQuality,\r\n    huirthDataSetBeginQuality,\r\n    huirthDataSetContentQuality,\r\n    huirthDataSetEndQuality,\r\n    huirthSendTriggerParseRepositoryStrategyQuality,\r\n    huirthSendTriggerSaveDataSetSelectionStrategyQuality,\r\n    huirthSendTriggerDeleteDataSetsStrategyQuality,\r\n    huirthSendTriggerSelectedTransformationStrategyQuality,\r\n    huirthUpdateFromPromptPayloadQuality,\r\n    huirthUpdateFromChosenPayloadQuality,\r\n    huirthUpdateFromRejectedPayloadQuality,\r\n    huirthUpdateDataSetNameQuality,\r\n    huirthUpdateDataSetContentsQuality,\r\n    huirthUpdateDataSetPromptQuality,\r\n    huirthUpdateProjectStatusQuality,\r\n    huirthUpdateDataSetSelectionQuality,\r\n    huirthUpdateParsedProjectDataSetQuality,\r\n    huirthUpdateProjectStatusToSavedQuality,\r\n    huirthNewDataSetEntryQuality,\r\n    huirthNewDataSetQuality,\r\n    huirthNewDPOEntryQuality,\r\n    huirthRemoveDataSetSelectionQuality,\r\n    huirthTriggerMinusCountingStrategyQuality,\r\n    huirthTriggerPlusCountingStrategyQuality,\r\n    huirthTriggerRandomCountingStrategyQuality,\r\n    huirthTriggerInstallGitRepositoryQuality,\r\n    huirthToggleSidebarQuality,\r\n    huirthSetPossibleProjectQuality,\r\n    huirthFilterTriggerInstallGitRepositoryQuality,\r\n    huirthSetDataSetQuality,\r\n    huirthSetSelectedTransformationQuality,\r\n    huirthSetTrainingDataPageQuality,\r\n    huirthFilterTrainingDataPageQuality,\r\n    huirthSetTrainingDataInitializedQuality,\r\n    huirthSendAddTrainingPageStrategyQuality,\r\n    huirthTriggerAddTrainingDataPageQuality,\r\n    huirthSendRemoveAddTrainingPageStrategyQuality,\r\n    huirthTriggerRemoveAddTrainingDataPageQuality\r\n  ];\r\n  // This is temporary, the complete flow would allow for all server logic to remain on the server.\r\n  return unifyConcepts(\r\n    [\r\n      createCounterConcept()\r\n    ],\r\n    createConcept(\r\n      huirthName,\r\n      createHuirthState(),\r\n      qualities,\r\n      principles,\r\n      []\r\n    ));\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate the model file contents.":{"type":"project","content":"// eslint-disable-next-line no-shadow\r\nexport enum ProjectStatus {\r\n  notInstalled = 'Not Installed',\r\n  installing = 'Installing',\r\n  installed = 'Installed',\r\n  parsing = 'Data Parsing...',\r\n  parsed = 'Data Parsed',\r\n  saving = 'Saving...',\r\n  saved = 'Saved',\r\n  pulled = 'Pulled',\r\n}\r\n\r\nexport type GeneralProjectStatuses = {name: string, status: ProjectStatus}[];\r\n\r\n// eslint-disable-next-line no-shadow\r\nexport enum PhuirEProjects {\r\n  // eslint-disable-next-line quotes\r\n  stratimux = \"stratimux\",\r\n  stratimuxURL = 'https://github.com/Phuire-Research/Stratimux',\r\n  huirth = 'huirth',\r\n  huirth_URL = 'https://github.com/Phuire-Research/huirth'\r\n}\r\n\r\nexport type Final_DPO = Record<string, {\r\n  chosen: [{\r\n    content: string\r\n  }],\r\n  rejected: [{\r\n    content: string\r\n  }]\r\n}>\r\nexport type Active_DPO = {\r\n  prompt: string,\r\n  chosen: string,\r\n  rejected: string\r\n}\r\n\r\nexport type BaseDataSet = {\r\n  prompt: string,\r\n  content: string,\r\n} & Record<string, string>\r\n\r\n// eslint-disable-next-line no-shadow\r\nexport enum DataSetTypes {\r\n  general = 'general',\r\n  project = 'project',\r\n  dpo = 'dpo',\r\n}\r\n\r\nexport type NamedDataSet = {\r\n  name: string,\r\n  type: DataSetTypes,\r\n  dataSet: BaseDataSet[]\r\n  index: number\r\n}\r\n\r\nexport type TrainingData = NamedDataSet[];\r\n\r\nexport const generateDPOTrainingData = (): Active_DPO => ({\r\n  prompt: '#insert prompt#',\r\n  chosen: '#insert chosen output#',\r\n  rejected: '#insert rejected output#'\r\n});\r\n\r\nexport const generateBaseDataSetEntry = (): BaseDataSet => {\r\n  return {\r\n    prompt: '#insert prompt#',\r\n    content: '#insert chosen output#',\r\n  };\r\n};\r\n\r\nexport const generateDefaultNamedDataSet = (name: string): NamedDataSet => ({\r\n  name,\r\n  type: DataSetTypes.general,\r\n  dataSet: [generateBaseDataSetEntry()],\r\n  index: 0\r\n});\r\n\r\nexport const generateDefaultTrainingData = (): TrainingData => [];\r\n\r\nexport const dataSetNameID = '#dataSetNameID-';\r\nexport const dataSetSelectionID = '#dataSetSelectionID-';\r\nexport const promptID = '#promptID-';\r\nexport const contentID = '#contentID-';\r\nexport const chosenID = '#chosenID-';\r\nexport const rejectedID = '#rejectedID-';\r\n\r\nexport function generateNumID(number: number) {\r\n  if (number < 10) {\r\n    return `00${number}`;\r\n  } else if (number < 100) {\r\n    return `0${number}`;\r\n  } else {\r\n    return `${number}`;\r\n  }\r\n}\r\n\r\nexport function selectTrainingDataIndex(element: HTMLElement, key: string) {\r\n  console.log('CHECK ERROR', element, key);\r\n  return Number(element.id.split(key)[1]);\r\n}\r\n\r\n// Transformation Strategies on server\r\nexport const huirthVerboseAddingStrategySelect = 'Verbose Adding Transformation Strategy';\r\nexport const huirthVerboseSubtractionStrategySelect = 'Verbose Subtraction Transformation Strategy';\r\nexport const huirthVerboseAdditionAndSubtractionStrategySelect = 'Verbose Addition and Subtraction Transformation Strategy';"},"For the graph programming framework Stratimux and a huirth Concept, generate a Principle that will detect the Axium's dialog and only will loaded on the client.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport {\r\n  Action,\r\n  Concepts,\r\n  PrincipleFunction,\r\n  UnifiedSubject,\r\n  axiumRegisterStagePlanner,\r\n  createStage,\r\n  getAxiumState,\r\n  getUnifiedName,\r\n} from 'stratimux';\r\nimport _ws from 'express-ws';\r\nimport { huirthAppendAxiumDialog } from './qualities/appendAxiumDialog.quality';\r\nimport { userInterfaceClientName } from '../userInterfaceClient/userInterfaceClient.concept';\r\n\r\nlet topic = '';\r\nexport const huirthDialogPrinciple: PrincipleFunction =\r\n  (_: Subscriber<Action>, cpts: Concepts, concepts$: UnifiedSubject, semaphore: number) => {\r\n    const beat = 500;\r\n    const plan = concepts$.plan('Observe Axium Dialog and append to State', [\r\n      createStage((concepts, dispatch) => {\r\n        const conceptName = getUnifiedName(concepts, semaphore);\r\n        if (conceptName && conceptName === userInterfaceClientName) {\r\n          dispatch(axiumRegisterStagePlanner({conceptName, stagePlanner: plan}), {\r\n            iterateStage: true,\r\n          });\r\n        } else {\r\n          plan.conclude();\r\n        }\r\n      }),\r\n      createStage((concepts, dispatch) => {\r\n        const axiumTopic = getAxiumState(concepts).lastStrategy;\r\n        const axiumDialog = getAxiumState(concepts).lastStrategyDialog;\r\n        // console.log(`TOPIC: ${topic}, AXIUM TOPIC: ${axiumTopic}`);\r\n        if (topic !== axiumTopic) {\r\n          topic = axiumTopic;\r\n          const setDialog = huirthAppendAxiumDialog({\r\n            dialog: axiumDialog\r\n          });\r\n          dispatch(setDialog, {\r\n            throttle: 1\r\n          });\r\n        }\r\n      }, {beat})\r\n    ]);\r\n  };"},"For the graph programming framework Stratimux and the brand Concept huirth, generate a series of unified selector creators that will select slices of huirth's state.":{"type":"project","content":"import { Concepts, createUnifiedKeyedSelector  } from 'stratimux';\r\nimport { huirthState } from './huirth.concept';\r\n\r\nexport const huirth_createDialogSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'dialog');\r\n};\r\nexport const huirth_createCountSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'count');\r\n};\r\n\r\nexport const huirth_createTrainingDataSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'trainingData');\r\n};\r\n\r\nexport const huirth_createDPOSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'activeDPO');\r\n};\r\n\r\nexport const huirth_createSideBarExpandedSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'sideBarExpanded');\r\n};\r\n\r\nexport const huirth_createPagesSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'pages');\r\n};\r\n\r\nexport const huirth_createPageStrategiesSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector<huirthState>(concepts, semaphore, 'pageStrategies');\r\n};\r\n\r\nexport const huirth_createDataSetSelector = (concepts: Concepts, semaphore: number, index: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'trainingData', [index]);\r\n};\r\n\r\nexport const huirth_createDataSetSelectionSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'dataSetSelection');\r\n};\r\n\r\nexport const huirth_createStratimuxStatusSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'stratimuxStatus');\r\n};\r\n\r\nexport const huirth_createHuirthStatusSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'huirthStatus');\r\n};\r\n\r\nexport const huirth_createProjectStatusSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'projectStatus');\r\n};\r\n\r\nexport const huirth_createPossibleProjectValidSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'possibleProjectValid');\r\n};\r\n\r\nexport const huirth_createSelectedTransformationSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector(concepts, semaphore, 'selectedTransformation');\r\n};"},"For the graph programming framework Stratimux and the brand concept huirth, generate a principle that will create pages based upon the loaded data sets assigned to state.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport { Action, ActionStrategy, Concepts, KeyedSelector, PrincipleFunction, UnifiedSubject, axiumKick, axiumRegisterStagePlanner, createStage, getUnifiedName, selectUnifiedState, strategyBegin, strategySequence } from 'stratimux';\r\nimport { userInterface_isClient } from '../../model/userInterface';\r\nimport { UserInterfaceState } from '../userInterface/userInterface.concept';\r\nimport { huirthState } from './huirth.concept';\r\nimport { UserInterfaceClientState } from '../userInterfaceClient/userInterfaceClient.concept';\r\nimport { userInterfaceAddNewPageStrategy } from '../userInterface/strategies.ts/addNewPage.strategy';\r\nimport { huirthGeneratedTrainingDataPageStrategy } from './strategies/pages/generatedTrainingDataPage.strategy';\r\nimport { DataSetTypes, ProjectStatus, TrainingData } from './huirth.model';\r\nimport { huirthUpdateProjectStatusStrategy } from './strategies/updateProjectStatus.strategy';\r\n// import { userInterfaceRemovePageStrategy } from '../userInterface/strategies.ts/removePage.strategy';\r\nimport { huirth_createPageStrategiesSelector, huirth_createPagesSelector, huirth_createTrainingDataSelector } from './huirth.selector';\r\nimport { huirthAddTrainingDataPageStrategy, huirthAddTrainingDataPageStrategyTopic } from './strategies/addPageTrainingData.strategy';\r\n// import { huirthRemoveTrainingDataPageStrategy } from './strategies/removeTrainingDataPage.strategy';\r\n\r\n// const namesChanged = (trainingData: TrainingData, cachedTrainingDataNames: string[]) => {\r\n//   if (trainingData.length !== cachedTrainingDataNames.length) {\r\n//     return true;\r\n//   } else {\r\n//     for (const data of trainingData) {\r\n//       let exists = false;\r\n//       for (const name of cachedTrainingDataNames) {\r\n//         if (data.name === name) {\r\n//           exists = true;\r\n//         }\r\n//       }\r\n//       if (!exists) {\r\n//         return true;\r\n//       }\r\n//     }\r\n//   }\r\n//   return false;\r\n// };\r\n\r\n// const determineAddRemove = (trainingData: TrainingData, cachedTrainingDataNames: string[]) => {\r\n//   const add: {\r\n//     i: number,\r\n//     name: string\r\n//   }[] = [];\r\n//   const remove: {\r\n//     i: number,\r\n//     name: string\r\n//   }[] = [];\r\n//   for (const [i, data] of trainingData.entries()) {\r\n//     let found = false;\r\n//     for (let index = 0; index < cachedTrainingDataNames.length; index++) {\r\n//       const name = cachedTrainingDataNames[index];\r\n//       if (data.name === name) {\r\n//         found = true;\r\n//         break;\r\n//       }\r\n//     }\r\n//     if (!found) {\r\n//       add.push({\r\n//         i,\r\n//         name: data.name\r\n//       });\r\n//     }\r\n//   }\r\n//   for (let index = 0; index < cachedTrainingDataNames.length; index++) {\r\n//     const name = cachedTrainingDataNames[index];\r\n//     let found = false;\r\n//     for (const data of trainingData) {\r\n//       if (data.name === name) {\r\n//         found = true;\r\n//         break;\r\n//       }\r\n//     }\r\n//     if (!found) {\r\n//       remove.push({\r\n//         i: index,\r\n//         name,\r\n//       });\r\n//     }\r\n//   }\r\n//   return [\r\n//     add, remove\r\n//   ];\r\n// };\r\n\r\nexport const huirthTrainingDataPagePrinciple: PrincipleFunction =\r\n  (_: Subscriber<Action>, cpts: Concepts, concepts$: UnifiedSubject, semaphore: number) => {\r\n    const cachedTrainingDataNames: string[] = [];\r\n    const beat = 33;\r\n    const isClient = userInterface_isClient();\r\n    const plan = concepts$.plan('Observe Training Data and modify Pages', [\r\n      createStage((concepts, dispatch) => {\r\n        const state = selectUnifiedState<UserInterfaceState>(concepts, semaphore);\r\n        const conceptName = getUnifiedName(concepts, semaphore);\r\n        if (conceptName) {\r\n          if (state && (state.pageStrategies.length === state.pages.length || isClient)) {\r\n            dispatch(axiumRegisterStagePlanner({conceptName, stagePlanner: plan}), {\r\n              iterateStage: true,\r\n            });\r\n          }\r\n        } else {\r\n          plan.conclude();\r\n        }\r\n      }, { selectors: [\r\n        huirth_createPagesSelector(cpts, semaphore) as KeyedSelector,\r\n        huirth_createPageStrategiesSelector(cpts, semaphore) as KeyedSelector,\r\n      ]}),\r\n      createStage((concepts, dispatch) => {\r\n        const state = selectUnifiedState<huirthState & UserInterfaceState>(concepts, semaphore);\r\n        const trainingData = state?.trainingData;\r\n        if (state && trainingData && state?.trainingDataInitialized) {\r\n          const add: {\r\n            i: number,\r\n            name: string\r\n          }[] = [];\r\n          trainingData.forEach((data, i) => {\r\n            add.push({\r\n              i,\r\n              name: data.name\r\n            });\r\n            return data.name;\r\n          });\r\n          if (add.length > 0) {\r\n            const list: ActionStrategy[] = [];\r\n            if (isClient) {\r\n              const currentPage = (selectUnifiedState(concepts, semaphore) as UserInterfaceClientState).currentPage;\r\n              let found = false;\r\n              for (let i = 0; i < add.length; i++) {\r\n                // eslint-disable-next-line max-depth\r\n                if (currentPage === add[i].name) {\r\n                  list.push(huirthAddTrainingDataPageStrategy(\r\n                    add[i].name,\r\n                    huirthGeneratedTrainingDataPageStrategy(trainingData[add[i].i].name),\r\n                    concepts,\r\n                  ));\r\n                  found = true;\r\n                }\r\n                if (currentPage === 'dataManager' && trainingData[add[i].i].type === DataSetTypes.project) {\r\n                  list.push(huirthUpdateProjectStatusStrategy(trainingData[add[i].i].name, ProjectStatus.parsed));\r\n                }\r\n              }\r\n              if (!found) {\r\n                dispatch(axiumKick(), {\r\n                  iterateStage: true\r\n                });\r\n              }\r\n              const strategies = strategySequence(list);\r\n              if (strategies) {\r\n                dispatch(strategyBegin(strategies), {\r\n                  iterateStage: true\r\n                });\r\n                // eslint-disable-next-line max-depth\r\n              }\r\n            } else {\r\n              for (let i = 0; i < add.length; i++) {\r\n                list.push(userInterfaceAddNewPageStrategy(\r\n                  add[i].name,\r\n                  huirthGeneratedTrainingDataPageStrategy(trainingData[add[i].i].name),\r\n                  concepts,\r\n                ));\r\n                cachedTrainingDataNames.push(add[i].name);\r\n              }\r\n              const strategies = strategySequence(list);\r\n              if (strategies) {\r\n                console.log('strategies: ', strategies);\r\n                const action = strategyBegin(strategies);\r\n                dispatch(action, {\r\n                  iterateStage: true\r\n                });\r\n              }\r\n            }\r\n          }\r\n        }\r\n        if (state === undefined) {\r\n          console.log('THIS PLAN SHOULDN\\'T CONCLUDE YET');\r\n          plan.conclude();\r\n        }\r\n      }, {beat}),\r\n      createStage(() => {\r\n        plan.conclude();\r\n      }),\r\n      // createStage((concepts, dispatch, changes) => {\r\n      //   const state = selectUnifiedState<huirthState & UserInterfaceState>(concepts, semaphore);\r\n      //   const trainingData = state?.trainingData;\r\n      //   // const changed = namesChanged(trainingData as TrainingData, cachedTrainingDataNames);\r\n      //   if (state && trainingData && changes.length > 0) {\r\n      //     const [\r\n      //       add,\r\n      //       remove\r\n      //     ] = determineAddRemove(trainingData, cachedTrainingDataNames);\r\n      //     if (add.length > 0 || (remove.length > 0)) {\r\n      //       let list: ActionStrategy[] = [];\r\n      //       if (remove.length > 0) {\r\n      //         cachedTrainingDataNames = cachedTrainingDataNames.filter((n) => {\r\n      //           for (const r of remove) {\r\n      //             if (r.name.toLocaleLowerCase() === n.toLocaleLowerCase()) {\r\n      //               const removeStr = huirthRemoveTrainingDataPageStrategy(n);\r\n      //               removeStr.topic += 'Removing : ' + n;\r\n      //               list = [removeStr, ...list];\r\n      //               return false;\r\n      //             }\r\n      //           }\r\n      //           return true;\r\n      //         });\r\n      //       }\r\n      //       if (add.length > 0) {\r\n      //         for (let i = 0; i < add.length; i++) {\r\n      //           const name = trainingData[add[i].i].name;\r\n      //           cachedTrainingDataNames.push(name);\r\n      //           list.push(userInterfaceAddNewPageStrategy(\r\n      //             name,\r\n      //             huirthGeneratedTrainingDataPageStrategy(name),\r\n      //             concepts,\r\n      //           ));\r\n      //         }\r\n      //       }\r\n      //       if (list.length > 0) {\r\n      //         const strategies = strategySequence(list) as ActionStrategy;\r\n      //         dispatch(strategyBegin(strategies), {\r\n      //           // iterateStage: true\r\n      //           throttle: 0,\r\n      //         });\r\n      //       }\r\n      //     }\r\n      //   } else if (state === undefined) {\r\n      //     plan.conclude();\r\n      //   }\r\n      // }, {beat, selectors: [huirth_createTrainingDataSelector(cpts, semaphore) as KeyedSelector]}),\r\n      // createStage((concepts, dispatch) => {\r\n      //   const state = selectUnifiedState<huirthState & UserInterfaceState>(concepts, semaphore);\r\n      //   if (state) {\r\n      //     const pageNames = state.pages.map(p => p.title);\r\n      //     console.log('pageNames: ', pageNames, cachedTrainingDataNames);\r\n      //     cachedTrainingDataNames = cachedTrainingDataNames.filter(name => pageNames.includes(name));\r\n      //     dispatch(axiumKick(), {\r\n      //       setStage: 2\r\n      //     });\r\n      //   } else {\r\n      //     plan.conclude();\r\n      //   }\r\n      // }, {beat}),\r\n      createStage(() => {\r\n        plan.conclude();\r\n      })\r\n    ]);\r\n  };"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that appends the Axium Dialog supplied via payload into huirth's state.":{"type":"project","content":"/* eslint-disable max-len */\r\nimport {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\n\r\nexport type huirthAppendAxiumDialogTypePayload = {\r\n  dialog: string;\r\n}\r\n\r\nexport const [\r\n  huirthAppendAxiumDialog,\r\n  huirthAppendAxiumDialogType,\r\n  huirthAppendAxiumDialogQuality\r\n] = createQualitySetWithPayload<huirthAppendAxiumDialogTypePayload>({\r\n  type: 'huirth append Axium Dialog',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const dialog = selectPayload<huirthAppendAxiumDialogTypePayload>(action).dialog;\r\n    return {\r\n      ...state,\r\n      dialog: state.dialog + dialog\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that set each entry of the data set selection to false.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\n\r\nexport const [\r\n  huirthClearDataSetSelection,\r\n  huirthClearDataSetSelectionType,\r\n  huirthClearDataSetSelectionQuality\r\n] = createQualitySet({\r\n  type: 'huirth clear the current data set selection',\r\n  reducer: (state: huirthState, _: Action): huirthState => {\r\n    const dataSetSelection = state.dataSetSelection.map(() => false);\r\n    return {\r\n      ...state,\r\n      dataSetSelection\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality that will create the Data Manager's initial slice and append to the page composition data field.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport {\r\n  createQualitySetComponent,\r\n  selectComponentPayload,\r\n  userInterface_appendCompositionToPage\r\n} from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthDataManagerBegin,\r\n  huirthDataManagerBeginType,\r\n  huirthDataManagerBeginQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for DataManagerBegin',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(action => {\r\n    const payload = selectComponentPayload(action);\r\n    const id = '#beginDataManagerID' + payload.pageTitle;\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n        id,\r\n        universal: false,\r\n        boundSelectors: [],\r\n        action: act(payload),\r\n        html: /*html*/`\r\n  <div id='${id}' class=\"carbon-fiber\">\r\n    <section class=\"flex flex-col items-center min-h-screen text-white bg-center bg-blend-overlay md:bg-fixed bg-neutral-900/60\">\r\n      <div class =\"flex-1 mb-12 w-[50rem] max-w-5xl m-10 pt-10 pb-10 bg-gray-800/90 rounded\">\r\n        <h1 class=\"text-3xl text-center p-4 mb-2\">Data Manager</h1>\r\n  `\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality that will create the Data Manager's body slice and bind all essential functions to properly manage a Stratimux project data.":{"type":"project","content":"import {\r\n  KeyedSelector,\r\n  UnifiedSubject,\r\n  createMethodDebounceWithConcepts,\r\n  nullReducer,\r\n  selectUnifiedState,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createBinding, createBoundSelectors, createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\nimport { elementEventBinding } from '../../../../../model/html';\r\nimport { huirthState } from '../../../huirth.concept';\r\nimport {\r\n  huirth_createDataSetSelectionSelector,\r\n  huirth_createHuirthStatusSelector,\r\n  huirth_createPossibleProjectValidSelector,\r\n  huirth_createProjectStatusSelector,\r\n  huirth_createSelectedTransformationSelector,\r\n  huirth_createStratimuxStatusSelector,\r\n  huirth_createTrainingDataSelector\r\n} from '../../../huirth.selector';\r\nimport { huirthNewDataSet } from '../../newDataSet.quality';\r\nimport { PhuirEProjects, ProjectStatus, dataSetNameID, dataSetSelectionID, generateNumID } from '../../../huirth.model';\r\nimport { huirthUpdateDataSetName } from '../../updateDataSetName.quality';\r\nimport { huirthTriggerInstallGitRepository } from '../../triggerInstallGitRepository.quality';\r\nimport { huirthUpdateDataSetSelection } from '../../updateDataSetSelection.quality';\r\nimport { huirthSendTriggerParseRepositoryStrategy } from '../../sendTriggerParseRepositoryStrategy.quality';\r\nimport { huirthSendTriggerSaveDataSetSelectionStrategy } from '../../sendTriggerSaveDataSetSelectionStrategy.quality';\r\nimport { huirthRemoveDataSetSelection } from '../../removeDataSetSelection.quality';\r\nimport { determineProjectControls } from './dataManagerProjectControls.model';\r\nimport { huirthSetPossibleProject } from '../../setPossibleProject.quality';\r\nimport { huirthFilterTriggerInstallGitRepository } from '../../filterTriggerInstallGitRepository.quality';\r\nimport { huirthSetSelectedTransformation } from '../../setSelectedTransformation.quality';\r\nimport { huirthSendTriggerTransformationStrategy } from '../../../strategies/server/triggerTransformationStrategy.helper';\r\nimport { huirthSendTriggerSelectedTransformationStrategy } from '../../sendTriggerSelectedTransformationStrategy.quality';\r\nimport { huirthSendTriggerGitPullRepositoryStrategy } from '../../../strategies/server/triggerGitPullRepositoryStrategy.helper';\r\n\r\nexport const [\r\n  huirthDataManagerContent,\r\n  huirthDataManagerContentType,\r\n  huirthDataManagerContentQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for DataManagerContent',\r\n  reducer: nullReducer,\r\n  componentCreator: (act, concepts$, _semaphore) =>\r\n    createMethodDebounceWithConcepts((action, concepts, semaphore) => {\r\n      console.log('HITTING DATA MANAGER COMPONENT');\r\n      const payload = selectComponentPayload(action);\r\n      const id = '#dataManagerID' + payload.pageTitle;\r\n      const projectInputID = '#projectInputID';\r\n      const saveID = '#saveID';\r\n      const addEntryID = '#addEntry' + payload.pageTitle;\r\n      const removeID = '#removeID';\r\n      const transformationSelectionID = '#transformationSelectionID';\r\n      const triggerCreateTransformationDataSetID = '#triggerCreateTransformationDataSetID';\r\n      const installProjectID = '#installProjectID';\r\n      const installStratimuxID = '#install_' + PhuirEProjects.stratimux;\r\n      const pullStratimuxID = '#pull_' + PhuirEProjects.stratimux;\r\n      let finalStratimuxID = '#stratimuxID';\r\n      // eslint-disable-next-line quotes\r\n      let finalStratimuxNote = \"stratimux\";\r\n      const parseStratimuxID = '#parse_' + PhuirEProjects.stratimux;\r\n      const installHuirth_ID = '#install_' + PhuirEProjects.huirth;\r\n      const pullHuirth_ID = '#pull_' + PhuirEProjects.huirth;\r\n      let finalHuirth_ID = '#huirth_ID';\r\n      let finalHuirth_note = 'Huirth';\r\n      const parseHuirth_ID = '#parse_' + PhuirEProjects.huirth;\r\n      if (action.strategy) {\r\n        const {\r\n          trainingData,\r\n          stratimuxStatus,\r\n          huirthStatus,\r\n          dataSetSelection,\r\n          projectsStatuses,\r\n          possibleProject,\r\n          possibleProjectValid,\r\n          selectedTransformation,\r\n          transformationStrategies\r\n        } = (selectUnifiedState<huirthState>(concepts, semaphore) as huirthState);\r\n        const anySelected = (() => {\r\n          for (const selected of dataSetSelection) {\r\n            if (selected) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        })();\r\n        let finalOutput = '';\r\n        const [finalProjects, bindingsArray] = determineProjectControls(projectsStatuses);\r\n        for (let i = 0; i < trainingData.length; i++) {\r\n          const elementID = generateNumID(i);\r\n          bindingsArray.push({\r\n            elementId: dataSetNameID + elementID,\r\n            eventBinding: elementEventBinding.onchange,\r\n            action: huirthUpdateDataSetName({index: i})\r\n          });\r\n          bindingsArray.push({\r\n            elementId: dataSetSelectionID + elementID,\r\n            eventBinding: elementEventBinding.onchange,\r\n            action: huirthUpdateDataSetSelection({index: i})\r\n          });\r\n          finalOutput += /*html*/`\r\n<div class=\"w-full ml-4 mt-2 mb-2\">\r\n  <div class=\"relative flex items-center h-10 w-full min-w-[200px]\">\r\n    <div class=\"absolute top-2/4 right-52 grid h-5 w-5 -translate-y-2/4 place-items-center text-blue-gray-500\">\r\n      <i class=\"fa-solid fa-book\"></i>\r\n    </div>\r\n    <input\r\n      id=\"${dataSetNameID + elementID}\"\r\n      class=\"${'peer h-full w-full rounded-[7px] border border-blue-gray-200 border-t-transparent bg-white ' +\r\n'px-3 py-2.5 !pr-9 font-sans text-sm font-normal text-blue-gray-700 outline outline-0 transition-all ' +\r\n'placeholder-shown:border placeholder-shown:border-blue-gray-200 placeholder-shown:border-t-blue-gray-200 ' +\r\n'focus:border-2 focus:border-pink-500 focus:border-t-transparent focus:outline-0 disabled:border-0 disabled:bg-blue-gray-50'}\"\r\n      value=\"${trainingData[i].name}\"\r\n    />\r\n    <button class=\"ml-4 italic cursor-pointer bg-purple-800/5 hover:bg-purple-500 text-purple-50 font-semibold hover:text-white py-2 px-4 border border-purple-400 hover:border-transparent border-solid rounded\">\r\n      <a href=\"/${trainingData[i].name}\"><i class=\"fa-solid fa-link\"></i></a>\r\n    </button>\r\n    <input\r\n      id=\"${dataSetSelectionID + elementID}\"\r\n      type=\"checkbox\"\r\n      class=\"w-40 bg-red-100 border-red-300 text-red-500 focus:ring-red-200\"\r\n      ${dataSetSelection[i] ? 'checked' : ''}\r\n    />\r\n  </div>\r\n</div>\r\n        `;\r\n        }\r\n        finalOutput += '</div>';\r\n        bindingsArray.push({\r\n          action: huirthNewDataSet({\r\n            priority: 1000\r\n          }),\r\n          elementId: addEntryID,\r\n          eventBinding: elementEventBinding.onclick\r\n        });\r\n        const stratimuxSaved = trainingData.filter(d => d.name.toLowerCase() === PhuirEProjects.stratimux.toLocaleLowerCase()).length > 0;\r\n        const huirthSaved = trainingData.filter(d => d.name.toLowerCase() === PhuirEProjects.huirth.toLocaleLowerCase()).length > 0;\r\n        if (stratimuxStatus === ProjectStatus.notInstalled) {\r\n          bindingsArray.push({\r\n            action: huirthTriggerInstallGitRepository({\r\n              url: PhuirEProjects.stratimuxURL,\r\n              name: PhuirEProjects.stratimux\r\n            }),\r\n            elementId: installStratimuxID,\r\n            eventBinding: elementEventBinding.onclick\r\n          });\r\n          finalStratimuxID = installStratimuxID;\r\n          finalStratimuxNote = 'Install Stratimux';\r\n        } else if (stratimuxStatus === ProjectStatus.installed && !stratimuxSaved) {\r\n          bindingsArray.push({\r\n            action: huirthSendTriggerParseRepositoryStrategy({name: PhuirEProjects.stratimux}),\r\n            elementId: parseStratimuxID,\r\n            eventBinding: elementEventBinding.onclick\r\n          });\r\n          finalStratimuxID = parseStratimuxID;\r\n          finalStratimuxNote = 'Parse Stratimux';\r\n        } else if (stratimuxStatus === ProjectStatus.saved || stratimuxStatus === ProjectStatus.parsed) {\r\n          bindingsArray.push({\r\n            action: huirthSendTriggerGitPullRepositoryStrategy(PhuirEProjects.stratimux),\r\n            elementId: pullStratimuxID,\r\n            eventBinding: elementEventBinding.onclick\r\n          });\r\n          finalStratimuxID = pullStratimuxID;\r\n          finalStratimuxNote = 'Pull Stratimux';\r\n        }\r\n        if (huirthStatus === ProjectStatus.notInstalled) {\r\n          bindingsArray.push({\r\n            action: huirthTriggerInstallGitRepository({\r\n              url: PhuirEProjects.huirth_URL,\r\n              name: PhuirEProjects.huirth\r\n            }),\r\n            elementId: installHuirth_ID,\r\n            eventBinding: elementEventBinding.onclick\r\n          });\r\n          finalHuirth_ID = installHuirth_ID;\r\n          finalHuirth_note = 'Install Huirth';\r\n        } else if (huirthStatus === ProjectStatus.installed && !huirthSaved) {\r\n          bindingsArray.push({\r\n            action: huirthSendTriggerParseRepositoryStrategy({name: PhuirEProjects.huirth}),\r\n            elementId: parseHuirth_ID,\r\n            eventBinding: elementEventBinding.onclick\r\n          });\r\n          finalHuirth_ID = parseHuirth_ID;\r\n          finalHuirth_note = 'Parse Huirth';\r\n        } else if (huirthStatus === ProjectStatus.saved || huirthStatus === ProjectStatus.parsed) {\r\n          bindingsArray.push({\r\n            action: huirthSendTriggerGitPullRepositoryStrategy(PhuirEProjects.huirth),\r\n            elementId: pullHuirth_ID,\r\n            eventBinding: elementEventBinding.onclick\r\n          });\r\n          finalHuirth_ID = pullHuirth_ID;\r\n          finalHuirth_note = 'Pull Huirth';\r\n        }\r\n        bindingsArray.push({\r\n          action: huirthSendTriggerSaveDataSetSelectionStrategy(),\r\n          elementId: saveID,\r\n          eventBinding: elementEventBinding.onclick\r\n        });\r\n        bindingsArray.push({\r\n          action: huirthRemoveDataSetSelection(),\r\n          elementId: removeID,\r\n          eventBinding: elementEventBinding.onclick\r\n        });\r\n        bindingsArray.push({\r\n          action: huirthSetPossibleProject(),\r\n          elementId: projectInputID,\r\n          eventBinding: elementEventBinding.onkeyup\r\n        });\r\n        bindingsArray.push({\r\n          action: huirthSetPossibleProject(),\r\n          elementId: projectInputID,\r\n          eventBinding: elementEventBinding.onpaste\r\n        });\r\n        bindingsArray.push({\r\n          action: huirthFilterTriggerInstallGitRepository(),\r\n          elementId: installProjectID,\r\n          eventBinding: elementEventBinding.onclick\r\n        });\r\n        bindingsArray.push({\r\n          action: huirthSetSelectedTransformation(),\r\n          elementId: transformationSelectionID,\r\n          eventBinding: elementEventBinding.onchange\r\n        });\r\n        bindingsArray.push({\r\n          action: huirthSendTriggerSelectedTransformationStrategy(),\r\n          elementId: triggerCreateTransformationDataSetID,\r\n          eventBinding: elementEventBinding.onclick\r\n        });\r\n        const bindings = createBinding(bindingsArray);\r\n        // console.log('Check bindings', bindings);\r\n        const strategy = strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n          id,\r\n          bindings,\r\n          universal: false,\r\n          boundSelectors: [\r\n            // START HERE\r\n            createBoundSelectors(id, huirthDataManagerContent(payload), [\r\n              huirth_createTrainingDataSelector(concepts, semaphore) as KeyedSelector,\r\n              huirth_createStratimuxStatusSelector(concepts, semaphore) as KeyedSelector,\r\n              huirth_createHuirthStatusSelector(concepts, semaphore) as KeyedSelector,\r\n              huirth_createDataSetSelectionSelector(concepts, semaphore) as KeyedSelector,\r\n              huirth_createProjectStatusSelector(concepts, semaphore) as KeyedSelector,\r\n              huirth_createPossibleProjectValidSelector(concepts, semaphore) as KeyedSelector,\r\n              huirth_createSelectedTransformationSelector(concepts, semaphore) as KeyedSelector\r\n            ])\r\n          ],\r\n          action: act(payload),\r\n          html: /*html*/`\r\n        <div class=\"flex flex-col items-center text-black\" id='${id}'>\r\n          <button class=\"italic cursor-not-allowed mb-4 mt-2 center-m bg-white/5 hover:bg-slate-500 text-slate-500 font-semibold hover:text-red-400 py-2 px-4 border border-slate-400 hover:border-transparent border-dashed rounded\">\r\n            Open <i class=\"fa-solid fa-folder\"></i>\r\n          </button>\r\n          <div class=\"p-8 pt-2 mt-2 bg-black/10 border border-t-2 rounded border-gray-700 [&>*:nth-child(3n+3)]:text-sky-400 [&>*:nth-child(2n+2)]:text-orange-400\">\r\n             <div class=\"m-4 flex-none flex items-center justify-end w-full\">\r\n              <h2 class=\"w-full text-white text-center italic\">${stratimuxStatus}</h2>\r\n              <button\r\n                id=\"${finalStratimuxID}\"\r\n                class=\"w-44 m-2 items-center bg-red-800/5 hover:bg-red-500 text-red-50 hover:text-white font-semibold py-2 px-4 border border-red-500 hover:border-transparent rounded\"\r\n              >\r\n                ${finalStratimuxNote} <img class=\"inline w-[27px]\" src=\"/static/Stratimux-Spiral.png\">\r\n              </button>\r\n            </div>\r\n            <div class=\"m-4 flex-none flex items-center justify-end w-full\">\r\n              <h2 class=\"w-full text-white text-center italic\">${huirthStatus}</h2>\r\n              <button\r\n                id=\"${finalHuirth_ID}\"\r\n                class=\"w-44 m-2 items-center bg-yellow-800/5 hover:bg-yellow-500 text-yellow-50 hover:text-white font-semibold py-2 px-4 border border-yellow-500 hover:border-transparent rounded\"\r\n              >\r\n                ${finalHuirth_note} <img class=\"inline w-[27px]\" src=\"/static/Huirth-Tiny.png\">\r\n              </button>\r\n            </div>\r\n            ${finalProjects}\r\n            <div class=\"m-4 flex-none flex items-center w-full\">\r\n              <div class=\"mr-4 relative h-10 w-full min-w-[200px]\">\r\n                <div class=\"absolute top-2/4 right-3 grid h-5 w-5 -translate-y-2/4 place-items-center text-orange-500\">\r\n                  <i class=\"fa-brands fa-github\"></i>\r\n                </div>\r\n                <input\r\n                  id=\"${projectInputID}\"\r\n                  class=\"${possibleProjectValid ? 'peer h-full w-full rounded-[7px] border border-orange-200 border-t-transparent bg-white ' +\r\n'px-3 py-2.5 !pr-9 font-sans text-sm font-normal text-blue-gray-700 outline outline-0 transition-all placeholder-shown:border ' +\r\n'placeholder-shown:border-blue-gray-200 placeholder-shown:border-t-blue-gray-200 focus:border-2 focus:border-pink-500 ' +\r\n'focus:border-t-transparent focus:outline-0 disabled:border-0 disabled:bg-blue-gray-50' : 'peer h-full w-full rounded-[7px] border border-orange-200 border-t-transparent bg-white ' +\r\n'px-3 py-2.5 !pr-9 font-sans text-sm font-normal text-red-800 outline outline-0 transition-all placeholder-shown:border ' +\r\n'placeholder-shown:border-blue-gray-200 placeholder-shown:border-t-blue-gray-200 focus:border-2 focus:border-pink-500 ' +\r\n'focus:border-t-transparent focus:outline-0 disabled:border-0 disabled:bg-blue-gray-50'}\"\r\n                  placeholder=\"${possibleProject !== 'INVALID' ? 'Paste Git Repository' : 'INVALID PASTE NEW GIT REPO'}\"\r\n                  value=\"${possibleProject !== 'INVALID' ? possibleProject : ''}\"\r\n                />\r\n              </div>\r\n              <button\r\n                id=\"${installProjectID}\"\r\n                class=\"${\r\n  possibleProjectValid ?\r\n    'w-44 m-2 bg-/5 bg-orange-800/5 hover:bg-orange-500 text-orange-50 hover:text-white font-semibold py-2 px-4 border border-orange-500 hover:border-transparent rounded'\r\n    :\r\n    'w-44 m-2 bg-/5 cursor-not-allowed bg-gray-800 hover:bg-gray-500 text-gray-50 hover:text-white font-semibold py-2 px-4 border border-gray-500 hover:border-transparent rounded'\r\n}\"\r\n              >\r\n                Project <i class=\"fa-solid fa-plus\"></i>\r\n              </button>\r\n            </div>\r\n            <div class=\"m-4 flex-none flex items-center w-full\">\r\n              <select id=\"${transformationSelectionID}\" class=\"${'mr-4 bg-white border border-gray-300 text-sm rounded-lg focus:ring-blue-500 ' +\r\n'focus:border-blue-500 block w-full p-2.5 dark:border-gray-600 dark:placeholder-gray-400 dark:focus:ring-blue-500' +\r\n'dark:focus:border-blue-500'}\">\r\n            <option>Select a Data Transformation Strategy</option>\r\n${\r\n  transformationStrategies.map(str => `<option ${selectedTransformation === str ? 'selected' : ''} value=\"${str}\"> ${str}</option>`).join('')\r\n}\r\n              </select>\r\n              <button\r\n                id=\"${triggerCreateTransformationDataSetID}\"\r\n                class=\"w-44 m-2 bg-blue-800/5 hover:bg-blue-500 text-blue-50 hover:text-white font-semibold py-2 px-4 border border-blue-500 hover:border-transparent rounded\"\r\n              >\r\n                Strategy <i class=\"fa-solid fa-plus\"></i>\r\n              </button>\r\n            </div>\r\n            <h1 class=\"m-4 text-white text-3xl w-full text-center\">Data Sets</h1>\r\n            <div class=\"mb-4 flex-none flex items-center w-full\">\r\n              <button id=${addEntryID} class=\"mb-8 mt-2 center-m bg-green-800/5 hover:bg-green-500 text-green-50 font-semibold hover:text-white py-2 px-4 border border-green-500 hover:border-transparent rounded\">\r\n                Custom Data Set <i class=\"fa-solid fa-plus\"></i>\r\n              </button>\r\n              <button class=\"italic cursor-not-allowed mb-8 mt-2 center-m bg-white/5 hover:bg-slate-500 text-slate-500 font-semibold hover:text-red-400 py-2 px-4 border border-slate-400 hover:border-transparent border-dashed rounded\">\r\n                Load <i class=\"fa-solid fa-folder-open\"></i>\r\n              </button>\r\n              <button class=\"italic cursor-not-allowed mb-8 mt-2 center-m bg-white/5 hover:bg-slate-500 text-slate-500 font-semibold hover:text-red-400 py-2 px-4 border border-slate-400 hover:border-transparent border-dashed rounded\">\r\n                Unify <i class=\"fa-solid fa-code-merge\"></i>\r\n              </button>\r\n${\r\n  !anySelected ?\r\n  /*html*/`\r\n              <button class=\"italic cursor-not-allowed mb-8 mt-2 center-m bg-white/5 hover:bg-slate-500 text-slate-500 font-semibold hover:text-red-400 py-2 px-4 border border-slate-400 hover:border-transparent border-dashed rounded\">\r\n                Remove <i class=\"fa-solid fa-trash\"></i>\r\n              </button>\r\n` : /*html*/`\r\n              <button id=\"${removeID}\"\r\n                class=\"italic cursor-pointer mb-8 mt-2 center-m bg-red-800/5 hover:bg-red-800 text-white font-semibold hover:text-black py-2 px-4 border border-red-800 hover:border-transparent rounded\">\r\n                Remove <i class=\"fa-solid fa-trash\"></i>\r\n              </button>\r\n`\r\n}\r\n${\r\n  !anySelected ?\r\n  /*html*/`\r\n              <button class=\"italic cursor-not-allowed mb-8 mt-2 center-m bg-white/5 hover:bg-slate-500 text-slate-500 font-semibold hover:text-red-400 py-2 px-4 border border-slate-400 hover:border-transparent border-dashed rounded\">\r\n                Save <i class=\"fa-solid fa-floppy-disk\"></i>\r\n              </button>\r\n` : /*html*/`\r\n              <button id=\"${saveID}\"\r\n                class=\"italic cursor-pointer mb-8 mt-2 center-m bg-white/5 hover:bg-white text-white font-semibold hover:text-black py-2 px-4 border border-white hover:border-transparent rounded\">\r\n                Save <i class=\"fa-solid fa-floppy-disk\"></i>\r\n              </button>\r\n`\r\n}\r\n            </div>\r\n            ${finalOutput}\r\n          </div>\r\n        </div>\r\n  `\r\n        }));\r\n        return strategy;\r\n      }\r\n      return action;\r\n    }, concepts$ as UnifiedSubject, _semaphore as number, 50)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality that will create the final slice for the Data Manager Component.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthDataManagerEnd,\r\n  huirthDataManagerEndType,\r\n  huirthDataManagerEndQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for DataManagerEnd',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(action => {\r\n    const payload = selectComponentPayload(action);\r\n    const id = '';\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n        id,\r\n        boundSelectors: [],\r\n        universal: false,\r\n        action: act(payload),\r\n        html: /*html*/`\r\n      </div>\r\n    </section>\r\n  </div>\r\n          `\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality to create the first slice of the DataSet Component.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthDataSetBegin,\r\n  huirthDataSetBeginType,\r\n  huirthDataSetBeginQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for DataSetBegin',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(action => {\r\n    const payload = selectComponentPayload(action);\r\n    const id = '#beginDataSetID' + payload.pageTitle;\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n        id,\r\n        boundSelectors: [],\r\n        universal: false,\r\n        action: act(payload),\r\n        html: /*html*/`\r\n  <div id='${id}' class=\"carbon-fiber\">\r\n    <section class=\"flex flex-col items-center min-h-screen text-white bg-center bg-blend-overlay md:bg-fixed bg-neutral-900/60\">\r\n      <div class =\"flex-1 mb-12 w-[42rem] max-w-5xl m-10 pt-10 pb-10 bg-gray-800/90 rounded\">\r\n        <h1 class=\"text-3xl text-center p-4\">DataSet: ${payload.pageTitle}</h1>\r\n  `\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality to create the content slice for the DataSet Component that binds all necessary functionality.":{"type":"project","content":"import {\r\n  Action,\r\n  KeyedSelector,\r\n  UnifiedSubject,\r\n  createMethodWithConcepts,\r\n  nullReducer,\r\n  selectUnifiedState,\r\n  strategyData_appendFailure,\r\n  strategyFailed,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createBinding, createBoundSelectors, createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\nimport { elementEventBinding } from '../../../../../model/html';\r\nimport { huirthState } from '../../../huirth.concept';\r\nimport { BaseDataSet, chosenID, contentID, generateNumID, promptID, rejectedID } from '../../../huirth.model';\r\nimport { huirthNewDataSetEntry } from '../../newDataSetEntry.quality';\r\nimport { huirth_createDataSetSelector, huirth_createTrainingDataSelector } from '../../../huirth.selector';\r\nimport { huirthUpdateDataSetContents } from '../../updateDataSetContents.quality';\r\nimport { huirthUpdateDataSetPrompt } from '../../updateDataSetPrompt.quality';\r\n\r\nexport const [\r\n  huirthDataSetContent,\r\n  huirthDataSetContentType,\r\n  huirthDataSetContentQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for DataSetContent',\r\n  reducer: nullReducer,\r\n  componentCreator: (act, concepts$, _semaphore) =>\r\n    createMethodWithConcepts((action, concepts, semaphore) => {\r\n      const payload = selectComponentPayload(action);\r\n      const id = '#dataSetID' + payload.pageTitle;\r\n      const addEntryID = '#addDataEntry' + payload.pageTitle;\r\n      if (action.strategy) {\r\n        const trainingData = (selectUnifiedState<huirthState>(concepts, semaphore) as huirthState).trainingData;\r\n        let finalOutput = '';\r\n        const bindingsArray: {\r\n          elementId: string;\r\n          eventBinding: elementEventBinding;\r\n          action: Action;\r\n        }[] = [];\r\n        let dataSet: BaseDataSet[] | undefined;\r\n        let index = -1;\r\n        for (const [i, data] of trainingData.entries()) {\r\n          if (data.name === payload.pageTitle) {\r\n            dataSet = data.dataSet;\r\n            console.log('CHECK DATASET IN CONTENT', data.name, payload.pageTitle, dataSet.length, i);\r\n            index = i;\r\n            break;\r\n          }\r\n        }\r\n        // console.log('CHECK DATASET IN CONTENT', dataSet);\r\n        if (dataSet) {\r\n          // console.log('CHECK TRAINING DATA INFO', trainingData[index].name, trainingData[index].type);\r\n          for (const [i, data] of dataSet.entries()) {\r\n            // So I don't break anything in the final sprint. Can save pagination if I have time today or tomorrow.\r\n            if (i === 10) {\r\n              break;\r\n            }\r\n            const elementID = generateNumID(i);\r\n            bindingsArray.push({\r\n              elementId: promptID + elementID,\r\n              eventBinding: elementEventBinding.onchange,\r\n              action: huirthUpdateDataSetPrompt({index, dataSetIndex: i})\r\n            });\r\n            bindingsArray.push({\r\n              elementId: contentID + elementID,\r\n              eventBinding: elementEventBinding.onchange,\r\n              action: huirthUpdateDataSetContents({index, dataSetIndex: i})\r\n            });\r\n            finalOutput += /*html*/`\r\n<div class=\"text-black m-4\">\r\n  <label class=\"text-white pl-2 translate-y-2\">\r\n    Prompt\r\n  </label>\r\n  <input\r\n    id=\"${promptID + elementID}\"\r\n    class=\"${'input-' + i + ' mb-4 peer h-full w-full rounded-[7px] border border-blue-gray-200 border-t-transparent' +\r\n'bg-white px-3 py-2.5 font-sans text-sm font-normal text-blue-gray-700 outline outline-0 transition-all' +\r\n'placeholder-shown:border placeholder-shown:border-blue-gray-200 placeholder-shown:border-t-blue-gray-200' +\r\n'focus:border-2 focus:border-teal-500 focus:border-t-transparent focus:outline-0 disabled:border-0 disabled:bg-blue-gray-50'}\"\r\n    value=\"${data.prompt + ''}\"\r\n  />\r\n  <label class=\"text-white pl-2 translate-y-2\">\r\n    Content\r\n  </label>\r\n  <textarea contentEditable=\"true\" id=\"${contentID + elementID}\" class=\"${'peer h-full min-h-[300px] w-full resize-none rounded-[7px] ' +\r\n'border border-blue-gray-200 border-t-transparent bg-white px-3 py-2.5 font-sans text-sm font-normal' +\r\n'text-blue-gray-700 outline outline-0 transition-all placeholder-shown:border placeholder-shown:border-blue-gray-200' +\r\n'placeholder-shown:border-t-blue-gray-200 focus:border-2 focus:border-pink-500 focus:border-t-transparent focus:outline-0' +\r\n'disabled:resize-none disabled:border-0 disabled:bg-blue-gray-50'}\" id=\"${chosenID + elementID}\" rows=\"4\" cols=\"50\"\r\n>${data.content}</textarea>\r\n</div>\r\n`;\r\n          //\r\n          }\r\n        }\r\n        bindingsArray.push({\r\n          action: huirthNewDataSetEntry({index}),\r\n          elementId: addEntryID,\r\n          eventBinding: elementEventBinding.onclick\r\n        });\r\n        const bindings = createBinding(bindingsArray);\r\n        // console.log('Check bindings', bindings);\r\n        if (index !== -1) {\r\n          const strategy = strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n            id,\r\n            bindings,\r\n            universal: false,\r\n            boundSelectors: [\r\n              // START HERE\r\n              createBoundSelectors(id, huirthDataSetContent(payload), [\r\n                huirth_createTrainingDataSelector(concepts, semaphore) as KeyedSelector,\r\n                huirth_createDataSetSelector(concepts, semaphore, index) as KeyedSelector\r\n              ])\r\n            ],\r\n            action: act(payload),\r\n            html: /*html*/`\r\n          <div class=\"flex flex-col items-center\" id='${id}'>\r\n            <div class=\"flex-none flex items-center w-full\">\r\n              <button id=${addEntryID} class=\"mb-8 mt-2 center-m bg-green-800/5 hover:bg-green-500 text-green-50 font-semibold hover:text-white py-2 px-4 border border-green-500 hover:border-transparent rounded\">\r\n                Entry <i class=\"fa-solid fa-plus\"></i>\r\n              </button>\r\n              <button class=\"italic cursor-not-allowed mb-8 mt-2 center-m bg-white/5 hover:bg-slate-500 text-slate-500 font-semibold hover:text-red-400 py-2 px-4 border border-slate-400 hover:border-transparent border-dashed rounded\">\r\n                Save <i class=\"fa-solid fa-floppy-disk\"></i>\r\n              </button>\r\n            </div>\r\n            <h1>Entries: ${trainingData[index] && trainingData[index].dataSet ? trainingData[index].dataSet.length : 'Data Set Removed'}</h1>\r\n            <h1>Page: ${trainingData[index] ? trainingData[index].index + 1 + '/' + Math.round((trainingData[index].dataSet.length / 10) + 1) : '0/0'}</h1>\r\n            <div class=\"flex-1 p-4 pt-0 [&>*:nth-child(3n+3)]:text-sky-400 [&>*:nth-child(2n+2)]:text-orange-400\">\r\n              ${finalOutput}\r\n            </div>\r\n          </div>\r\n    `\r\n          }));\r\n          return strategy;\r\n        } else {\r\n          return strategyFailed(action.strategy, strategyData_appendFailure(action.strategy, 'Data Set for ' + payload.pageTitle + ' not found!'));\r\n        }\r\n      }\r\n      return action;\r\n    }, concepts$ as UnifiedSubject, _semaphore as number)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality to create the final slice of the DataSet Component with the necessary closing element tags.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthDataSetEnd,\r\n  huirthDataSetEndType,\r\n  huirthDataSetEndQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for DataSetEnd',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(action => {\r\n    const payload = selectComponentPayload(action);\r\n    const id = '';\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n        id,\r\n        boundSelectors: [],\r\n        universal: false,\r\n        action: act(payload),\r\n        html: /*html*/`\r\n      </div>\r\n    </section>\r\n  </div>\r\n          `\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality for the first slice of the Dialog Component.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthIndexDialogBegin,\r\n  huirthIndexDialogBeginType,\r\n  huirthIndexDialogBeginQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for IndexDialogBegin',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(action => {\r\n    const payload = selectComponentPayload(action);\r\n    const id = '#dialogBeginID';\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n        id,\r\n        boundSelectors: [],\r\n        universal: false,\r\n        action: act(payload),\r\n        html: /*html*/`\r\n<div id='${id}' class=\"carbon-fiber\">\r\n  <section class=\"flex flex-col items-center bg-gradient-to-br from-60% from-black to-transparent to-black min-h-screen text-white\">\r\n    <div class =\"flex-1 mb-12 max-w-3xl m-10 pt-10 pb-10\">\r\n      <h1 class=\"text-3xl text-center p-4\">Stratimux Dialog Output</h1>\r\n`\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality for the content slice of the Dialog Component with the necessary bindings and selectors.":{"type":"project","content":"import {\r\n  Concepts,\r\n  CounterState,\r\n  KeyedSelector,\r\n  UnifiedSubject,\r\n  counterAdd,\r\n  counterSubtract,\r\n  createMethodDebounceWithConcepts,\r\n  nullReducer,\r\n  selectUnifiedState,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createBinding, createBoundSelectors, createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage, userInterface_isClient } from '../../../../../model/userInterface';\r\nimport { elementEventBinding } from '../../../../../model/html';\r\nimport { huirthState } from '../../../huirth.concept';\r\nimport { huirth_createCountSelector, huirth_createDialogSelector } from '../../../huirth.selector';\r\nimport { huirthTriggerMinusCountingStrategy } from '../../triggerMinusCounterStrategy.quality';\r\nimport { huirthTriggerPlusCountingStrategy } from '../../triggerPlusCounterStrategy.quality';\r\nimport { huirthTriggerRandomCountingStrategy } from '../../triggerRandomCounterStrategy.quality';\r\nimport { Subject } from 'rxjs';\r\n\r\nexport const [\r\n  huirthIndexDialogContent,\r\n  huirthIndexDialogContentType,\r\n  huirthIndexDialogContentQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for IndexDialogContent',\r\n  reducer: nullReducer,\r\n  componentCreator: (act, concepts$?: Subject<Concepts>, _semaphore?: number) =>\r\n    createMethodDebounceWithConcepts((action, concepts, semaphore) => {\r\n      const payload = selectComponentPayload(action);\r\n      const id = '#dialogID';\r\n      const strategyId = '#strategyID';\r\n      const strategyPlusId = '#strategyPlusID';\r\n      const strategyMinusId = '#strategyMinusID';\r\n      const addId = '#addID';\r\n      const subtractId = '#subtractID';\r\n\r\n      if (action.strategy) {\r\n        const isClient = userInterface_isClient();\r\n        if (isClient !== undefined) {\r\n          const dialog = (selectUnifiedState<huirthState>(concepts, semaphore) as huirthState).dialog.trim();\r\n          const counter = selectUnifiedState<CounterState>(concepts, semaphore);\r\n          const count = counter ? counter.count : 0;\r\n          let finalDialog = '';\r\n          // if (isClient) {\r\n          let index = 0;\r\n          dialog.split('\\n').forEach((paragraph) => {\r\n            if (paragraph.trim().includes('User Interface atomic update compositions.')) {\r\n              const split = (paragraph.trim().split('User Interface atomic update compositions.'));\r\n              if (split[0].trim().length > 0) {\r\n                index++;\r\n                finalDialog += /*html*/`\r\n                <p class=\"pb-2 indent-4\">\r\n                  ${index + ': ' + split[0]}\r\n                </p>\r\n              `;\r\n              }\r\n              if (split[1].trim().length > 0) {\r\n                index++;\r\n                finalDialog += /*html*/`\r\n                <p class=\"pb-2 indent-4\">\r\n                  ${index + ': ' + split[1]}\r\n                </p>\r\n              `;\r\n              }\r\n            } else {\r\n              index++;\r\n              finalDialog += /*html*/`\r\n              <p class=\"pb-2 indent-4\">\r\n                ${index + ': ' + paragraph}\r\n              </p>\r\n            `;\r\n            }\r\n          });\r\n          if (isClient) {\r\n            setTimeout(() => {\r\n              const element = document.getElementById(id + 'scroll');\r\n              if (element) {\r\n                element.scrollTop = element.scrollHeight;\r\n              }\r\n            }, 20);\r\n          }\r\n          // }\r\n          const boundSelectors = isClient ? [\r\n            createBoundSelectors(id, huirthIndexDialogContent(payload), [\r\n            huirth_createDialogSelector(concepts, semaphore) as KeyedSelector,\r\n            huirth_createCountSelector(concepts, semaphore) as KeyedSelector\r\n            ])\r\n          ] : [createBoundSelectors(id, huirthIndexDialogContent(payload), [\r\n            huirth_createCountSelector(concepts, semaphore) as KeyedSelector\r\n          ])];\r\n          const strategy = strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n            id,\r\n            bindings: createBinding([\r\n              {elementId: strategyId, action: huirthTriggerRandomCountingStrategy(), eventBinding: elementEventBinding.onclick},\r\n              {elementId: strategyPlusId, action: huirthTriggerPlusCountingStrategy(), eventBinding: elementEventBinding.onclick},\r\n              {elementId: strategyMinusId, action: huirthTriggerMinusCountingStrategy(), eventBinding: elementEventBinding.onclick},\r\n              {elementId: addId, action: counterAdd(), eventBinding: elementEventBinding.onclick},\r\n              {elementId: subtractId, action: counterSubtract(), eventBinding: elementEventBinding.onclick}\r\n            ]),\r\n            universal: false,\r\n            boundSelectors,\r\n            action: act(payload),\r\n            html: /*html*/`\r\n          <div id='${id}'>\r\n            <button id=${strategyId} class=\"m-2 center-m bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded\">\r\n              Random\r\n            </button>\r\n            <button id=${strategyPlusId} class=\"m-2 center-m bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded\">\r\n              Count Seven\r\n            </button>\r\n            <button id=${strategyMinusId} class=\"m-2 center-m bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded\">\r\n              Minus Seven\r\n            </button>\r\n            <button id=${addId} class=\"m-2 center-m bg-transparent hover:bg-green-500 text-green-700 font-semibold hover:text-white py-2 px-4 border border-green-500 hover:border-transparent rounded\">\r\n              Add\r\n            </button>\r\n            <button id=${subtractId} class=\"m-2 center-m bg-transparent hover:bg-red-500 text-red-700 font-semibold hover:text-white py-2 px-4 border border-red-500 hover:border-transparent rounded\">\r\n              Subtract\r\n            </button>\r\n            <span class=\"text-amber-300 text-xl\">Count: ${count}</span>\r\n            <br>\r\n            <div id='${id + 'scroll'}' class=\"mt-4 overflow-scroll max-h-[70vh] p-4 [&>*:nth-child(3n+3)]:text-sky-400 [&>*:nth-child(2n+2)]:text-orange-400\">\r\n              ${finalDialog}\r\n            </div>\r\n          </div>\r\n    `\r\n          }));\r\n          return strategy;\r\n        }\r\n      }\r\n      return action;\r\n    }, concepts$ as UnifiedSubject, _semaphore as number, 50)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality for the last slice of the Dialog Component with the necessary closing element tags.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthIndexDialogEnd,\r\n  huirthIndexDialogEndType,\r\n  huirthIndexDialogEndQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for IndexDialogEnd',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(action => {\r\n    const payload = selectComponentPayload(action);\r\n    const id = '';\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n        id,\r\n        boundSelectors: [],\r\n        universal: false,\r\n        action: act(payload),\r\n        html: /*html*/`\r\n    </div>\r\n  </section>\r\n</div>\r\n        `\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality for the first slice of the DPO DataSet Component.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthIndexDPOBegin,\r\n  huirthIndexDPOBeginType,\r\n  huirthIndexDPOBeginQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for IndexDPOBegin',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(action => {\r\n    const payload = selectComponentPayload(action);\r\n    const id = '#beginDPOID' + payload.pageTitle;\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n        id,\r\n        boundSelectors: [],\r\n        universal: false,\r\n        action: act(payload),\r\n        html: /*html*/`\r\n<div id='${id}' class=\"carbon-fiber\">\r\n  <section class=\"flex flex-col items-center min-h-screen text-white bg-center bg-blend-overlay md:bg-fixed bg-neutral-900/60\">\r\n    <div class =\"flex-1 mb-12 max-w-5xl m-10 pt-10 pb-10 bg-gray-800/90 rounded\">\r\n      <h1 class=\"text-3xl text-center p-4\">DPO Training Set</h1>\r\n`\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality for the content slice of the DPO DataSet Component with the necessary bindings.":{"type":"project","content":"/* eslint-disable max-len */\r\nimport {\r\n  Action,\r\n  KeyedSelector,\r\n  UnifiedSubject,\r\n  createMethodDebounceWithConcepts,\r\n  nullReducer,\r\n  selectUnifiedState,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createBinding, createBoundSelectors, createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\nimport { elementEventBinding } from '../../../../../model/html';\r\nimport { huirthState } from '../../../huirth.concept';\r\nimport { chosenID, generateNumID, promptID, rejectedID } from '../../../huirth.model';\r\nimport { huirthUpdateFromPromptPayload } from '../../updateFromPromptPayload.quality';\r\nimport { huirthUpdateFromChosenPayload } from '../../updateFromChosenPayload.quality';\r\nimport { huirthUpdateFromRejectedPayload } from '../../updateFromRejectedPayload.quality';\r\nimport { huirthNewDataSetEntry } from '../../newDataSetEntry.quality';\r\nimport { huirth_createDPOSelector } from '../../../huirth.selector';\r\nimport { huirthTriggerSaveDPOStrategy } from '../../../strategies/server/triggerSaveDPOStrategy.helper';\r\nimport { huirthNewDPOEntry } from '../../newDPOEntry.quality';\r\n\r\nexport const [\r\n  huirthIndexDPOContent,\r\n  huirthIndexDPOContentType,\r\n  huirthIndexDPOContentQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for IndexDPOContent',\r\n  reducer: nullReducer,\r\n  componentCreator: (act, concepts$, _semaphore) =>\r\n    createMethodDebounceWithConcepts((action, concepts, semaphore) => {\r\n      const payload = selectComponentPayload(action);\r\n      const id = '#trainingDataID' + payload.pageTitle;\r\n      const addEntryID = '#addEntry' + payload.pageTitle;\r\n      const saveDPOID = '#saveDPO' + payload.pageTitle;\r\n      if (action.strategy) {\r\n        const activeDPO = (selectUnifiedState<huirthState>(concepts, semaphore) as huirthState).activeDPO;\r\n        let finalOutput = '';\r\n        const bindingsArray: {\r\n        elementId: string;\r\n        eventBinding: elementEventBinding;\r\n        action: Action;\r\n      }[] = [];\r\n        for (let i = 0; i < activeDPO.length; i++) {\r\n          const elementID = generateNumID(i);\r\n          bindingsArray.push({\r\n            elementId: promptID + elementID,\r\n            eventBinding: elementEventBinding.onchange,\r\n            action: huirthUpdateFromPromptPayload()\r\n          });\r\n          bindingsArray.push({\r\n            elementId: chosenID + elementID,\r\n            eventBinding: elementEventBinding.onchange,\r\n            action: huirthUpdateFromChosenPayload()\r\n          });\r\n          bindingsArray.push({\r\n            elementId: rejectedID + elementID,\r\n            eventBinding: elementEventBinding.onchange,\r\n            action: huirthUpdateFromRejectedPayload()\r\n          });\r\n          finalOutput += /*html*/`\r\n<div class=\"text-black\">\r\n  <label class=\"text-white pl-2 translate-y-2\">\r\n    Prompt\r\n  </label>\r\n  <input\r\n    id=\"${promptID + elementID}\"\r\n    class=\"mb-4 peer h-full w-full rounded-[7px] border border-blue-gray-200 border-t-transparent bg-white px-3 py-2.5 font-sans text-sm font-normal text-blue-gray-700 outline outline-0 transition-all placeholder-shown:border placeholder-shown:border-blue-gray-200 placeholder-shown:border-t-blue-gray-200 focus:border-2 focus:border-teal-500 focus:border-t-transparent focus:outline-0 disabled:border-0 disabled:bg-blue-gray-50\"\r\n    value=\"${activeDPO[i].prompt}\"\r\n  />\r\n  <label class=\"text-white pl-2 translate-y-2\">\r\n    Chosen\r\n  </label>\r\n  <textarea id=\"${chosenID + elementID}\" class=\"peer h-full min-h-[100px] w-full resize-none rounded-[7px] border border-blue-gray-200 border-t-transparent bg-white px-3 py-2.5 font-sans text-sm font-normal text-blue-gray-700 outline outline-0 transition-all placeholder-shown:border placeholder-shown:border-blue-gray-200 placeholder-shown:border-t-blue-gray-200 focus:border-2 focus:border-pink-500 focus:border-t-transparent focus:outline-0 disabled:resize-none disabled:border-0 disabled:bg-blue-gray-50\" id=\"${chosenID + elementID}\" rows=\"4\" cols=\"50\">\r\n${activeDPO[i].chosen}\r\n  </textarea>\r\n  </textarea>\r\n  <label class=\"text-white pl-2 translate-y-2\">\r\n    Rejected\r\n  </label>\r\n  <textarea id=\"${rejectedID + elementID}\" class=\"peer h-full min-h-[100px] w-full resize-none rounded-[7px] border border-blue-gray-200 border-t-transparent bg-white px-3 py-2.5 font-sans text-sm font-normal text-blue-gray-700 outline outline-0 transition-all placeholder-shown:border placeholder-shown:border-blue-gray-200 placeholder-shown:border-t-blue-gray-200 focus:border-2 focus:border-pink-500 focus:border-t-transparent focus:outline-0 disabled:resize-none disabled:border-0 disabled:bg-blue-gray-50\" id=\"${chosenID + elementID}\" rows=\"4\" cols=\"50\">\r\n${activeDPO[i].rejected}\r\n  </textarea>\r\n</div>\r\n        `;\r\n        }\r\n        bindingsArray.push({\r\n          action: huirthNewDPOEntry(),\r\n          elementId: addEntryID,\r\n          eventBinding: elementEventBinding.onclick\r\n        });\r\n        bindingsArray.push({\r\n          action: huirthTriggerSaveDPOStrategy(),\r\n          elementId: saveDPOID,\r\n          eventBinding: elementEventBinding.onclick\r\n        });\r\n        const bindings = createBinding(bindingsArray);\r\n        // console.log('Check bindings', bindings);\r\n        const strategy = strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n          id,\r\n          bindings,\r\n          universal: false,\r\n          boundSelectors: [\r\n            // START HERE\r\n            createBoundSelectors(id, huirthIndexDPOContent(payload), [\r\n              huirth_createDPOSelector(concepts, semaphore) as KeyedSelector\r\n            ])\r\n          ],\r\n          action: act(payload),\r\n          html: /*html*/`\r\n        <div class=\"flex flex-col items-center\" id='${id}'>\r\n          <button id=${addEntryID} class=\"m-2 center-m bg-white/5 hover:bg-green-500 text-green-700 font-semibold hover:text-white py-2 px-4 border border-green-500 hover:border-transparent rounded\">\r\n            Add Entry\r\n          </button>\r\n          <button id=${saveDPOID} class=\"m-2 center-m bg-white/5 hover:bg-green-500 text-green-700 font-semibold hover:text-white py-2 px-4 border border-green-500 hover:border-transparent rounded\">\r\n            Save Training Data\r\n          </button>\r\n          <div class=\"mt-4 p-4 [&>*:nth-child(3n+3)]:text-sky-400 [&>*:nth-child(2n+2)]:text-orange-400\">\r\n            ${finalOutput}\r\n          </div>\r\n        </div>\r\n  `\r\n        }));\r\n        return strategy;\r\n      }\r\n      return action;\r\n    }, concepts$ as UnifiedSubject, _semaphore as number, 50)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality for the last slice of the DPO DataSet Component with the proper closing tags.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthIndexDPOEnd,\r\n  huirthIndexDPOEndType,\r\n  huirthIndexDPOEndQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for IndexDPOEnd',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(action => {\r\n    const payload = selectComponentPayload(action);\r\n    const id = '';\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n        id,\r\n        boundSelectors: [],\r\n        universal: false,\r\n        action: act(payload),\r\n        html: /*html*/`\r\n    </div>\r\n  </section>\r\n</div>\r\n        `\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality for the Error Page Component.":{"type":"project","content":"/* eslint-disable max-len */\r\nimport {\r\n  Action,\r\n  axiumConcludeType,\r\n  createAction,\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthError,\r\n  huirthErrorType,\r\n  huirthErrorQuality\r\n] = createQualitySetComponent({\r\n  type: 'Create huirth Error Composition',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) =>\r\n    createMethod((action: Action) => {\r\n      const payload = selectComponentPayload(action);\r\n      if (action.strategy) {\r\n        const id = '#errorID';\r\n        return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n          id,\r\n          boundSelectors: [],\r\n          universal: false,\r\n          action: act(payload),\r\n          html: /*html*/`\r\n<section id='${id}' class=\"flex flex-col min-h-screen bg-black text-white bg-center bg-blend-overlay md:bg-fixed bg-black/5\">\r\n  <div class=\"flex-1 flex items-center\">\r\n    <div class=\"flex flex-col items-center text-center mx-auto\">\r\n      <h1 class=\"text-8xl text-black\">404</h1>\r\n    </div>\r\n  </div>\r\n</section>\r\n`\r\n        }));\r\n      }\r\n      return createAction(axiumConcludeType);\r\n    })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality to create the footer component.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthFooter,\r\n  huirthFooterType,\r\n  huirthFooterQuality\r\n] = createQualitySetComponent({\r\n  type: 'Create huirth Footer',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(\r\n    (action) => {\r\n      const payload = selectComponentPayload(action);\r\n      if (action.strategy) {\r\n        return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n          id: '',\r\n          boundSelectors: [],\r\n          universal: true,\r\n          action: act(payload),\r\n          html: /*html*/`\r\n  <footer\r\n    class=\"bg-neutral-200 text-center dark:bg-neutral-700 lg:text-left\">\r\n    <div class=\"p-4 text-center text-neutral-700 dark:text-neutral-200\">\r\n       2024 Copyright: PHUIRE RESEARCH LLC\r\n    </div>\r\n  </footer>\r\n    `\r\n        }));\r\n      }\r\n      return action;\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality for to create the head content necessary for the huirth brand page strategies.":{"type":"project","content":"/* eslint-disable max-len */\r\nimport {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthHead,\r\n  huirthHeadType,\r\n  huirthHeadQuality\r\n] = createQualitySetComponent({\r\n  type: 'Create huirth Head',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(\r\n    (action) => {\r\n      const payload = selectComponentPayload(action);\r\n      if (action.strategy) {\r\n        return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n          id: '',\r\n          boundSelectors: [],\r\n          universal: true,\r\n          action: act(payload),\r\n          html: /*html*/`\r\n      <link rel=\"stylesheet\" href=\"static/output.css\" />\r\n      <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css\" integrity=\"sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\" />\r\n      `\r\n        }));\r\n      }\r\n      return action;\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality for the Hero Section Component.":{"type":"project","content":"/* eslint-disable max-len */\r\nimport {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthIndexHero,\r\n  huirthIndexHeroType,\r\n  huirthIndexHeroQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for IndexHero',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(action => {\r\n    const payload = selectComponentPayload(action);\r\n    const id = '#heroId';\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage(action.strategy, {\r\n        id,\r\n        boundSelectors: [],\r\n        universal: false,\r\n        action: act(payload),\r\n        html: /*html*/`\r\n<section id='${id}' class=\"flex flex-col min-h-screen bg-black text-white bg-center bg-blend-overlay md:bg-fixed bg-black/5\">\r\n  <div class=\"flex-1 flex items-center\">\r\n    <div class=\"flex flex-col items-center text-center mx-auto\">\r\n      <img class=\"flex-none\" src=\"/static/Huirth.png\" alt=\"huirth\">\r\n    </div>\r\n  </div>\r\n</section>\r\n        `\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality to create the first slice of the Side Bar Component.":{"type":"project","content":"/* eslint-disable max-len */\r\nimport {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthSideBarBegin,\r\n  huirthSideBarBeginType,\r\n  huirthSideBarBeginQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for SideBarBegin',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(action => {\r\n    // console.log('SIDEBAR BEGIN', action.strategy);\r\n    const payload = selectComponentPayload(action);\r\n    const id = '#sideBarBegin';\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n        id,\r\n        boundSelectors: [],\r\n        universal: true,\r\n        action: act(payload),\r\n        html: /*html*/`\r\n<aside id=${id} class=\"fixed left-0 top-0 bottom-0 h-screen w-min overflow-y-scroll bg-white\">\r\n  <nav class=\"h-full flex flex-col bg-gray-200 border-r shadow-sm\">\r\n`\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality to create the content slice of the Side Bar Component with the necessary bindings and selectors.":{"type":"project","content":"/* eslint-disable max-len */\r\nimport {\r\n  KeyedSelector,\r\n  UnifiedSubject,\r\n  createMethodWithConcepts,\r\n  nullReducer,\r\n  selectUnifiedState,\r\n  strategySuccess,\r\n  select,\r\n  createMethodDebounceWithConcepts\r\n} from 'stratimux';\r\n\r\nimport { createBinding, createBoundSelectors, createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\nimport { huirthState } from '../../../huirth.concept';\r\nimport { UserInterfaceState } from '../../../../userInterface/userInterface.concept';\r\nimport { huirth_createSideBarExpandedSelector, huirth_createTrainingDataSelector } from '../../../huirth.selector';\r\nimport { huirthToggleSidebar } from '../../toggleSidebar.quality';\r\nimport { elementEventBinding } from '../../../../../model/html';\r\nimport { userInterface_createPagesSelector } from '../../../../userInterface/userInterface.selector';\r\n\r\nexport const [\r\n  huirthSideBarContent,\r\n  huirthSideBarContentType,\r\n  huirthSideBarContentQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for SideBarContent',\r\n  reducer: nullReducer,\r\n  componentCreator: (act, concepts$, semaphore) => createMethodWithConcepts((action, concepts) => {\r\n    // console.log('SIDEBAR CONTENT', action.strategy);\r\n    const state = selectUnifiedState<UserInterfaceState & huirthState>(concepts, semaphore as number);\r\n    const payload = selectComponentPayload(action);\r\n    const id = '#sideBarContent';\r\n    const expandSideBarId = '#expandSideBarID';\r\n    let liClass = 'w-48 overflow-hidden relative flex items-center py-2 px-3 my-2 font-medium rounded-md bg-gray-100 hover:bg-white';\r\n    let pages = '';\r\n    if (state) {\r\n      if (!state.sideBarExpanded) {\r\n        liClass += ' hidden';\r\n      }\r\n      pages = /*html*/`\r\n<li class=\"${liClass} cursor-pointer\"><a href=\"/\"><i class=\"fa-solid fa-house\"></i> Home</a></li>\r\n<li class=\"${liClass} text-slate-400 italic cursor-not-allowed\"><a><i class=\"fa-solid fa-compass\"></i> Applications</a></li>\r\n<li class=\"${liClass} text-slate-400 italic cursor-not-allowed\"><a><i class=\"fa-solid fa-lightbulb\"></i> Concepts</a></li>\r\n<li class=\"${liClass} text-slate-400 italic cursor-not-allowed\"><a><i class=\"fa-solid fa-fire\"></i> Tutorials</a></li>\r\n<li class=\"${liClass} text-slate-400 italic cursor-not-allowed\"><a><i class=\"fa-solid fa-vial-circle-check\"></i> Model Lab</a></li>\r\n<li class=\"${liClass} text-slate-400 italic cursor-not-allowed\"><a><i class=\"fa-sharp fa-solid fa-diagram-project\"></i> Project Manager</a></li>\r\n<li class=\"${liClass} cursor-pointer\"><a href=\"/dataManager\"><i class=\"fa-solid fa-book\"></i> Data Manager</a></li>\r\n`;\r\n      for (const data of state.trainingData) {\r\n        // let add = false;\r\n        // state.pages.forEach(page => {\r\n        //   if (page.title === data.name) {\r\n        //     add = true;\r\n        //   }\r\n        // });\r\n        // if (add) {\r\n        pages += /*html*/`\r\n<li class='${liClass}'><a href=\"/${data.name}\"><i class=\"fa-solid fa-file\"></i> ${data.name}</a></li>\r\n`;\r\n        // }\r\n      }\r\n    }\r\n    const boundSelectors = [createBoundSelectors(id, act(payload), [\r\n      huirth_createSideBarExpandedSelector(concepts, semaphore as number) as KeyedSelector,\r\n      huirth_createTrainingDataSelector(concepts, semaphore as number) as KeyedSelector,\r\n    ])];\r\n    if (action.strategy && state) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n        id,\r\n        boundSelectors,\r\n        universal: true,\r\n        bindings: createBinding([\r\n          {elementId: expandSideBarId, action: huirthToggleSidebar(), eventBinding: elementEventBinding.onclick},\r\n        ]),\r\n        action: act(payload),\r\n        html: /*html*/`\r\n<div id=\"${id}\" class=\"p-4 pb-2 flex flex-col justify-between items-center\">\r\n  <div class=\"flex mb-8\">\r\n    <img class=\"overflow-hidden transition-all ${state.sideBarExpanded ? 'p-2 w-52 max-w-none' : 'w-0'}\" src=\"/static/PHUIRE-Title.png\" alt=\"PhuirE\">\r\n    <!-- Navbar Logo -->\r\n    <button id=\"${expandSideBarId}\" class=\"h-24 p-1.5 rounded-lg bg-transparent hover:bg-gray-100\">\r\n      <i class=\"fa-solid fa-bars translate-y-1\"></i>\r\n    </button>\r\n  </div>\r\n  <!-- Navbar Menu -->\r\n  <div class=\"flex overflow-y-scroll\">\r\n    <ul class=\"${(state?.sideBarExpanded ? '' : 'w-0 overflow-hidden')} flex-1 px-3 text-xl\">\r\n      ${pages}\r\n      <li class='${liClass} cursor-pointer'><a class=\"\" href=\"https://github.com/Phuire-Research/huirth\"><i class=\"fa-brands fa-github\"></i> Github</a></li>\r\n    </ul>\r\n  </div>\r\n</div>\r\n`\r\n      }));\r\n    }\r\n    return action;\r\n  }, concepts$ as UnifiedSubject, semaphore as number)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality for to create the last slice of the Side Bar Component with the necessary closing tags to complete the first slice.":{"type":"project","content":"/* eslint-disable max-len */\r\nimport {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthSideBarEnd,\r\n  huirthSideBarEndType,\r\n  huirthSideBarEndQuality\r\n] = createQualitySetComponent({\r\n  type: 'create userInterface for SideBarEnd',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(action => {\r\n    const payload = selectComponentPayload(action);\r\n    const id = '#sideBarEnd';\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n        id,\r\n        boundSelectors: [],\r\n        universal: true,\r\n        action: act(payload),\r\n        html: /*html*/`\r\n  </nav>\r\n</aside> \r\n`\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a User Interface Component quality to create the style component necessary for the huirth page strategies.":{"type":"project","content":"import {\r\n  createMethod,\r\n  nullReducer,\r\n  strategySuccess\r\n} from 'stratimux';\r\n\r\nimport { createQualitySetComponent, selectComponentPayload, userInterface_appendCompositionToPage } from '../../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthStyle,\r\n  huirthStyleType,\r\n  huirthStyleQuality\r\n] = createQualitySetComponent({\r\n  type: 'Create huirth Style',\r\n  reducer: nullReducer,\r\n  componentCreator: (act) => createMethod(\r\n    (action) => {\r\n      const payload = selectComponentPayload(action);\r\n      if (action.strategy) {\r\n        return strategySuccess(action.strategy, userInterface_appendCompositionToPage( action.strategy, {\r\n          id: '',\r\n          boundSelectors: [],\r\n          universal: true,\r\n          action: act(payload),\r\n          html: /*html*/`\r\n  <style>\r\n    html, body {\r\n      overflow-x: clip;\r\n    }\r\n    .center {\r\n      margin: 0 auto;\r\n      padding-top: 5%;\r\n      padding-bottom: 5%;\r\n      width: 768px;\r\n    }\r\n    .center-m {\r\n      margin: 0 auto;\r\n    }\r\n    .center-image {\r\n      margin: 0 auto;\r\n      width: 30%;\r\n    }\r\n    .header {\r\n      padding-top: 10px;\r\n      font-size: 24px;\r\n    }\r\n    .title {\r\n      padding-top: 10px;\r\n      font-size: 20px;\r\n    }\r\n    @media only screen and (min-width: 640px) {\r\n        \r\n    } \r\n    @media only screen and (min-width: 768px) {\r\n        \r\n    } \r\n    @media only screen and (min-width: 1024px) {\r\n        \r\n    } \r\n    @media only screen and (min-width: 1280px) {\r\n        \r\n    } \r\n    @media only screen and (min-width: 1536px) {\r\n        \r\n    } \r\n    @media only screen and (min-width: 2000px) {\r\n      \r\n    }\r\n    .carbon-fiber {\r\n      background-image: repeating-linear-gradient(135deg, transparent, transparent 10px, #0f0f0f 10px, #111 20px);\r\n      background-color: #000000;\r\n    }\r\n  </style>\r\n    `\r\n        }));\r\n      }\r\n      return action;\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will create the context index needed to load Stratimux and all unified huirth concepts onto the client.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { PrimedConceptAndProperties } from '../../../model/userInterface';\r\nimport { createContextIndexContent } from '../../../model/contextIndex';\r\n\r\nexport type CreateContextIndexPayload = {\r\n  primedConcepts: PrimedConceptAndProperties[],\r\n  root: string,\r\n  directoryMap: string[]\r\n};\r\n\r\nexport const [\r\n  userInterfaceServerCreateContextIndex,\r\n  userInterfaceServerCreateContextIndexType,\r\n  userInterfaceServerCreateContextIndexQuality\r\n] = createQualitySetWithPayload<CreateContextIndexPayload>({\r\n  type: 'User Interface Server create Context index.ts',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createAsyncMethod(\r\n    (controller, action) => {\r\n      const payload = selectPayload<CreateContextIndexPayload>(action);\r\n      if (action.strategy) {\r\n        const indexTs = path.join(payload.root + '/context/src/index.ts');\r\n        const content = createContextIndexContent(payload.primedConcepts, payload.directoryMap);\r\n        fs.writeFile(indexTs, content).then(() => {\r\n          const newStrategy =\r\n            strategySuccess(action.strategy as ActionStrategy);\r\n          controller.fire(newStrategy);\r\n        });\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will filter out a new training data from state.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\n\r\nexport type HuirthFilterTrainingDataPagePayload = {\r\n  trainingDataName: string\r\n}\r\n\r\nexport const [\r\n  huirthFilterTrainingDataPage,\r\n  huirthFilterTrainingDataPageType,\r\n  huirthFilterTrainingDataPageQuality\r\n] = createQualitySetWithPayload<HuirthFilterTrainingDataPagePayload>({\r\n  type: 'huirth filter training data page',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const {trainingDataName} = selectPayload<HuirthFilterTrainingDataPagePayload>(action);\r\n    return {\r\n      ...state,\r\n      trainingDataPages: state.trainingDataPages.filter(name => name !== trainingDataName)\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will attempt to parse a valid name from a provided url.\r\nIf valid it will then trigger the strategy that will install the target git repository via a supplied url to a directory of the given name.":{"type":"project","content":"import {\r\n  Concepts,\r\n  createMethodWithState,\r\n  createQualitySet,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { ProjectStatus } from '../huirth.model';\r\nimport { huirthInstallGitRepositoryStrategy } from '../strategies/installGitProject.strategy';\r\nimport { Subject } from 'rxjs';\r\n\r\nconst getName = (url: string): string | undefined => {\r\n  const split = url.split('/');\r\n  console.log('CHECK SPLIT', split[split.length - 1].split('.git'));\r\n  const finalSplit = split[split.length - 1].split('.git');\r\n  return finalSplit.length > 1 ? finalSplit[0] : undefined;\r\n};\r\n\r\nexport const [\r\n  huirthFilterTriggerInstallGitRepository,\r\n  huirthFilterTriggerInstallGitRepositoryType,\r\n  huirthFilterTriggerInstallGitRepositoryQuality\r\n] = createQualitySet({\r\n  type: 'Create huirth that filters only valid git urls to trigger install git repository',\r\n  reducer: (state: huirthState) => {\r\n    const {trainingData, projectsStatuses, possibleProject, possibleProjectValid} = state;\r\n    const name = getName(possibleProject);\r\n    let exists = false;\r\n    if (name && possibleProjectValid) {\r\n      for (const data of trainingData) {\r\n        if (data.name === name) {\r\n          exists = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!exists) {\r\n        projectsStatuses.push({\r\n          name,\r\n          status: ProjectStatus.installing\r\n        });\r\n        return {\r\n          ...state,\r\n          projectsStatuses,\r\n          possibleProject: ''\r\n        };\r\n      }\r\n    }\r\n    return {\r\n      ...state,\r\n      possibleProject: 'INVALID'\r\n    };\r\n  },\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createMethodWithState<huirthState>(\r\n      (action, state) => {\r\n        const {possibleProject, possibleProjectValid} = state;\r\n        const name = getName(possibleProject);\r\n        if (name && possibleProjectValid) {\r\n          console.log('SENDING NAME TO SERVER', name);\r\n          const strategy = huirthInstallGitRepositoryStrategy(possibleProject, name);\r\n          return strategyBegin(strategy);\r\n        } else {\r\n          return action;\r\n        }\r\n      }, concepts$ as Subject<Concepts>, semaphore as number\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will add a new default named dataset to the state's trainingData property.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  Concepts,\r\n  KeyedSelector,\r\n  axiumKick,\r\n  createAsyncMethodWithConcepts,\r\n  createMethodWithConcepts,\r\n  createQualitySetWithPayload,\r\n  createStage,\r\n  getAxiumState,\r\n  nullReducer,\r\n  selectPayload,\r\n  selectSlice,\r\n  stageWaitForOpenThenIterate,\r\n  strategyBegin,\r\n  strategySequence,\r\n} from 'stratimux';\r\nimport { huirthGeneratedTrainingDataPageStrategy } from '../strategies/pages/generatedTrainingDataPage.strategy';\r\nimport { Subject } from 'rxjs';\r\nimport { huirthRemoveTrainingDataPageStrategy } from '../strategies/removeTrainingDataPage.strategy';\r\nimport { huirthAddTrainingDataPageStrategy } from '../strategies/addPageTrainingData.strategy';\r\nimport { huirth_createTrainingDataSelector } from '../huirth.selector';\r\nimport { TrainingData } from '../huirth.model';\r\n\r\ntype TriggerRemoveAddTrainingDataPage = {\r\n  newName: string\r\n  oldName: string\r\n};\r\n\r\nexport const [\r\n  huirthTriggerRemoveAddTrainingDataPage,\r\n  huirthTriggerRemoveAddTrainingDataPageType,\r\n  huirthTriggerRemoveAddTrainingDataPageQuality\r\n] = createQualitySetWithPayload<TriggerRemoveAddTrainingDataPage>({\r\n  type: 'Huirth trigger remove old page then add new generated training data page',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$, semaphore) => createMethodWithConcepts((action, cpts) => {\r\n    const selector = huirth_createTrainingDataSelector(cpts, semaphore);\r\n    if (selector) {\r\n      const {newName, oldName} = selectPayload<TriggerRemoveAddTrainingDataPage>(action);\r\n      const generatedTrainingDataPage = huirthGeneratedTrainingDataPageStrategy(newName);\r\n      const strategyAdd = huirthAddTrainingDataPageStrategy(\r\n        newName,\r\n        generatedTrainingDataPage,\r\n        cpts,\r\n      );\r\n      strategyAdd.priority = 3000;\r\n      const strategyRemove = huirthRemoveTrainingDataPageStrategy(\r\n        oldName,\r\n      );\r\n      strategyRemove.priority = 3000;\r\n      return strategyBegin(strategySequence([strategyRemove, strategyAdd]) as ActionStrategy);\r\n    } else {\r\n      return action;\r\n    }\r\n  }, concepts$ as Subject<Concepts>, semaphore as number)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality to add a new base data set entry to the training data at the target index.":{"type":"project","content":"import {\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { generateBaseDataSetEntry } from '../huirth.model';\r\n\r\nexport type huirthNewDataSetEntryPayload = {\r\n  index: number\r\n};\r\nexport const [\r\n  huirthNewDataSetEntry,\r\n  huirthNewDataSetEntryType,\r\n  huirthNewDataSetEntryQuality\r\n] = createQualitySetWithPayload<huirthNewDataSetEntryPayload>({\r\n  type: 'Huirth create a new default DataSet entry at target index',\r\n  reducer: (state: huirthState, action): huirthState => {\r\n    const payload = selectPayload<huirthNewDataSetEntryPayload>(action);\r\n    const trainingData = [...state.trainingData];\r\n    trainingData[payload.index].dataSet.push(generateBaseDataSetEntry());\r\n    return {\r\n      ...state,\r\n      trainingData,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will add new default DPO Training Data Entry to huirth's state.":{"type":"project","content":"import {\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { generateDPOTrainingData } from '../huirth.model';\r\n\r\nexport const [\r\n  huirthNewDPOEntry,\r\n  huirthNewDPOEntryType,\r\n  huirthNewDPOEntryQuality\r\n] = createQualitySet({\r\n  type: 'Create huirth NewDPOEntry',\r\n  reducer: (state: huirthState): huirthState => {\r\n    const activeDPO = [...state.activeDPO];\r\n    activeDPO.push(generateDPOTrainingData());\r\n    return {\r\n      ...state,\r\n      activeDPO,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that remove a dataset and if it is a project, update the status to installed.":{"type":"project","content":"import {\r\n  UnifiedSubject,\r\n  createActionNode,\r\n  createMethodWithState,\r\n  createQualitySet,\r\n  createStrategy,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { DataSetTypes, NamedDataSet, PhuirEProjects, ProjectStatus, TrainingData } from '../huirth.model';\r\nimport { huirthSendTriggerDeleteDataSetsStrategy } from './sendTriggerDeleteDataSetsStrategy.quality';\r\nimport { userInterface_isClient } from '../../../model/userInterface';\r\n\r\nconst isNot = (dataSet: NamedDataSet, not: string[]) => {\r\n  for (const n of not) {\r\n    if (dataSet.name === n) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nexport const [\r\n  huirthRemoveDataSetSelection,\r\n  huirthRemoveDataSetSelectionType,\r\n  huirthRemoveDataSetSelectionQuality\r\n] = createQualitySet({\r\n  type: 'huirth remove data set selection',\r\n  reducer: (state: huirthState): huirthState => {\r\n    const {trainingData, dataSetSelection } = state;\r\n    let {projectsStatuses, stratimuxStatus, huirthStatus} = state;\r\n    const newDataSetSelection = [];\r\n    const newTrainingData: TrainingData = [];\r\n    const not = trainingData.filter((_, i) => dataSetSelection[i]).map(d => d.name);\r\n    const newStatuses = [];\r\n\r\n    for (const data of trainingData) {\r\n      if (isNot(data, not)) {\r\n        newTrainingData.push(data);\r\n        newDataSetSelection.push(false);\r\n        for (const project of projectsStatuses) {\r\n          if (project.name === data.name) {\r\n            newStatuses.push(project);\r\n          }\r\n          break;\r\n        }\r\n      } else\r\n      if (data.type === DataSetTypes.project) {\r\n        if (data.name.toLowerCase() === PhuirEProjects.stratimux) {\r\n          stratimuxStatus = ProjectStatus.installed;\r\n        } else if (data.name.toLowerCase() === PhuirEProjects.huirth) {\r\n          huirthStatus = ProjectStatus.installed;\r\n        } else {\r\n          for (const project of projectsStatuses) {\r\n            if (project.name === data.name) {\r\n              project.status = ProjectStatus.installed;\r\n              newStatuses.push(project);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    projectsStatuses = newStatuses;\r\n    console.log('NEW DATA SET SELECTION', newDataSetSelection);\r\n    return {\r\n      ...state,\r\n      trainingData: newTrainingData,\r\n      stratimuxStatus,\r\n      huirthStatus,\r\n      projectsStatuses,\r\n      dataSetSelection: newDataSetSelection\r\n    };\r\n  },\r\n  methodCreator: (concepts$, semaphore) => createMethodWithState<huirthState>((action, state) => {\r\n    const {trainingData, dataSetSelection} = state;\r\n    const names = trainingData.filter((__, i) => dataSetSelection[i]).map(d => d.name);\r\n    return strategyBegin(createStrategy({\r\n      topic: 'Send Trigger Delete Data Sets: ' + names.join(', '),\r\n      initialNode: createActionNode(huirthSendTriggerDeleteDataSetsStrategy({names}), {successNode: null, failureNode: null})\r\n    }));\r\n  }, concepts$ as UnifiedSubject, semaphore as number)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will trigger the minus count seven strategy.":{"type":"project","content":"import {\r\n  Concepts,\r\n  CounterState,\r\n  UnifiedSubject,\r\n  createMethodDebounceWithState,\r\n  createQualitySet,\r\n  nullReducer,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthMinusSevenStrategy } from '../strategies/countMinusSeven.strategy';\r\nimport { Subject } from 'rxjs';\r\n\r\nexport const [\r\n  huirthTriggerMinusCountingStrategy,\r\n  huirthTriggerMinusCountingStrategyType,\r\n  huirthTriggerMinusCountingStrategyQuality\r\n] = createQualitySet({\r\n  type: 'Create huirth trigger minus seven counting strategy',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createMethodDebounceWithState<CounterState>(\r\n      (_, state) => {\r\n        const strategy = huirthMinusSevenStrategy(state.count, semaphore as number);\r\n        return strategyBegin(strategy);\r\n      }, concepts$ as UnifiedSubject, semaphore as number, 3\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will Send the trigger action to the server that starts deletion strategy for data set that have been removed.":{"type":"project","content":"import {\r\n  createAction,\r\n  createActionNode,\r\n  createMethodDebounce,\r\n  createQualitySetWithPayload,\r\n  createStrategy,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { userInterfaceClientSendActionToServer } from '../../userInterfaceClient/strategies/sendActionToServer.helper';\r\nimport { huirthClearDataSetSelection } from './clearDataSetSelection.quality';\r\n\r\nexport type huirthSendTriggerDeleteDataSetsStrategyPayload = {\r\n  names: string[],\r\n}\r\n\r\nexport const [\r\n  huirthSendTriggerDeleteDataSetsStrategy,\r\n  huirthSendTriggerDeleteDataSetsStrategyType,\r\n  huirthSendTriggerDeleteDataSetsStrategyQuality\r\n] = createQualitySetWithPayload<huirthSendTriggerDeleteDataSetsStrategyPayload>({\r\n  type: 'huirth send trigger delete data sets strategy',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createMethodDebounce(\r\n      (action) => {\r\n        const payload = selectPayload<huirthSendTriggerDeleteDataSetsStrategyPayload>(action);\r\n        return strategyBegin(createStrategy({\r\n          topic: 'Sent to Web Socket: Trigger Delete Data Sets: ' + payload.names.join(', '),\r\n          initialNode: createActionNode(\r\n            userInterfaceClientSendActionToServer(\r\n              createAction('huirthServer trigger delete data sets strategy', {payload})), {\r\n              successNode: createActionNode(huirthClearDataSetSelection())\r\n            })\r\n        }));\r\n      }, 50\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will Send the trigger action to the server that starts the parse repositories strategy on the server.\r\nAs well as inform the user that the data is currently being parsed.":{"type":"project","content":"import {\r\n  Action,\r\n  createAction,\r\n  createActionNode,\r\n  createMethodDebounce,\r\n  createQualitySetWithPayload,\r\n  createStrategy,\r\n  selectPayload,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { PhuirEProjects, ProjectStatus } from '../huirth.model';\r\nimport { userInterfaceClientSendActionToServer } from '../../userInterfaceClient/strategies/sendActionToServer.helper';\r\n\r\nexport type huirthSendTriggerParseRepositoryStrategyPayload = {\r\n  name: string,\r\n}\r\n\r\nexport const [\r\n  huirthSendTriggerParseRepositoryStrategy,\r\n  huirthSendTriggerParseRepositoryStrategyType,\r\n  huirthSendTriggerParseRepositoryStrategyQuality\r\n] = createQualitySetWithPayload<huirthSendTriggerParseRepositoryStrategyPayload>({\r\n  type: 'huirth send trigger parse repository to the server',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const { name } = selectPayload<huirthSendTriggerParseRepositoryStrategyPayload>(action);\r\n    let { stratimuxStatus, huirthStatus, projectsStatuses } = state;\r\n    if (name.toLowerCase() === PhuirEProjects.stratimux) {\r\n      stratimuxStatus = ProjectStatus.parsing;\r\n    } else if (name.toLowerCase() === PhuirEProjects.huirth) {\r\n      huirthStatus = ProjectStatus.parsing;\r\n    } else {\r\n      const newStatuses = [];\r\n      let added = false;\r\n      for (const status of projectsStatuses) {\r\n        if (status.name === name) {\r\n          status.status = ProjectStatus.parsing;\r\n          newStatuses.push(status);\r\n          added = true;\r\n        } else {\r\n          newStatuses.push(status);\r\n        }\r\n      }\r\n      if (!added) {\r\n        newStatuses.push({\r\n          name: name,\r\n          status: ProjectStatus.parsing\r\n        });\r\n      }\r\n      projectsStatuses = newStatuses;\r\n    }\r\n    return {\r\n      ...state,\r\n      stratimuxStatus,\r\n      huirthStatus,\r\n      projectsStatuses\r\n    };\r\n  },\r\n  methodCreator: () =>\r\n    createMethodDebounce(\r\n      (action) => {\r\n        const { name } = selectPayload<huirthSendTriggerParseRepositoryStrategyPayload>(action);\r\n        return strategyBegin(\r\n          createStrategy({\r\n            topic: `Sending to server trigger parse repository strategy for ${name}`,\r\n            initialNode: createActionNode(\r\n              userInterfaceClientSendActionToServer(\r\n                createAction('huirthServer trigger parse repository strategy', {payload: {\r\n                  name\r\n                }})))\r\n          }));\r\n      }, 50\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will Send the trigger action to the server that starts the save data set selection strategy.\r\nAs well as inform the user what data sets are currently being saved.":{"type":"project","content":"import {\r\n  Action,\r\n  UnifiedSubject,\r\n  createAction,\r\n  createActionNode,\r\n  createMethodDebounceWithState,\r\n  createQualitySet,\r\n  createStrategy,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { ProjectStatus } from '../huirth.model';\r\nimport { userInterfaceClientSendActionToServer } from '../../userInterfaceClient/strategies/sendActionToServer.helper';\r\nimport { huirthServerState } from '../../huirthServer/huirthServer.concept';\r\nimport { huirthClearDataSetSelection } from './clearDataSetSelection.quality';\r\n\r\nexport const [\r\n  huirthSendTriggerSaveDataSetSelectionStrategy,\r\n  huirthSendTriggerSaveDataSetSelectionStrategyType,\r\n  huirthSendTriggerSaveDataSetSelectionStrategyQuality\r\n] = createQualitySet({\r\n  type: 'huirth send trigger save data set selection strategy to server',\r\n  reducer: (state: huirthState, _: Action): huirthState => {\r\n    const {trainingData} = state;\r\n    let { stratimuxStatus, huirthStatus, projectsStatuses } = state;\r\n    const { dataSetSelection } = state;\r\n    const names: string[] = [];\r\n    for (const [i, select] of dataSetSelection.entries()) {\r\n      if (select) {\r\n        const name = trainingData[i].name;\r\n        names.push(name);\r\n        if (name.toLowerCase() === 'stratimux') {\r\n          stratimuxStatus = ProjectStatus.saving;\r\n        } else if (name.toLowerCase() === 'huirth') {\r\n          huirthStatus = ProjectStatus.saving;\r\n        } else {\r\n          const newStatuses = [];\r\n          let added = false;\r\n          for (const status of projectsStatuses) {\r\n            if (status.name === name) {\r\n              status.status = ProjectStatus.saving;\r\n              newStatuses.push(status);\r\n              added = true;\r\n            } else {\r\n              newStatuses.push(status);\r\n            }\r\n          }\r\n          if (!added) {\r\n            newStatuses.push({\r\n              name: name,\r\n              status: ProjectStatus.saving\r\n            });\r\n          }\r\n          projectsStatuses = newStatuses;\r\n        }\r\n      }\r\n    }\r\n    return {\r\n      ...state,\r\n      stratimuxStatus,\r\n      huirthStatus,\r\n      projectsStatuses,\r\n    };\r\n  },\r\n  methodCreator: (concepts$, semaphore) =>\r\n    createMethodDebounceWithState<huirthServerState>(\r\n      (_, state) => {\r\n        const {dataSetSelection, trainingData} = state;\r\n        const names: string[] = [];\r\n        for (const [i, select] of dataSetSelection.entries()) {\r\n          if (select) {\r\n            const name = trainingData[i].name;\r\n            names.push(name);\r\n          }\r\n        }\r\n        const strategy = createStrategy({\r\n          topic: `Sending to server trigger save data set selection for: ${names.join(', ')}`,\r\n          initialNode: createActionNode(userInterfaceClientSendActionToServer(createAction('huirthServer trigger save data set selection strategy', {payload: {\r\n            names\r\n          }})), {\r\n            successNode: createActionNode(huirthClearDataSetSelection()),\r\n          })\r\n        });\r\n        return strategyBegin(strategy);\r\n      }, concepts$ as UnifiedSubject, semaphore as number, 50\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will Send the trigger action to the server that starts transformation strategy based on the passed selection value.":{"type":"project","content":"import {\r\n  UnifiedSubject,\r\n  createAction,\r\n  createActionNode,\r\n  createMethodWithState,\r\n  createQualitySet,\r\n  createStrategy,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { userInterfaceClientSendActionToServer } from '../../userInterfaceClient/strategies/sendActionToServer.helper';\r\n\r\nexport const [\r\n  huirthSendTriggerSelectedTransformationStrategy,\r\n  huirthSendTriggerSelectedTransformationStrategyType,\r\n  huirthSendTriggerSelectedTransformationStrategyQuality\r\n] = createQualitySet({\r\n  type: 'huirth send trigger selected transformation strategy to server',\r\n  reducer: (state: huirthState): huirthState => {\r\n    const dataSetSelection = state.dataSetSelection.map(() => false);\r\n    return {\r\n      ...state,\r\n      dataSetSelection\r\n    };\r\n  },\r\n  methodCreator: (concepts$, semaphore) =>\r\n    createMethodWithState<huirthState>(\r\n      (_, state) => {\r\n        const serverActionType = 'huirthServer trigger passed transformation strategy from payload';\r\n        const {selectedTransformation} = state;\r\n        const topic = 'Sent to Web Socket: Trigger : ' + serverActionType + ' ' + selectedTransformation;\r\n        return strategyBegin(createStrategy({\r\n          topic,\r\n          initialNode: createActionNode(\r\n            userInterfaceClientSendActionToServer(\r\n              createAction(serverActionType, {payload: {\r\n                selection: selectedTransformation\r\n              }})))\r\n        }));\r\n      }, concepts$ as UnifiedSubject, semaphore as number\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that set incoming data set into the currently loaded training data.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { NamedDataSet, TrainingData } from '../huirth.model';\r\n\r\nexport type huirthSetDataSetPayload = {\r\n  named: NamedDataSet\r\n}\r\n\r\nexport const [\r\n  huirthSetDataSet,\r\n  huirthSetDataSetType,\r\n  huirthSetDataSetQuality\r\n] = createQualitySetWithPayload<huirthSetDataSetPayload>({\r\n  type: 'huirth set data set to the current training data',\r\n  reducer: (state: huirthState, action: Action) => {\r\n    const {trainingData} = state;\r\n    const newTrainingData: TrainingData = [];\r\n    const {named} = selectPayload<huirthSetDataSetPayload>(action);\r\n    // eslint-disable-next-line no-useless-escape\r\n    let exists = false;\r\n    for (const data of trainingData) {\r\n      if (data.name === named.name) {\r\n        newTrainingData.push(named);\r\n        exists = true;\r\n        break;\r\n      } else {\r\n        newTrainingData.push(data);\r\n      }\r\n    }\r\n    if (!exists) {\r\n      trainingData.push(named);\r\n    }\r\n    return {\r\n      ...state,\r\n      trainingData: newTrainingData,\r\n    };\r\n  },\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that set the possibleProject based on an input value and determine if it is valid url that includes .git.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { userInterface_selectInputTarget } from '../../../model/userInterface';\r\n\r\nconst getName = (url: string): string | undefined => {\r\n  const split = url.split('/');\r\n  console.log('CHECK SPLIT', split[split.length - 1].split('.git'));\r\n  const finalSplit = split[split.length - 1].split('.git');\r\n  return finalSplit.length > 1 ? finalSplit[0] : undefined;\r\n};\r\n\r\nexport const [\r\n  huirthSetPossibleProject,\r\n  huirthSetPossibleProjectType,\r\n  huirthSetPossibleProjectQuality\r\n] = createQualitySet({\r\n  type: 'huirth set the possible project and check if it is valid',\r\n  reducer: (state: huirthState, action: Action) => {\r\n    const {trainingData} = state;\r\n    const target = userInterface_selectInputTarget(action);\r\n    const value = target.value;\r\n    // eslint-disable-next-line no-useless-escape\r\n    const urlRegex = RegExp(/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/);\r\n    const isValid = urlRegex.test(value);\r\n    const name = getName(value);\r\n    console.log('CHECK NAME', name, isValid);\r\n    let exists = false;\r\n    if (name && isValid) {\r\n      for (const data of trainingData) {\r\n        if (data.name === name) {\r\n          exists = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!exists) {\r\n        return {\r\n          ...state,\r\n          possibleProject: value,\r\n          possibleProjectValid: true\r\n        };\r\n      }\r\n    }\r\n    return {\r\n      ...state,\r\n      possibleProject: value,\r\n      possibleProjectValid: false\r\n    };\r\n  },\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that set the current selected transformation to the incoming target value.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { userInterface_selectInputTarget } from '../../../model/userInterface';\r\n\r\nexport const [\r\n  huirthSetSelectedTransformation,\r\n  huirthSetSelectedTransformationType,\r\n  huirthSetSelectedTransformationQuality\r\n] = createQualitySet({\r\n  type: 'huirth set the currently selected transformation',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const target = userInterface_selectInputTarget(action);\r\n    const value = target.value;\r\n    // eslint-disable-next-line no-useless-escape\r\n    return {\r\n      ...state,\r\n      selectedTransformation: value\r\n    };\r\n  }\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will inform that the training data has loaded.":{"type":"project","content":"import {\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\n\r\nexport const [\r\n  huirthSetTrainingDataInitialized,\r\n  huirthSetTrainingDataInitializedType,\r\n  huirthSetTrainingDataInitializedQuality\r\n] = createQualitySet({\r\n  type: 'huirth set that training data is initialized',\r\n  reducer: (state: huirthState): huirthState => {\r\n    return {\r\n      ...state,\r\n      trainingDataInitialized: true,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will set a new training data page to state.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\n\r\nexport type HuirthSetTrainingDataPagePayload = {\r\n  trainingDataName: string\r\n}\r\n\r\nexport const [\r\n  huirthSetTrainingDataPage,\r\n  huirthSetTrainingDataPageType,\r\n  huirthSetTrainingDataPageQuality\r\n] = createQualitySetWithPayload<HuirthSetTrainingDataPagePayload>({\r\n  type: 'huirth set a new training data page',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const {trainingDataName} = selectPayload<HuirthSetTrainingDataPagePayload>(action);\r\n    return {\r\n      ...state,\r\n      trainingDataPages: [\r\n        ...state.trainingDataPages,\r\n        trainingDataName\r\n      ]\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will toggle the sideBarExpanded property on the supplied state.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\n\r\nexport const [\r\n  huirthToggleSidebar,\r\n  huirthToggleSidebarType,\r\n  huirthToggleSidebarQuality\r\n] = createQualitySet({\r\n  type: 'Create huirth ToggleSidebar',\r\n  reducer: (state: huirthState): huirthState => {\r\n    return {\r\n      ...state,\r\n      sideBarExpanded: !state.sideBarExpanded,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will trigger the strategy that will install the target git repository via a supplied url to a directory of the given name.":{"type":"project","content":"import {\r\n  createMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthInstallGitRepositoryStrategy } from '../strategies/installGitProject.strategy';\r\n\r\nexport type huirthTriggerInstallGitRepositoryPayload = {\r\n  url: string,\r\n  name: string\r\n}\r\n\r\nexport const [\r\n  huirthTriggerInstallGitRepository,\r\n  huirthTriggerInstallGitRepositoryType,\r\n  huirthTriggerInstallGitRepositoryQuality\r\n] = createQualitySetWithPayload<huirthTriggerInstallGitRepositoryPayload>({\r\n  type: 'Create huirth trigger install git repository',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createMethod(\r\n      (action) => {\r\n        const { url, name } = selectPayload<huirthTriggerInstallGitRepositoryPayload>(action);\r\n        const strategy = huirthInstallGitRepositoryStrategy(url, name);\r\n        return strategyBegin(strategy);\r\n      }\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will trigger the count plus seven strategy.":{"type":"project","content":"import {\r\n  Concepts,\r\n  CounterState,\r\n  UnifiedSubject,\r\n  createMethodDebounceWithState,\r\n  createQualitySet,\r\n  nullReducer,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthPlusSevenStrategy } from '../strategies/countPlusSeven.strategy';\r\nimport { Subject } from 'rxjs';\r\n\r\nexport const [\r\n  huirthTriggerPlusCountingStrategy,\r\n  huirthTriggerPlusCountingStrategyType,\r\n  huirthTriggerPlusCountingStrategyQuality\r\n] = createQualitySet({\r\n  type: 'Create huirth trigger plus seven counting strategy',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createMethodDebounceWithState<CounterState>(\r\n      (_, state) => {\r\n        const strategy = huirthPlusSevenStrategy(state.count, semaphore as number);\r\n        return strategyBegin(strategy);\r\n      }, concepts$ as UnifiedSubject, semaphore as number, 3\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will trigger a randomly generated counting strategy.":{"type":"project","content":"import {\r\n  Concepts,\r\n  CounterState,\r\n  UnifiedSubject,\r\n  createMethodDebounceWithState,\r\n  createQualitySet,\r\n  nullReducer,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthGenerateCountingStrategy } from '../strategies/generateCountingStrategy.strategy';\r\nimport { Subject } from 'rxjs';\r\n\r\nexport const [\r\n  huirthTriggerRandomCountingStrategy,\r\n  huirthTriggerRandomCountingStrategyType,\r\n  huirthTriggerRandomCountingStrategyQuality\r\n] = createQualitySet({\r\n  type: 'Create huirth trigger random counting strategy',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createMethodDebounceWithState<CounterState>(\r\n      (_, state) => {\r\n        const strategy = huirthGenerateCountingStrategy(state.count, semaphore as number);\r\n        return strategyBegin(strategy);\r\n      }, concepts$ as UnifiedSubject, semaphore as number, 3\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will set the DataSet at the specified index, the value of the html target supplied in the strategy data field.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { userInterface_selectInputTarget } from '../../../model/userInterface';\r\n\r\nexport type huirthUpdateDataSetContentsPayload = {\r\n  index: number,\r\n  dataSetIndex: number\r\n}\r\n\r\nexport const [\r\n  huirthUpdateDataSetContents,\r\n  huirthUpdateDataSetContentsType,\r\n  huirthUpdateDataSetContentsQuality\r\n] = createQualitySetWithPayload<huirthUpdateDataSetContentsPayload>({\r\n  type: 'Create huirth UpdateDataSetContents',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const payload = selectPayload<huirthUpdateDataSetContentsPayload>(action);\r\n    const target = userInterface_selectInputTarget(action);\r\n    const trainingData = [...state.trainingData];\r\n    const named = trainingData[payload.index];\r\n    if (named && target) {\r\n      named.dataSet[payload.dataSetIndex].content = target.value.trim();\r\n    }\r\n    return {\r\n      ...state,\r\n      trainingData,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that updates a DataSet's associated Page name by index and set by event target value.":{"type":"project","content":"import {\r\n  Action,\r\n  Concepts,\r\n  axiumKick,\r\n  axiumRegisterTimeOut,\r\n  createActionNode,\r\n  createMethodWithState,\r\n  createQualitySetWithPayload,\r\n  createStrategy,\r\n  selectPayload,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { userInterface_selectInputTarget } from '../../../model/userInterface';\r\nimport { DataSetTypes, PhuirEProjects, ProjectStatus } from '../huirth.model';\r\nimport { Subject } from 'rxjs';\r\nimport { huirthSendRemoveAddTrainingPageStrategy } from './sendTriggerRemoveAddTrainingPageStrategy.quality';\r\nimport { webSocketClientForceSync } from '../../webSocketClient/qualities/forceSync.quality';\r\n\r\nexport type huirthUpdateDataSetNamePayload = {\r\n  index: number,\r\n}\r\n\r\nexport const [\r\n  huirthUpdateDataSetName,\r\n  huirthUpdateDataSetNameType,\r\n  huirthUpdateDataSetNameQuality\r\n] = createQualitySetWithPayload<huirthUpdateDataSetNamePayload>({\r\n  type: 'Create huirth UpdateDataSetName',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const payload = selectPayload<huirthUpdateDataSetNamePayload>(action);\r\n    const target = userInterface_selectInputTarget(action);\r\n    const trainingData = [...state.trainingData];\r\n    let {stratimuxStatus, huirthStatus} = state;\r\n    const {projectsStatuses} = state;\r\n    const dataSet = trainingData[payload.index];\r\n    if (dataSet && target) {\r\n      if (dataSet.type === DataSetTypes.project) {\r\n        const name = dataSet.name.toLowerCase();\r\n        if (name === PhuirEProjects.stratimux) {\r\n          stratimuxStatus = ProjectStatus.installed;\r\n        } else if (name === PhuirEProjects.huirth) {\r\n          huirthStatus = ProjectStatus.installed;\r\n        } else {\r\n          for (const project of projectsStatuses) {\r\n            if (project.name.toLowerCase() === name) {\r\n              project.status = ProjectStatus.installed;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      dataSet.name = target.value;\r\n    }\r\n    return {\r\n      ...state,\r\n      trainingData,\r\n      stratimuxStatus,\r\n      huirthStatus,\r\n      projectsStatuses\r\n    };\r\n  },\r\n  methodCreator: (concepts$, semaphore) => createMethodWithState<huirthState>((action, state) => {\r\n    const payload = selectPayload<huirthUpdateDataSetNamePayload>(action);\r\n    const oldName = state.trainingData[payload.index].name;\r\n    const newName = userInterface_selectInputTarget(action).value;\r\n    const removeAdd = createStrategy({\r\n      topic: 'Finally send trigger remove add training data page strategy',\r\n      initialNode: createActionNode(huirthSendRemoveAddTrainingPageStrategy({ oldName, newName }))\r\n    });\r\n    const timeOut = createActionNode(axiumRegisterTimeOut({\r\n      act: strategyBegin(removeAdd),\r\n      timeOut: 50\r\n    }));\r\n    const forceSync = createActionNode(\r\n      webSocketClientForceSync({\r\n        keys: ['trainingData'],\r\n      }),\r\n      {\r\n        successNode: timeOut,\r\n      }\r\n    );\r\n    // return strategyBegin(sendRemoveAddTrainingDataPage);\r\n    return strategyBegin(createStrategy({\r\n      topic: 'Force Sync Training Data then time out send trigger remove add training data page',\r\n      initialNode: forceSync,\r\n      priority: 4000\r\n    }));\r\n  }, concepts$ as Subject<Concepts>, semaphore as number)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that updates a DataSet's prompt by index and set by event target value.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { userInterface_selectInputTarget } from '../../../model/userInterface';\r\n\r\nexport type huirthUpdateDataSetPromptPayload = {\r\n  index: number,\r\n  dataSetIndex: number\r\n}\r\n\r\nexport const [\r\n  huirthUpdateDataSetPrompt,\r\n  huirthUpdateDataSetPromptType,\r\n  huirthUpdateDataSetPromptQuality\r\n] = createQualitySetWithPayload<huirthUpdateDataSetPromptPayload>({\r\n  type: 'Create huirth UpdateDataSetPrompt',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const payload = selectPayload<huirthUpdateDataSetPromptPayload>(action);\r\n    const target = userInterface_selectInputTarget(action);\r\n    const trainingData = [...state.trainingData];\r\n    const named = trainingData[payload.index];\r\n    if (named && target) {\r\n      named.dataSet[payload.dataSetIndex].prompt = target.value;\r\n    }\r\n    return {\r\n      ...state,\r\n      trainingData,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that updates a DataSet's selection within state by index by toggling the boolean value.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\n\r\nexport type huirthUpdateDataSetSelectionPayload = {\r\n  index: number,\r\n}\r\n\r\nexport const [\r\n  huirthUpdateDataSetSelection,\r\n  huirthUpdateDataSetSelectionType,\r\n  huirthUpdateDataSetSelectionQuality\r\n] = createQualitySetWithPayload<huirthUpdateDataSetSelectionPayload>({\r\n  type: 'Create huirth update data set selection',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const {index} = selectPayload<huirthUpdateDataSetSelectionPayload>(action);\r\n    const dataSetSelection = [...state.dataSetSelection];\r\n    console.log('CHECK DATA SET SELECTION BEFORE', dataSetSelection, index);\r\n    if (dataSetSelection[index] !== undefined) {\r\n      dataSetSelection[index] = !dataSetSelection[index];\r\n    }\r\n    console.log('CHECK DATA SET SELECTION AFTER', dataSetSelection);\r\n    return {\r\n      ...state,\r\n      dataSetSelection,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that updates a DPO DataSet's chosen property by index and set by event target value.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { userInterface_selectInputTarget } from '../../../model/userInterface';\r\nimport { chosenID, selectTrainingDataIndex } from '../huirth.model';\r\n\r\nexport const [\r\n  huirthUpdateFromChosenPayload,\r\n  huirthUpdateFromChosenPayloadType,\r\n  huirthUpdateFromChosenPayloadQuality\r\n] = createQualitySet({\r\n  type: 'Create huirth update DPO Dataset from chosen payload target',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const target = userInterface_selectInputTarget(action);\r\n    if (target) {\r\n      const index = selectTrainingDataIndex(target, chosenID);\r\n      const activeDPO = state.activeDPO;\r\n      activeDPO[index].chosen = target.value;\r\n      return {\r\n        ...state,\r\n        activeDPO,\r\n      };\r\n    }\r\n    return {\r\n      ...state\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that updates a DPO DataSet's prompt property by index and set by event target value.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { userInterface_selectInputTarget } from '../../../model/userInterface';\r\nimport { promptID, selectTrainingDataIndex } from '../huirth.model';\r\n\r\nexport const [\r\n  huirthUpdateFromPromptPayload,\r\n  huirthUpdateFromPromptPayloadType,\r\n  huirthUpdateFromPromptPayloadQuality\r\n] = createQualitySet({\r\n  type: 'Create huirth update DPO Dataset from prompt payload target',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const target = userInterface_selectInputTarget(action);\r\n    const index = selectTrainingDataIndex(target, promptID);\r\n    const activeDPO = state.activeDPO;\r\n    activeDPO[index].prompt = target.value;\r\n    return {\r\n      ...state,\r\n      activeDPO,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that updates a DPO DataSet's rejected property by index and set by event target value.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { userInterface_selectInputTarget } from '../../../model/userInterface';\r\nimport { rejectedID, selectTrainingDataIndex } from '../huirth.model';\r\n\r\nexport const [\r\n  huirthUpdateFromRejectedPayload,\r\n  huirthUpdateFromRejectedPayloadType,\r\n  huirthUpdateFromRejectedPayloadQuality\r\n] = createQualitySet({\r\n  type: 'Create huirth update DPO Dataset from rejected payload target',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const target = userInterface_selectInputTarget(action);\r\n    console.log('CHECK TARGET', target);\r\n    const index = selectTrainingDataIndex(target, rejectedID);\r\n    const activeDPO = state.activeDPO;\r\n    activeDPO[index].rejected = target.value;\r\n    return {\r\n      ...state,\r\n      activeDPO,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will append the payload data set into state, replacing if it already exists.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { DataSetTypes, NamedDataSet, PhuirEProjects, ProjectStatus, TrainingData } from '../huirth.model';\r\n\r\nexport type huirthUpdateParsedProjectDataSetPayload = {\r\n  dataSet: NamedDataSet,\r\n}\r\n\r\nexport const [\r\n  huirthUpdateParsedProjectDataSet,\r\n  huirthUpdateParsedProjectDataSetType,\r\n  huirthUpdateParsedProjectDataSetQuality\r\n] = createQualitySetWithPayload<huirthUpdateParsedProjectDataSetPayload>({\r\n  type: 'huirth update parsed project data set',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const {dataSet} = selectPayload<huirthUpdateParsedProjectDataSetPayload>(action);\r\n    const { dataSetSelection, trainingData } = state;\r\n    let {projectsStatuses, stratimuxStatus, huirthStatus} = state;\r\n    const newTrainingData: TrainingData = [];\r\n    let added = false;\r\n    for (const data of trainingData) {\r\n      if (data.name === dataSet.name) {\r\n        newTrainingData.push(dataSet);\r\n        added = true;\r\n      } else if (data.name !== dataSet.name) {\r\n        newTrainingData.push(data);\r\n      }\r\n    }\r\n    console.log('CHECK INCOMING NAME', dataSet.name);\r\n    if (!added) {\r\n      newTrainingData.push(dataSet);\r\n      dataSetSelection.push(false);\r\n    }\r\n    if (dataSet.type === DataSetTypes.project) {\r\n      if (dataSet.name.toLowerCase() === PhuirEProjects.stratimux) {\r\n        stratimuxStatus = ProjectStatus.parsed;\r\n      } else if (dataSet.name.toLowerCase() === PhuirEProjects.huirth) {\r\n        huirthStatus = ProjectStatus.parsed;\r\n      } else {\r\n        added = false;\r\n        const newStatuses = [];\r\n        for (const status of projectsStatuses) {\r\n          if (status.name === dataSet.name) {\r\n            status.status = ProjectStatus.parsed;\r\n            newStatuses.push(status);\r\n            added = true;\r\n          } else {\r\n            newStatuses.push(status);\r\n          }\r\n        }\r\n        if (!added) {\r\n          newStatuses.push({\r\n            name: dataSet.name,\r\n            status: ProjectStatus.parsed\r\n          });\r\n        }\r\n        projectsStatuses = newStatuses;\r\n      }\r\n    }\r\n    return {\r\n      ...state,\r\n      trainingData: newTrainingData,\r\n      stratimuxStatus,\r\n      huirthStatus,\r\n      projectsStatuses\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will update a project's status to saved.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { PhuirEProjects, ProjectStatus, TrainingData } from '../huirth.model';\r\n\r\nexport type huirthUpdateProjectStatusToSavedPayload = {\r\n  name: string\r\n}\r\n\r\nexport const [\r\n  huirthUpdateProjectStatusToSaved,\r\n  huirthUpdateProjectStatusToSavedType,\r\n  huirthUpdateProjectStatusToSavedQuality\r\n] = createQualitySetWithPayload<huirthUpdateProjectStatusToSavedPayload>({\r\n  type: 'huirth update project status to saved',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const { name } = selectPayload<huirthUpdateProjectStatusToSavedPayload>(action);\r\n    let {projectsStatuses, stratimuxStatus, huirthStatus} = state;\r\n    console.log('HIT UPDATED SAVED STATUS!!', name);\r\n    let added = false;\r\n    if (name.toLowerCase() === PhuirEProjects.stratimux) {\r\n      stratimuxStatus = ProjectStatus.saved;\r\n    } else if (name.toLowerCase() === PhuirEProjects.huirth) {\r\n      huirthStatus = ProjectStatus.saved;\r\n    } else {\r\n      added = false;\r\n      const newStatuses = [];\r\n      for (const status of projectsStatuses) {\r\n        if (status.name === name) {\r\n          status.status = ProjectStatus.saved;\r\n          newStatuses.push(status);\r\n          added = true;\r\n        } else {\r\n          newStatuses.push(status);\r\n        }\r\n      }\r\n      if (!added) {\r\n        newStatuses.push({\r\n          name: name,\r\n          status: ProjectStatus.saved\r\n        });\r\n      }\r\n      projectsStatuses = newStatuses;\r\n    }\r\n    return {\r\n      ...state,\r\n      stratimuxStatus,\r\n      huirthStatus,\r\n      projectsStatuses\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming graph programming framework Stratimux and a Concept huirth, generate a quality that updates a project's status via supplied payload and selected by included name property.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { huirthState } from '../huirth.concept';\r\nimport { PhuirEProjects, ProjectStatus } from '../huirth.model';\r\n\r\nexport type huirthUpdateProjectStatusPayload = {\r\n  name: string,\r\n  status: ProjectStatus\r\n}\r\nexport const [\r\n  huirthUpdateProjectStatus,\r\n  huirthUpdateProjectStatusType,\r\n  huirthUpdateProjectStatusQuality\r\n] = createQualitySetWithPayload<huirthUpdateProjectStatusPayload>({\r\n  type: 'huirth Update Project Status',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    const { name, status } = selectPayload<huirthUpdateProjectStatusPayload>(action);\r\n    console.log('CHECK INCOMING STATUS', name, status);\r\n    if (name.toLocaleLowerCase() === PhuirEProjects.stratimux) {\r\n      return {\r\n        ...state,\r\n        stratimuxStatus: status\r\n      };\r\n    } else if (name.toLocaleLowerCase() === PhuirEProjects.huirth) {\r\n      return {\r\n        ...state,\r\n        huirthStatus: status\r\n      };\r\n    } else {\r\n      const projectsStatuses = state.projectsStatuses;\r\n      projectsStatuses.push({\r\n        name,\r\n        status,\r\n      });\r\n      return {\r\n        ...state,\r\n        projectsStatuses,\r\n      };\r\n    }\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and the User Interface Concept, generate a strategy that will append each page strategy's page composition to the state pages property.":{"type":"project","content":"import { ActionStrategy, Concepts, createActionNode, createActionNodeFromStrategy, createStrategy } from 'stratimux';\r\nimport { userInterfaceAddNewPage } from '../qualities/addNewPage.quality';\r\nimport { PageStrategyCreators, userInterface_selectPage } from '../../../model/userInterface';\r\nimport { userInterfacePageToStateStrategy } from './pageToState.strategy';\r\n\r\nexport const userInterfaceAddNewPageStrategyTopic = 'User Interface add new Page Strategy, for: ';\r\nexport function userInterfaceAddNewPageStrategy(name: string, pageStrategy: PageStrategyCreators, concepts: Concepts): ActionStrategy {\r\n  const strategy = userInterfacePageToStateStrategy(pageStrategy(concepts));\r\n  const stepPageToState = createActionNodeFromStrategy(strategy);\r\n  const stepAddToState = createActionNode(userInterfaceAddNewPage({\r\n    pageStrategy,\r\n  }), {\r\n    successNode: stepPageToState,\r\n  });\r\n\r\n  return createStrategy({\r\n    topic: userInterfaceAddNewPageStrategyTopic + name,\r\n    initialNode: stepAddToState,\r\n    data: strategy.data,\r\n    priority: 500\r\n  });\r\n}"},"For the graph programming framework Stratimux and a Concept huirth, generate an Action Strategy Component Stitch that appends the huirth footer to the desired composition.":{"type":"project","content":"import { axium_createStitchNode, createActionNode, createStrategy } from 'stratimux';\r\nimport { huirthFooter } from '../../qualities/components/footer.quality';\r\nimport { ActionStrategyComponentStitch } from '../../../../model/userInterface';\r\n\r\nexport const huirthFooterStitch: ActionStrategyComponentStitch = (payload) => {\r\n  const stepStitch = axium_createStitchNode();\r\n  const stephuirthFooter = createActionNode(huirthFooter(payload), {\r\n    successNode: stepStitch,\r\n  });\r\n  return [stepStitch, createStrategy({\r\n    topic: 'Create huirth Header Content',\r\n    initialNode: stephuirthFooter,\r\n  })];\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate an Action Strategy Component Stitch that appends the huirth style component to the desired composition.":{"type":"project","content":"import { createActionNode, createStrategy } from 'stratimux';\r\nimport { huirthStyle } from '../../qualities/components/style.quality';\r\nimport { huirthHead } from '../../qualities/components/head.quality';\r\nimport { ActionStrategyComponentStitch, userInterface } from '../../../../model/userInterface';\r\n\r\nexport const huirthHeaderStitch: ActionStrategyComponentStitch = (payload) => {\r\n  const stephuirthStyle = userInterface.createComponent(huirthStyle(payload));\r\n  const stephuirthHead = userInterface.createComponent(huirthHead(payload), stephuirthStyle);\r\n  return [stephuirthStyle, createStrategy({\r\n    topic: 'Create huirth Header Content',\r\n    initialNode: stephuirthHead,\r\n  })];\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate an Action Strategy Component Stitch that appends the Sidebar first, content, and last component slices to the desired composition.":{"type":"project","content":"import { createActionNode, createStrategy } from 'stratimux';\r\nimport { ActionStrategyComponentStitch, userInterface } from '../../../../model/userInterface';\r\nimport { huirthSideBarEnd } from '../../qualities/components/sideBar/sideBarEnd.quality';\r\nimport { huirthSideBarBegin } from '../../qualities/components/sideBar/sideBarBegin.quality';\r\nimport { huirthSideBarContent } from '../../qualities/components/sideBar/sideBarContent.quality';\r\n\r\nexport const huirthSidebarComponentStitch: ActionStrategyComponentStitch = (payload) => {\r\n  // HEAD\r\n  const stephuirthSidebarEnd = userInterface.createComponent(huirthSideBarEnd(payload));\r\n  const stephuirthSidebarContent = userInterface.createComponent(huirthSideBarContent(payload), stephuirthSidebarEnd);\r\n  const stephuirthSidebarBegin = userInterface.createComponent(huirthSideBarBegin(payload), stephuirthSidebarContent);\r\n  return [stephuirthSidebarEnd, createStrategy({\r\n    topic: 'Create huirth Sidebar',\r\n    initialNode: stephuirthSidebarBegin,\r\n  })];\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate an ActionStrategy that accepts the current count and conceptSemaphore to have a unified Counter Concept be decremented seven times.":{"type":"project","content":"import { counterSubtract, createActionNode, createStrategy } from 'stratimux';\r\n\r\nexport const huirthMinusSevenStrategy = (count: number, conceptSemaphore: number) => {\r\n  const stepSeventh = createActionNode(counterSubtract({conceptSemaphore}));\r\n  const stepSix = createActionNode(counterSubtract({conceptSemaphore}), {\r\n    successNode: stepSeventh,\r\n  });\r\n  const stepFifth = createActionNode(counterSubtract({conceptSemaphore}), {\r\n    successNode: stepSix,\r\n  });\r\n  const StepFourth = createActionNode(counterSubtract({conceptSemaphore}), {\r\n    successNode: stepFifth,\r\n  });\r\n  const stepThird = createActionNode(counterSubtract({conceptSemaphore}), {\r\n    successNode: StepFourth,\r\n  });\r\n  const stepSecond = createActionNode(counterSubtract({conceptSemaphore}), {\r\n    successNode: stepThird,\r\n  });\r\n  const stepFirst = createActionNode(counterSubtract({conceptSemaphore}), {\r\n    successNode: stepSecond,\r\n  });\r\n\r\n  const topic = `Minus Seven Strategy from: ${count}`;\r\n  return createStrategy({\r\n    initialNode: stepFirst,\r\n    topic,\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate an ActionStrategy that accepts the current count and conceptSemaphore to have a unified Counter Concept be incremented seven times.":{"type":"project","content":"import { counterAdd, createActionNode, createStrategy } from 'stratimux';\r\n\r\nexport const huirthPlusSevenStrategy = (count: number, conceptSemaphore: number) => {\r\n  const stepSeventh = createActionNode(counterAdd({conceptSemaphore}));\r\n  const stepSix = createActionNode(counterAdd({conceptSemaphore}), {\r\n    successNode: stepSeventh,\r\n  });\r\n  const stepFifth = createActionNode(counterAdd({conceptSemaphore}), {\r\n    successNode: stepSix,\r\n  });\r\n  const StepFourth = createActionNode(counterAdd({conceptSemaphore}), {\r\n    successNode: stepFifth,\r\n  });\r\n  const stepThird = createActionNode(counterAdd({conceptSemaphore}), {\r\n    successNode: StepFourth,\r\n  });\r\n  const stepSecond = createActionNode(counterAdd({conceptSemaphore}), {\r\n    successNode: stepThird,\r\n  });\r\n  const stepFirst = createActionNode(counterAdd({conceptSemaphore}), {\r\n    successNode: stepSecond,\r\n  });\r\n\r\n  const topic = `Add Seven Strategy from: ${count}`;\r\n  return createStrategy({\r\n    initialNode: stepFirst,\r\n    topic,\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate an ActionStrategy that will randomly generate a series of steps that will either increment or decrement a unified Counter Concept.":{"type":"project","content":"import { counterAdd, counterSubtract, createActionNode, createStrategy } from 'stratimux';\r\n\r\nfunction getRandomRange(min: number, max: number) {\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\nexport const huirthGenerateCountingStrategy = (count: number, conceptSemaphore: number) => {\r\n  const length = Math.round(getRandomRange(1, 20));\r\n  let numPos = 0;\r\n  let numNeg = 0;\r\n  const firstRand = Math.round(getRandomRange(1, 5));\r\n  const firstAction = firstRand % 2 === 0 ? counterAdd({conceptSemaphore}) : counterSubtract({conceptSemaphore});\r\n  let previousStep = createActionNode(firstAction);\r\n  const stepFirst = previousStep;\r\n  if (firstRand % 2 === 0) {\r\n    numPos++;\r\n  } else {\r\n    numNeg--;\r\n  }\r\n  for (let i = 1; i < length; i++) {\r\n    const even = Math.round(getRandomRange(1, 5)) % 2;\r\n    const action = even ? counterAdd({conceptSemaphore}) : counterSubtract({conceptSemaphore});\r\n    const newStep = createActionNode(action);\r\n    if (even) {\r\n      numPos++;\r\n    } else {\r\n      numNeg--;\r\n    }\r\n\r\n    previousStep.successNode = newStep;\r\n    previousStep = newStep;\r\n  }\r\n  previousStep.successNode = null;\r\n\r\n  const topic = `Generated Counting Strategy from: ${count}, using ${numPos} Adds and ${numNeg} Subtracts`;\r\n  return createStrategy({\r\n    initialNode: stepFirst,\r\n    topic,\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate an ActionStrategy that will set a target project status to installing then utilize the client helper function to trigger the git clone strategy on the server.":{"type":"project","content":"import { createActionNode, createStrategy } from 'stratimux';\r\nimport { huirthUpdateProjectStatus } from '../qualities/updateProjectToStatus.quality';\r\nimport { ProjectStatus } from '../huirth.model';\r\nimport { huirthTriggerCloneGitRepositoryStrategy } from './server/triggerCloneGitRepositoryStrategy.helper';\r\n\r\nexport const huirthInstallGitRepositoryStrategyTopic = 'huirth set project status to installing then trigger git clone strategy on server';\r\nexport const huirthInstallGitRepositoryStrategy = (url: string, name:string) => {\r\n  const stepSendToServer = createActionNode(huirthTriggerCloneGitRepositoryStrategy(url, name), {\r\n    // TODO: If failed we can use open to load a window with the git install webpage\r\n    failureNode: null,\r\n  });\r\n  const stepUpdateToInstalling = createActionNode(huirthUpdateProjectStatus({name, status: ProjectStatus.installing}), {\r\n    successNode: stepSendToServer,\r\n  });\r\n  return createStrategy({\r\n    topic: huirthInstallGitRepositoryStrategyTopic,\r\n    initialNode: stepUpdateToInstalling,\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate a Page Strategy Creator that will unify Sidebar, DataManager, Footer, and Header Action Strategy Component Stitches into a Page Composition.":{"type":"project","content":"import { createActionNode, createStrategy } from 'stratimux';\r\nimport {\r\n  ActionStrategyComponentStitch,\r\n  PageStrategyCreators,\r\n  userInterface,\r\n  userInterface_createPage\r\n} from '../../../../model/userInterface';\r\nimport { userInterfaceCreatePageStrategy } from '../../../userInterface/strategies.ts/createPage.strategy';\r\nimport { huirthFooterStitch } from '../components/footer.strategy';\r\nimport { huirthHeaderStitch } from '../components/header.strategy';\r\nimport { huirthDataManagerBegin } from '../../qualities/components/dataManager/dataManagerBegin.quality';\r\nimport { huirthDataManagerContent } from '../../qualities/components/dataManager/dataManagerContent.quality';\r\nimport { huirthDataManagerEnd } from '../../qualities/components/dataManager/dataManagerEnd.quality';\r\nimport { huirthSidebarComponentStitch } from '../components/sidebar.strategy';\r\n\r\nexport const huirthDataManagerPageStrategyTopic = 'dataManager';\r\nexport const huirthDataManagerPageStrategy: PageStrategyCreators = () => () => {\r\n  const pageData = userInterface_createPage({\r\n    title: huirthDataManagerPageStrategyTopic,\r\n    conceptAndProps: [],\r\n    cachedSelectors: [],\r\n    compositions: [],\r\n    cachedComponentSelectors: []\r\n  });\r\n\r\n  return userInterfaceCreatePageStrategy(\r\n    huirthDataManagerPageStrategyTopic,\r\n    pageData,\r\n    [\r\n      huirthSidebarComponentStitch,\r\n      huirthDataManagerStrategyStitch,\r\n      huirthFooterStitch\r\n    ],\r\n    huirthHeaderStitch\r\n  );\r\n};\r\n\r\nexport const huirthDataManagerStrategyStitchTopic = 'huirth Data Manager Action Strategy Component Stitch';\r\nexport const huirthDataManagerStrategyStitch: ActionStrategyComponentStitch = (payload) => {\r\n  // Body\r\n  const stephuirthDataManagerEnd = userInterface.createComponent(huirthDataManagerEnd(payload));\r\n  const stephuirthDataManagerContent = userInterface.createComponent(huirthDataManagerContent(payload), stephuirthDataManagerEnd);\r\n  const stephuirthDataManagerBegin = userInterface.createComponent(huirthDataManagerBegin(payload), stephuirthDataManagerContent);\r\n  return [\r\n    stephuirthDataManagerEnd,\r\n    createStrategy({\r\n      topic: huirthDataManagerStrategyStitchTopic,\r\n      initialNode: stephuirthDataManagerBegin,\r\n    })\r\n  ];\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate a Page Strategy Creator that will unify Sidebar, DPO, Footer, and Header Action Strategy Component Stitches into a Page Composition.":{"type":"project","content":"import { createActionNode, createStrategy } from 'stratimux';\r\nimport { ActionStrategyComponentStitch, PageStrategyCreators, userInterface, userInterface_createPage } from '../../../../model/userInterface';\r\nimport { userInterfaceCreatePageStrategy } from '../../../userInterface/strategies.ts/createPage.strategy';\r\nimport { huirthFooterStitch } from '../components/footer.strategy';\r\nimport { huirthHeaderStitch } from '../components/header.strategy';\r\nimport { huirthIndexDPOBegin } from '../../qualities/components/DPO/DPOBegin.quality';\r\nimport { huirthIndexDPOContent } from '../../qualities/components/DPO/DPOContent.quality';\r\nimport { huirthIndexDPOEnd } from '../../qualities/components/DPO/DPOEnd.quality';\r\nimport { huirthSidebarComponentStitch } from '../components/sidebar.strategy';\r\n\r\nexport const huirthDataSetDPOPageStrategyTopic = 'dpo';\r\nexport const huirthIndexPageStrategy: PageStrategyCreators = () => () => {\r\n  const pageData = userInterface_createPage({\r\n    title: huirthDataSetDPOPageStrategyTopic,\r\n    conceptAndProps: [],\r\n    cachedSelectors: [],\r\n    cachedComponentSelectors: [],\r\n    compositions: []\r\n  });\r\n\r\n  return userInterfaceCreatePageStrategy(\r\n    huirthDataSetDPOPageStrategyTopic,\r\n    pageData,\r\n    [\r\n      huirthSidebarComponentStitch,\r\n      huirthIndexDPOStrategyStitch,\r\n      huirthFooterStitch\r\n    ],\r\n    huirthHeaderStitch\r\n  );\r\n};\r\n\r\nexport const huirthIndexDPOStrategyStitchTopic = 'huirth Index Training Data Strategy Component Stitch';\r\nexport const huirthIndexDPOStrategyStitch: ActionStrategyComponentStitch = (payload) => {\r\n  const stephuirthIndexDPOEnd = userInterface.createComponent(huirthIndexDPOEnd(payload));\r\n  const stephuirthIndexDPOContent = userInterface.createComponent(huirthIndexDPOContent(payload), stephuirthIndexDPOEnd);\r\n  const stephuirthIndexDPOBegin = userInterface.createComponent(huirthIndexDPOBegin(payload), stephuirthIndexDPOContent);\r\n  return [\r\n    stephuirthIndexDPOEnd,\r\n    createStrategy({\r\n      topic: huirthIndexDPOStrategyStitchTopic,\r\n      initialNode: stephuirthIndexDPOBegin,\r\n    })\r\n  ];\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate a Page Strategy Creator that will unify Sidebar, Error, Footer, and Header Action Strategy Component Stitches into a Page Composition.":{"type":"project","content":"/*<$\r\nFor the graph programming framework Stratimux and a Concept huirth, generate a Page Strategy Creator that will unify Sidebar, Error, Footer, and Header Action Strategy Component Stitches into a Page Composition.\r\n$>*/\r\n/*<#*/"},"For the graph programming framework Stratimux and a Concept huirth, generate a Page Strategy Creator that will unify Sidebar, DataSet, Footer, and Header Action Strategy Component Stitches into a Page Composition.":{"type":"project","content":"import { createActionNode, createStrategy } from 'stratimux';\r\nimport {\r\n  ActionStrategyComponentStitch,\r\n  PageStrategyCreators,\r\n  userInterface,\r\n  userInterface_createPage\r\n} from '../../../../model/userInterface';\r\nimport { userInterfaceCreatePageStrategy } from '../../../userInterface/strategies.ts/createPage.strategy';\r\nimport { huirthFooterStitch } from '../components/footer.strategy';\r\nimport { huirthHeaderStitch } from '../components/header.strategy';\r\nimport { huirthSidebarComponentStitch } from '../components/sidebar.strategy';\r\nimport { huirthDataSetEnd } from '../../qualities/components/dataSet/dataSetEnd.quality';\r\nimport { huirthDataSetContent } from '../../qualities/components/dataSet/dataSetContent.quality';\r\nimport { huirthDataSetBegin } from '../../qualities/components/dataSet/dataSetBegin.quality';\r\n\r\nexport const huirthGeneratedTrainingDataPageStrategy = (pageTitle: string): PageStrategyCreators => {\r\n  const title = pageTitle;\r\n  return () => () => {\r\n    const pageData = userInterface_createPage({\r\n      title,\r\n      conceptAndProps: [],\r\n      cachedSelectors: [],\r\n      compositions: [],\r\n      cachedComponentSelectors: []\r\n    });\r\n\r\n    return userInterfaceCreatePageStrategy(\r\n      title,\r\n      pageData,\r\n      [\r\n        huirthSidebarComponentStitch,\r\n        huirthGeneratedTrainingDataStrategyStitch,\r\n        huirthFooterStitch\r\n      ],\r\n      huirthHeaderStitch\r\n    );\r\n  };\r\n};\r\n\r\nexport const huirthGeneratedTrainingDataStrategyStitchTopic = 'huirth Generated Training Data Strategy Component Stitch';\r\nexport const huirthGeneratedTrainingDataStrategyStitch: ActionStrategyComponentStitch = (payload) => {\r\n  const stephuirthDataSetEnd = userInterface.createComponent(huirthDataSetEnd(payload));\r\n  const stephuirthDataManagerContent = userInterface.createComponent(huirthDataSetContent(payload), stephuirthDataSetEnd);\r\n  const stephuirthDataSetBegin = userInterface.createComponent(huirthDataSetBegin(payload), stephuirthDataManagerContent);\r\n  return [\r\n    stephuirthDataSetEnd,\r\n    createStrategy({\r\n      topic: `huirth Generated ${payload.pageTitle} Training Data Strategy Stitch`,\r\n      initialNode: stephuirthDataSetBegin,\r\n    })\r\n  ];\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate a Page Strategy Creator called index, that will unify Sidebar, Hero, Dialog, Footer, and Header Action Strategy Component Stitches into a Page Composition.":{"type":"project","content":"import { axium_createStitchNode, createStrategy } from 'stratimux';\r\nimport {\r\n  ActionComponentPayload,\r\n  ActionStrategyComponentStitch,\r\n  PageStrategyCreators,\r\n  userInterface,\r\n  userInterface_createPage\r\n} from '../../../../model/userInterface';\r\nimport { userInterfaceCreatePageStrategy } from '../../../userInterface/strategies.ts/createPage.strategy';\r\nimport { huirthFooterStitch } from '../components/footer.strategy';\r\nimport { huirthHeaderStitch } from '../components/header.strategy';\r\nimport { huirthIndexHero } from '../../qualities/components/hero/indexHero.quality';\r\nimport { huirthIndexDialogBegin } from '../../qualities/components/dialog/indexDialogBegin.quality';\r\nimport { huirthIndexDialogContent } from '../../qualities/components/dialog/indexDialogContent.quality';\r\nimport { huirthIndexDialogEnd } from '../../qualities/components/dialog/indexDialogEnd.quality';\r\nimport { huirthSidebarComponentStitch } from '../components/sidebar.strategy';\r\n\r\nexport const huirthIndexPageStrategyTopic = 'index';\r\nexport const huirthIndexPageStrategy: PageStrategyCreators = () => () => {\r\n  const page: ActionComponentPayload = {\r\n    pageTitle: huirthIndexPageStrategyTopic,\r\n  };\r\n  const stepStitch = axium_createStitchNode();\r\n  const stephuirthIndexHero = userInterface.createComponent(huirthIndexHero(page), stepStitch);\r\n  const huirthBody: ActionStrategyComponentStitch = (payload: ActionComponentPayload) => [stepStitch, createStrategy({\r\n    topic: 'Create huirth Body Content',\r\n    initialNode: stephuirthIndexHero,\r\n  })];\r\n\r\n  const pageData = userInterface_createPage({\r\n    title: huirthIndexPageStrategyTopic,\r\n    conceptAndProps: [],\r\n    cachedSelectors: [],\r\n    compositions: [],\r\n    cachedComponentSelectors: []\r\n  });\r\n\r\n  return userInterfaceCreatePageStrategy(\r\n    huirthIndexPageStrategyTopic,\r\n    pageData,\r\n    [\r\n      huirthSidebarComponentStitch,\r\n      huirthBody,\r\n      huirthIndexDialogStrategyStitch,\r\n      huirthFooterStitch\r\n    ],\r\n    huirthHeaderStitch\r\n  );\r\n};\r\n\r\nexport const huirthIndexDialogStrategyStitchTopic = 'huirth Index Dialog Strategy Component Stitch';\r\nexport const huirthIndexDialogStrategyStitch: ActionStrategyComponentStitch = (payload) => {\r\n  // Body\r\n  const stephuirthIndexDialogEnd = userInterface.createComponent(huirthIndexDialogEnd(payload));\r\n  const stephuirthIndexDialogContent = userInterface.createComponent(huirthIndexDialogContent(payload), stephuirthIndexDialogEnd);\r\n  const stephuirthIndexDialogBegin = userInterface.createComponent(huirthIndexDialogBegin(payload), stephuirthIndexDialogContent);\r\n  return [\r\n    stephuirthIndexDialogEnd,\r\n    createStrategy({\r\n      topic: huirthIndexDialogStrategyStitchTopic,\r\n      initialNode: stephuirthIndexDialogBegin,\r\n    })\r\n  ];\r\n};"},"For the graph programming framework Stratimux and the Huirth Brand Concept, generate a strategy that will remove a page by name and its union pageStrategy":{"type":"project","content":"import { ActionStrategy, createActionNode, createStrategy } from 'stratimux';\r\nimport { huirthFilterTrainingDataPage } from '../qualities/filterTrainingDataPage.quality';\r\nimport { userInterfaceRemovePage } from '../../userInterface/qualities/removePage.quality';\r\n\r\nexport const huirthRemoveTrainingDataPageStrategyTopic = 'Huirth remove training data page strategy. ';\r\nexport function huirthRemoveTrainingDataPageStrategy(name: string): ActionStrategy {\r\n  const filterFromTrainingDataPages = createActionNode(huirthFilterTrainingDataPage({\r\n    trainingDataName: name,\r\n  }));\r\n  const stepRemoveTrainingDataFromState = createActionNode(userInterfaceRemovePage({\r\n    name,\r\n  }), {\r\n    successNode: filterFromTrainingDataPages\r\n  });\r\n\r\n  return createStrategy({\r\n    topic: huirthRemoveTrainingDataPageStrategyTopic,\r\n    initialNode: stepRemoveTrainingDataFromState,\r\n    priority: 600\r\n  });\r\n}"},"For the graph programming framework Stratimux and a Concept huirth, for the client generate a helper action that will trigger the clone git repository on the server.":{"type":"project","content":"import { createAction } from 'stratimux';\r\nimport { userInterfaceClientSendActionToServer } from '../../../userInterfaceClient/strategies/sendActionToServer.helper';\r\n\r\nexport const huirthSendTriggerTransformationStrategy = (selection: string) =>\r\n  (userInterfaceClientSendActionToServer(createAction('huirthServer trigger passed transformation strategy from payload', {payload: {\r\n    selection\r\n  }})));"},"For the graph programming framework Stratimux and a Concept huirth, for the client generate a helper action that will trigger the save DPO strategy on the server.":{"type":"project","content":"import { createAction } from 'stratimux';\r\nimport { userInterfaceClientSendActionToServer } from '../../../userInterfaceClient/strategies/sendActionToServer.helper';\r\n\r\nexport const huirthTriggerSaveDPOStrategy = () =>\r\n  (userInterfaceClientSendActionToServer(createAction('huirthServer trigger save DPO strategy')));"},"For the graph programming framework Stratimux and a Concept huirth, for the client generate a helper action that will trigger the save training data strategy on the server.":{"type":"project","content":"import { createAction } from 'stratimux';\r\nimport { userInterfaceClientSendActionToServer } from '../../../userInterfaceClient/strategies/sendActionToServer.helper';\r\n\r\nexport const huirthTriggerSaveTrainingDataStrategy = () =>\r\n  (userInterfaceClientSendActionToServer(createAction('huirthServer trigger save training data strategy')));"},"For the graph programming framework Stratimux and a Concept huirth, generate an ActionStrategy that will set a target project status to the passed value of status.":{"type":"project","content":"import { createActionNode, createStrategy } from 'stratimux';\r\nimport { huirthUpdateProjectStatus } from '../qualities/updateProjectToStatus.quality';\r\nimport { ProjectStatus } from '../huirth.model';\r\n\r\nexport const huirthUpdateProjectStatusStrategyTopic = 'huirth set project status to the specified status';\r\nexport const huirthUpdateProjectStatusStrategy = (name:string, status: ProjectStatus) => {\r\n  const stepSendToServer = createActionNode(huirthUpdateProjectStatus({\r\n    name,\r\n    status\r\n  }), {\r\n    // TODO: If failed we can use open to load a window with the git install webpage\r\n    failureNode: null,\r\n  });\r\n  const stepUpdateToInstalling = createActionNode(huirthUpdateProjectStatus({name, status: ProjectStatus.installing}), {\r\n    successNode: stepSendToServer,\r\n  });\r\n  return createStrategy({\r\n    topic: huirthUpdateProjectStatusStrategyTopic,\r\n    initialNode: stepUpdateToInstalling,\r\n  });\r\n};"},"For the asynchronous graph programming framework Stratimux, generate a tests and demonstrates how buffer methods perform their functionality.":{"type":"project","content":"import { CounterState, axiumKick, counterAdd, counterName, counterSelectCount, createAxium, createCounterConcept, createExperimentConcept, createExperimentState, createStage, selectState, stageWaitForOpenThenIterate } from 'stratimux';\r\nimport {\r\n  experimentAsyncBufferMultiplyByCountFromConcepts,\r\n  experimentAsyncBufferMultiplyByCountFromConceptsQuality\r\n} from './qualities/asyncBufferMultiplyByCountFromConceptsAction.quality';\r\nimport {\r\n  experimentBufferMultiplyByCountFromConcepts,\r\n  experimentBufferMultiplyByCountFromConceptsQuality\r\n} from './qualities/bufferMultiplyByCountFromConceptsAction.quality';\r\nimport { experimentBufferNextAction, experimentBufferNextActionQuality } from './qualities/bufferSomeAction.quality';\r\n\r\ntest('Buffer method periodic count', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentBufferNextActionQuality]);\r\n  const axium = createAxium('Experiment method buffer defer actions', [createCounterConcept(), experiment]);\r\n  const plan = axium.plan('Experiment buffer add 4 after 10ms', [\r\n    stageWaitForOpenThenIterate(() => axiumKick()),\r\n    createStage((_, dispatch) => {\r\n      dispatch(experimentBufferNextAction({\r\n        action: counterAdd()\r\n      }), {\r\n        iterateStage: true,\r\n      });\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const counterState = selectState<CounterState>(concepts, counterName);\r\n      expect(counterState?.count).toBe(0);\r\n      dispatch(experimentBufferNextAction({\r\n        action: counterAdd()\r\n      }), {\r\n        iterateStage: true,\r\n      });\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const counterState = selectState<CounterState>(concepts, counterName);\r\n      expect(counterState?.count).toBe(0);\r\n      dispatch(experimentBufferNextAction({\r\n        action: counterAdd()\r\n      }), {\r\n        iterateStage: true,\r\n      });\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const counterState = selectState<CounterState>(concepts, counterName);\r\n      expect(counterState?.count).toBe(0);\r\n      dispatch(experimentBufferNextAction({\r\n        action: counterAdd()\r\n      }), {\r\n        iterateStage: true,\r\n      });\r\n    }),\r\n    createStage((concepts, _dispatch, changes) => {\r\n      const counterState = selectState<CounterState>(concepts, counterName);\r\n      if (changes.length > 0) {\r\n        expect(counterState?.count).toBe(4);\r\n        setTimeout(() => {\r\n          plan.conclude();\r\n          axium.close();\r\n          done();\r\n        }, 10);\r\n      }\r\n    }, {selectors: [counterSelectCount], beat: 200}),\r\n    createStage(() => {\r\n      plan.conclude();\r\n    })\r\n  ]);\r\n});\r\n\r\n// test('Buffer method with concept towards final multiply of count', (done) => {\r\n//   const experiment = createExperimentConcept(createExperimentState(), [experimentBufferMultiplyByCountFromConceptsQuality]);\r\n//   const axium = createAxium('Experiment method buffer defer multiply', [createCounterConcept(), experiment]);\r\n//   const plan = axium.plan('Experiment buffer multiply by 2 from concept state after 10ms', [\r\n//     stageWaitForOpenThenIterate(() => axiumKick()),\r\n//     createStage((_, dispatch) => {\r\n//       dispatch(counterSetCount({\r\n//         newCount: 2\r\n//       }), {\r\n//         iterateStage: true,\r\n//       });\r\n//     }),\r\n//     createStage((concepts, dispatch) => {\r\n//       const counterState = selectState<CounterState>(concepts, counterName);\r\n//       expect(counterState?.count).toBe(2);\r\n//       dispatch(experimentBufferMultiplyByCountFromConcepts(), {\r\n//         iterateStage: true,\r\n//       });\r\n//     }),\r\n//     createStage((concepts, dispatch) => {\r\n//       const counterState = selectState<CounterState>(concepts, counterName);\r\n//       expect(counterState?.count).toBe(2);\r\n//       dispatch(experimentBufferMultiplyByCountFromConcepts(), {\r\n//         iterateStage: true,\r\n//       });\r\n//     }),\r\n//     createStage((concepts, dispatch) => {\r\n//       const counterState = selectState<CounterState>(concepts, counterName);\r\n//       expect(counterState?.count).toBe(2);\r\n//       dispatch(experimentBufferMultiplyByCountFromConcepts(), {\r\n//         iterateStage: true,\r\n//       });\r\n//     }),\r\n//     createStage((concepts, _dispatch, changes) => {\r\n//       const counterState = selectState<CounterState>(concepts, counterName);\r\n//       if (changes.length > 0) {\r\n//         expect(counterState?.count).toBe(16);\r\n//         setTimeout(() => {\r\n//           plan.conclude();\r\n//           axium.close();\r\n//           done();\r\n//         }, 10);\r\n//       }\r\n//     }, {selectors: [counterSelectCount], beat: 200}),\r\n//     createStage(() => {\r\n//       plan.conclude();\r\n//     })\r\n//   ]);\r\n// });\r\n\r\n// test('Buffer method with concept towards final multiply of count', (done) => {\r\n//   const experiment = createExperimentConcept(createExperimentState(), [experimentAsyncBufferMultiplyByCountFromConceptsQuality]);\r\n//   const axium = createAxium('Experiment method buffer defer multiply', [createCounterConcept(), experiment], {\r\n//     // logActionStream: true\r\n//   });\r\n//   const plan = axium.plan('Experiment buffer multiply by 2 from concept state after 10ms', [\r\n//     stageWaitForOpenThenIterate(() => axiumKick()),\r\n//     createStage((_, dispatch) => {\r\n//       dispatch(counterSetCount({\r\n//         newCount: 2\r\n//       }), {\r\n//         iterateStage: true,\r\n//       });\r\n//     }),\r\n//     createStage((concepts, dispatch) => {\r\n//       const counterState = selectState<CounterState>(concepts, counterName);\r\n//       expect(counterState?.count).toBe(2);\r\n//       dispatch(experimentAsyncBufferMultiplyByCountFromConcepts(), {\r\n//         iterateStage: true,\r\n//       });\r\n//     }),\r\n//     createStage((concepts, dispatch) => {\r\n//       const counterState = selectState<CounterState>(concepts, counterName);\r\n//       expect(counterState?.count).toBe(2);\r\n//       dispatch(experimentAsyncBufferMultiplyByCountFromConcepts(), {\r\n//         iterateStage: true,\r\n//       });\r\n//     }),\r\n//     createStage((concepts, dispatch) => {\r\n//       const counterState = selectState<CounterState>(concepts, counterName);\r\n//       expect(counterState?.count).toBe(2);\r\n//       dispatch(experimentAsyncBufferMultiplyByCountFromConcepts(), {\r\n//         iterateStage: true,\r\n//       });\r\n//     }),\r\n//     createStage((concepts, _dispatch, changes) => {\r\n//       const counterState = selectState<CounterState>(concepts, counterName);\r\n//       console.log('CHECK STATE', counterState);\r\n//       if (changes.length > 0) {\r\n//         expect(counterState?.count).toBe(16);\r\n//         setTimeout(() => {\r\n//           plan.conclude();\r\n//           axium.close();\r\n//           done();\r\n//         }, 10);\r\n//       }\r\n//     }, {selectors: [counterSelectCount], beat: 200}),\r\n//     createStage(() => {\r\n//       plan.conclude();\r\n//     })\r\n//   ]);\r\n//   // axium.subscribe(c => {\r\n//   //   const s = getAxiumState(c);\r\n//   //   console.log(s.head, s.body, s.tail);\r\n//   // });\r\n// });"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a method that will buffer asynchronously\r\nthe dispatch of an action assigned to payload.":{"type":"project","content":"import { CounterState, counterAdd, counterName, createActionNode, createAsyncMethodBufferWithConcepts, createQualitySet, createStrategy, defaultReducer, selectState, strategyBegin } from 'stratimux';\r\n\r\n\r\nexport const [\r\n  experimentAsyncBufferMultiplyByCountFromConcepts,\r\n  experimentAsyncBufferMultiplyByCountFromConceptsType,\r\n  experimentAsyncBufferMultiplyByCountFromConceptsQuality\r\n] = createQualitySet({\r\n  type: 'Experiment will asynchronously buffer multiply count using concepts accessing counter state',\r\n  reducer: defaultReducer,\r\n  methodCreator: (c, s) => createAsyncMethodBufferWithConcepts((controller, _, concepts) => {\r\n    setTimeout(() => {\r\n      const counterState = selectState<CounterState>(concepts, counterName);\r\n      controller.fire(strategyBegin(createStrategy({\r\n        initialNode: createActionNode(counterAdd()),\r\n        topic: 'AsyncBuffered Action Topic'\r\n      })));\r\n    }, 50);\r\n  }, c, s, 10)\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a method that will buffer\r\nthe dispatch of an action assigned to payload.":{"type":"project","content":"import { Action, createActionNode, createMethodBuffer, createQualitySetWithPayload, createStrategy, defaultReducer, selectPayload, strategyBegin } from 'stratimux';\r\n\r\ntype ExperimentBufferNextActionPayload = {\r\n  action: Action\r\n}\r\n\r\nexport const [\r\n  experimentBufferNextAction,\r\n  experimentBufferNextActionType,\r\n  experimentBufferNextActionQuality\r\n] = createQualitySetWithPayload<ExperimentBufferNextActionPayload>({\r\n  type: 'Experiment will buffer incoming actions for a set duration',\r\n  reducer: defaultReducer,\r\n  methodCreator: () => createMethodBuffer((action) => {\r\n    const act = selectPayload<ExperimentBufferNextActionPayload>(action).action;\r\n    return strategyBegin(createStrategy({\r\n      initialNode: createActionNode(act),\r\n      topic: 'Buffered Action Topic'\r\n    }));\r\n  }, 10)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a test that will ensure that parseFileFrom's parsing function is working as intended.":{"type":"project","content":"const createData = () => {\r\n  return `\r\n  This would be some data that exists beyond the stop point. But has be excluded due to parsing reasons.\r\n  And would include a series of prompts bound with content. That tests whether the parsing system is working as intended.\r\n`;\r\n\r\nimport { ParsingTokens } from '../../huirthServer/huirthServer.model';\r\nimport { BaseDataSet } from '../huirth.model';\r\n\r\nconst recurseExclude = (content: string): string => {\r\n  const excludeBegin = content.indexOf(ParsingTokens.excludeBegin);\r\n  if (excludeBegin !== -1) {\r\n    const excludeEnd = content.indexOf(ParsingTokens.excludeEnd) + ParsingTokens.excludeEnd.length;\r\n    if (excludeEnd !== -1) {\r\n      const sliceBegin = content.substring(0, excludeBegin);\r\n      const newContent = sliceBegin + content.substring(excludeEnd);\r\n      const newExclude = newContent.indexOf(ParsingTokens.excludeBegin);\r\n      if (newExclude !== -1) {\r\n        return recurseExclude(newContent);\r\n      } else {\r\n        return newContent;\r\n      }\r\n    } else {\r\n      return content.substring(0, excludeBegin) + content.substring(excludeBegin + ParsingTokens.excludeBegin.length);\r\n    }\r\n  }\r\n  return content;\r\n};\r\n\r\nconst recursiveParse = (data: BaseDataSet[], content: string): BaseDataSet[] => {\r\n  const index = content.indexOf(ParsingTokens.promptBegin);\r\n  const stop = content.indexOf(ParsingTokens.stop);\r\n  const stopExists = stop !== -1;\r\n  const willStop = (i: number) => stopExists ? i < stop : true;\r\n  if (index !== -1 && willStop(index)) {\r\n    let output = '';\r\n    const promptBegin = index + ParsingTokens.promptBegin.length;\r\n    const promptEnd = content.indexOf(ParsingTokens.promptEnd);\r\n    const contentBegin = content.indexOf(ParsingTokens.contentBegin) + ParsingTokens.contentBegin.length;\r\n    const contentEnd = content.indexOf(ParsingTokens.contentEnd);\r\n    const importBegin = content.indexOf(ParsingTokens.importBegin);\r\n    const includeBegin = content.indexOf(ParsingTokens.includeBegin);\r\n    if (importBegin !== -1 && importBegin < contentEnd && willStop(contentEnd)) {\r\n      const begin = importBegin + ParsingTokens.importBegin.length;\r\n      const end = content.indexOf(ParsingTokens.importEnd);\r\n      output += recurseExclude(content.substring(begin, end));\r\n    }\r\n    if (includeBegin !== -1 && includeBegin < contentEnd && willStop(contentEnd)) {\r\n      const begin = includeBegin + ParsingTokens.includeBegin.length;\r\n      const end = content.indexOf(ParsingTokens.includeEnd);\r\n      output += content.substring(begin, end);\r\n    }\r\n    if (willStop(promptEnd)) {\r\n      const prompt = content.substring(promptBegin, promptEnd).trim();\r\n      output += recurseExclude(content.substring(contentBegin, contentEnd));\r\n      output = output.trim();\r\n      data.push({\r\n        prompt,\r\n        content: output\r\n      });\r\n    }\r\n    const sub = content.substring(contentEnd + ParsingTokens.contentEnd.length);\r\n    const cont = sub.indexOf(ParsingTokens.promptBegin);\r\n    if (cont  !== -1 && willStop(cont)) {\r\n      return recursiveParse(data, sub);\r\n    }\r\n  }\r\n  return data;\r\n};\r\n/*<%\r\nconst createData = () => {\r\n  return `\r\n  This would be some data that exists beyond the stop point. But has be excluded due to parsing reasons.\r\n  And would include a series of prompts bound with content. That tests whether the parsing system is working as intended.\r\n`;\r\n%>*/\r\ntest('userInterfaceBindingsToString', (done) => {\r\n  const simulated = createData();\r\n  const parsed = recursiveParse([], simulated);\r\n  console.log(parsed);\r\n  expect(parsed.length).toBe(2);\r\n  done();\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a test that will ensure that the selectSlice helper function from Stratimux is operating as intended.":{"type":"project","content":"import { Concepts, KeyedSelector, createConcept, createUnifiedKeyedSelector, selectSlice } from 'stratimux';\r\nimport { generateBaseDataSetEntry, generateDefaultNamedDataSet } from '../huirth.model';\r\n\r\ntest('userInterfaceBindingsToString', (done) => {\r\n  const simulated = {\r\n    trainingData: [generateDefaultNamedDataSet('something')],\r\n  };\r\n  const experiment = createConcept(\r\n    'experiment',\r\n    simulated\r\n  );\r\n  const concepts: Concepts = {\r\n    1: experiment\r\n  };\r\n  const entry = generateBaseDataSetEntry();\r\n  const selector = createUnifiedKeyedSelector(concepts, 1, 'trainingData.0.dataSet.0.prompt') as KeyedSelector;\r\n  const getUndefined = {...selector};\r\n  getUndefined.conceptName = 'something';\r\n  expect(selectSlice(concepts, selector)).toBe(entry.prompt);\r\n  expect(selectSlice(concepts, getUndefined)).toBe(undefined);\r\n  done();\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a test that will confirm that the generateNumID function is working as intended.":{"type":"project","content":"import { generateNumID, promptID, selectTrainingDataIndex } from '../huirth.model';\r\n\r\ntest('userInterfaceBindingsToString', (done) => {\r\n  const ID = promptID + generateNumID(0);\r\n  const element = {} as HTMLElement;\r\n  element.id = ID;\r\n  expect(selectTrainingDataIndex(element, promptID)).toBe(0);\r\n  done();\r\n});"},"For the graph programming framework Stratimux generate a Brand Server Concept called huirth Server that will be responsible for all server side qualities and principle.":{"type":"project","content":"import { createConcept, Concept, unifyConcepts, PrincipleFunction, Quality } from 'stratimux';\r\nimport { huirthState } from '../huirth/huirth.concept';\r\nimport { huirthServerTriggerSaveTrainingDataStrategyQuality } from './qualities/triggerSaveTrainingDataStrategy.quality';\r\nimport { huirthServerPrinciple } from './huirthServer.principle';\r\nimport { huirthServerReadFromDataTrainingDataFromDirectoriesQuality } from './qualities/readFromDataTrainingDataFromDirectory.quality';\r\nimport { huirthServerSetDPOFromDataQuality } from './qualities/setDPOFromData.quality';\r\nimport { huirthServerTriggerSaveDPOStrategyQuality } from './qualities/triggerSaveDPOStrategy.quality';\r\nimport { huirthServerIsDataDirectorySetUpQuality } from './qualities/isDataDirectorySetUp.quality';\r\nimport { huirthServerTriggerCloneGitRepositoryStrategyQuality } from './qualities/triggerCloneGitRepositoryStrategy.quality';\r\nimport { huirthServerGitCloneRepoToDirectoryQuality } from './qualities/gitCloneRepoToDirectory.quality';\r\nimport { huirthServerSetRepositoriesFromDataQuality } from './qualities/setRepositoriesFromData.quality';\r\nimport { huirthServerTriggerParseRepositoryStrategyQuality } from './qualities/triggerParseRepositoryIntoDataSet.quality';\r\nimport { huirthServerParseFileFromDataQuality } from './qualities/parseFileFromData.quality';\r\nimport { huirthServerDetermineReadParseAppendStrategyQuality } from './qualities/determineReadParseAppendStrategy.quality';\r\nimport { huirthServerAppendParsedDataToNamedDataSetQuality } from './qualities/appendParsedDataToNamedDataSet.quality';\r\nimport { huirthServerPrepareParsedProjectDataUpdateQuality } from './qualities/prepareUpdateParsedProjectData.quality';\r\nimport { huirthServerTriggerSaveDataSetSelectionStrategyQuality } from './qualities/triggerSaveDataSetSelectionStrategy.quality';\r\nimport { huirthServerSetTrainingDataFromDataQuality } from './qualities/setTrainingDataFromData.quality';\r\nimport { huirthServerTriggerDeleteDataSetsStrategyQuality } from './qualities/triggerDeleteDataSetsStrategy.quality';\r\nimport { huirthServerInnerAddToQuality } from './qualities/innerAddTo.quality';\r\nimport { huirthServerGenerateVerboseAddingStrategyQuality } from './qualities/generateVerboseAddingDataSet.quality';\r\nimport { huirthServerTriggerSelectTransformationStrategyQuality } from './qualities/triggerSelectedTransformationStrategy.quality';\r\nimport { huirthServerInnerSubtractFromQuality } from './qualities/innerSubtractFrom.quality';\r\nimport { huirthServerGenerateVerboseSubtractionStrategyQuality } from './qualities/generateVerboseSubtractionDataSet.quality';\r\nimport { huirthServerGenerateVerboseAdditionAndSubtractionStrategyQuality } from './qualities/generateVerboseAdditionAndSubtractionDataSet.quality';\r\nimport { huirthServerExitPrinciple } from './huirthServer.exit.principle';\r\nimport { huirthServerGitPullRepositoryQuality } from './qualities/gitPullRepository.quality';\r\nimport { huirthServerTriggerGitPullRepositoryStrategyQuality } from './qualities/triggerGitPullRepositoryStrategy.quality';\r\n\r\nexport const huirthServerName = 'huirthServer';\r\nexport type huirthServerState = {\r\n  //\r\n} & huirthState;\r\n\r\nexport const createHuirthServerConcept = (): Concept =>  {\r\n  const principles: PrincipleFunction[] = [\r\n    huirthServerPrinciple,\r\n    huirthServerExitPrinciple\r\n  ];\r\n  const qualities: Quality[] = [\r\n    huirthServerTriggerSaveTrainingDataStrategyQuality,\r\n    huirthServerTriggerSaveDPOStrategyQuality,\r\n    huirthServerReadFromDataTrainingDataFromDirectoriesQuality,\r\n    huirthServerSetDPOFromDataQuality,\r\n    huirthServerSetTrainingDataFromDataQuality,\r\n    huirthServerIsDataDirectorySetUpQuality,\r\n    huirthServerGitCloneRepoToDirectoryQuality,\r\n    huirthServerTriggerCloneGitRepositoryStrategyQuality,\r\n    huirthServerTriggerGitPullRepositoryStrategyQuality,\r\n    huirthServerTriggerParseRepositoryStrategyQuality,\r\n    huirthServerTriggerSaveDataSetSelectionStrategyQuality,\r\n    huirthServerTriggerDeleteDataSetsStrategyQuality,\r\n    huirthServerSetRepositoriesFromDataQuality,\r\n    huirthServerParseFileFromDataQuality,\r\n    huirthServerDetermineReadParseAppendStrategyQuality,\r\n    huirthServerAppendParsedDataToNamedDataSetQuality,\r\n    huirthServerPrepareParsedProjectDataUpdateQuality,\r\n    huirthServerInnerAddToQuality,\r\n    huirthServerGenerateVerboseAddingStrategyQuality,\r\n    huirthServerTriggerSelectTransformationStrategyQuality,\r\n    huirthServerInnerSubtractFromQuality,\r\n    huirthServerGenerateVerboseSubtractionStrategyQuality,\r\n    huirthServerGenerateVerboseAdditionAndSubtractionStrategyQuality,\r\n    huirthServerGitPullRepositoryQuality\r\n  ];\r\n  return unifyConcepts(\r\n    [\r\n    ],\r\n    createConcept(\r\n      huirthServerName,\r\n      {},\r\n      qualities,\r\n      principles,\r\n      []\r\n    ));\r\n};"},"For the graph programming framework Stratimux and Brand Concept huirth that extends the Server Concept, generate a principle that close the axium if a message is received at a specified api endpoint.":{"type":"project","content":"export const huirthServerExitPrinciple: PrincipleFunction =\r\n  (_: Subscriber<Action>, cpts: Concepts, concepts$: UnifiedSubject, semaphore: number) => {\r\n    let shouldClose = false;\r\n    const beat = 333;\r\n    const initialServerState = selectUnifiedState(cpts, semaphore) as ServerState;\r\n    const server = initialServerState.server;\r\n    const plan = concepts$.plan('Server listening for exit signal', [\r\n      createStage((concepts, dispatch) => {\r\n        const name = getUnifiedName(concepts, semaphore);\r\n        if (name) {\r\n          dispatch(axiumRegisterStagePlanner({conceptName: name, stagePlanner: plan}), {\r\n            iterateStage: true\r\n          });\r\n        } else {\r\n          plan.conclude();\r\n        }\r\n      }),\r\n      createStage((concepts, dispatch) => {\r\n        const name = getUnifiedName(concepts, semaphore);\r\n        if (name) {\r\n          if (shouldClose) {\r\n            dispatch(axiumPreClose({\r\n              exit: true\r\n            }), {\r\n              iterateStage: true\r\n            });\r\n          }\r\n        } else {\r\n          plan.conclude();\r\n        }\r\n      }, {beat}),\r\n      createStage((__, ___) => {\r\n        plan.conclude();\r\n      }),\r\n    ]);\r\n\r\n    server.get('/server/axiumEXIT', (__, req) => {\r\n      shouldClose = true;\r\n      req.json({\r\n        exit: shouldClose\r\n      });\r\n    });\r\n  };"},"For the graph programming framework Stratimux and a Concept huirth Server, generate the model file contents that will handle Data Sets, Failure Conditions, and Tokens.":{"type":"project","content":"import { DPO_DataSet } from '../../model/huirth';\r\nimport { Active_DPO, BaseDataSet, DataSetTypes, NamedDataSet, TrainingData } from '../huirth/huirth.model';\r\n\r\n// eslint-disable-next-line no-shadow\r\nexport enum huirthServerFailureConditions {\r\n  noTrainingData = 'noTrainingData',\r\n  failedParsingTrainingData = 'failedParsingTrainingData',\r\n}\r\n\r\n// eslint-disable-next-line no-shadow\r\nexport enum dataDirectories {\r\n  gitRepo = 'repositories',\r\n  sets = 'sets'\r\n}\r\n\r\nexport const convertDPOToSaveFormatDPO = (trainingData: Active_DPO[]) => {\r\n  const saveFormat: SavedFormat = {};\r\n  trainingData.forEach((entry) => {\r\n    saveFormat[entry.prompt] = {\r\n      type: DataSetTypes.dpo,\r\n      content: '',\r\n      chosen: entry.chosen,\r\n      rejected: entry.chosen,\r\n    };\r\n  });\r\n  return saveFormat;\r\n};\r\n\r\nexport type SavedFormat = {\r\n  [prompt: string]: ({\r\n    type: string\r\n    content: string\r\n  } & Record<string, string>)\r\n}\r\n\r\nexport const convertNamedDataSetToSaveFormat = (named: NamedDataSet) => {\r\n  const saveFormat: SavedFormat = {};\r\n  named.dataSet.forEach((entry) => {\r\n    saveFormat[entry.prompt] = {\r\n      type: named.type,\r\n      content: entry.content\r\n    };\r\n    const keys = Object.keys(entry);\r\n    for (const key of keys) {\r\n      if (key !== 'prompt' && key !== 'content' && key !== 'type') {\r\n        saveFormat.prompt[key] = entry[key];\r\n      }\r\n    }\r\n  });\r\n  return saveFormat;\r\n};\r\n\r\nexport const convertSavedFormatToNamedDataSet = (saved: SavedFormat, name: string) => {\r\n  const named: NamedDataSet = {\r\n    name,\r\n    type: DataSetTypes.general,\r\n    dataSet: [],\r\n    index: 0\r\n  };\r\n  const keys = Object.keys(saved);\r\n  for (const key of keys) {\r\n    const final: BaseDataSet = {\r\n      prompt: key,\r\n      content: ''\r\n    };\r\n    const data = saved[key];\r\n    const dataKeys = Object.keys(data);\r\n    for (const d of dataKeys) {\r\n      if (d === 'type') {\r\n        named.type = data[d] as DataSetTypes;\r\n      } else {\r\n        final[d] = data[d];\r\n      }\r\n    }\r\n    named.dataSet.push(final);\r\n  }\r\n  return named;\r\n};\r\n\r\nexport const convertSaveFormatDPOToDPO = (named: NamedDataSet) => {\r\n  const DPO: Active_DPO[] = [];\r\n  for (const set of named.dataSet) {\r\n    DPO.push({\r\n      prompt: set.prompt,\r\n      chosen: set.chosen !== undefined ? set.chosen : '',\r\n      rejected: set.rejected !== undefined ? set.rejected : '',\r\n    });\r\n  }\r\n  return DPO;\r\n};\r\n\r\nexport const TRANSFORMATION_DATASET_LIMIT = 25;"},"For the graph programming framework Stratimux and a Concept huirth Server, generate principle that will dispatch a initialization strategy.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport {\r\n  Action,\r\n  Concepts,\r\n  PrincipleFunction,\r\n  UnifiedSubject,\r\n  axiumRegisterStagePlanner,\r\n  createStage,\r\n  getUnifiedName,\r\n  selectState,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { FileSystemState, fileSystemName } from '../fileSystem/fileSystem.concept';\r\nimport { huirthServerInitializationStrategy } from './strategies/initialization.strategy';\r\n\r\nexport const huirthServerPrinciple: PrincipleFunction =\r\n  (_: Subscriber<Action>, _cpts: Concepts, concepts$: UnifiedSubject, semaphore: number) => {\r\n    const plan = concepts$.plan('huirthServer initialization plan', [\r\n      createStage((concepts, dispatch) => {\r\n        const conceptName = getUnifiedName(concepts, semaphore);\r\n        if (conceptName) {\r\n          dispatch(axiumRegisterStagePlanner({conceptName, stagePlanner: plan}), {\r\n            iterateStage: true,\r\n          });\r\n        } else {\r\n          plan.conclude();\r\n        }\r\n      }),\r\n      createStage((concepts, dispatch) => {\r\n        const root = selectState<FileSystemState>(concepts, fileSystemName)?.root;\r\n        if (root) {\r\n          dispatch(strategyBegin(huirthServerInitializationStrategy(root)), {\r\n            iterateStage: true\r\n          });\r\n        } else {\r\n          plan.conclude();\r\n        }\r\n      }),\r\n      createStage((__, ___) => {\r\n        plan.conclude();\r\n      }),\r\n    ]);\r\n  };"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality will add an entry or create a specified named data set to state, then remove the first entry from the filesAndData field.":{"type":"project","content":"import {\r\n  Action,\r\n  ActionType,\r\n  createMethod,\r\n  createQuality,\r\n  createQualitySetWithPayload,\r\n  prepareActionWithPayloadCreator,\r\n  selectPayload,\r\n  strategyData_select,\r\n  strategyData_unifyData,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { ReadDirectoryField } from '../../fileSystem/qualities/readDir.quality';\r\nimport { ParsedFileFromDataField } from './parseFileFromData.quality';\r\nimport { huirthServerState } from '../huirthServer.concept';\r\nimport { DataSetTypes } from '../../huirth/huirth.model';\r\n\r\nexport type huirthServerAppendParsedDataToNamedDataSetPayload = {\r\n  name: string,\r\n  type: DataSetTypes\r\n}\r\n\r\nexport const [\r\n  huirthServerAppendParsedDataToNamedDataSet,\r\n  huirthServerAppendParsedDataToNamedDataSetType,\r\n  huirthServerAppendParsedDataToNamedDataSetQuality\r\n] = createQualitySetWithPayload<huirthServerAppendParsedDataToNamedDataSetPayload>({\r\n  type: 'huirthServer append parsed data to named data set, then remove its path from fileAndDirectories field',\r\n  reducer: (state: huirthServerState, action: Action): huirthServerState => {\r\n    const {name, type} = selectPayload<huirthServerAppendParsedDataToNamedDataSetPayload>(action);\r\n    if (action.strategy) {\r\n      const {strategy} = action;\r\n      const {dataSetSelection} = state;\r\n      const data = strategyData_select<ParsedFileFromDataField>(strategy);\r\n      if (data) {\r\n        const {parsed} = data;\r\n        const {trainingData} = state;\r\n        let added = false;\r\n        for (const set of trainingData) {\r\n          if (set.name === name) {\r\n            set.dataSet = [\r\n              ...set.dataSet,\r\n              ...parsed\r\n            ];\r\n            added = true;\r\n            console.log(set.dataSet.length, parsed.length);\r\n            break;\r\n          }\r\n        }\r\n        if (!added) {\r\n          trainingData.push({\r\n            name,\r\n            type,\r\n            dataSet: parsed,\r\n            index: 0\r\n          });\r\n          dataSetSelection.push(false);\r\n        }\r\n        return {\r\n          ...state,\r\n          trainingData,\r\n          dataSetSelection\r\n        };\r\n      }\r\n    }\r\n    return {\r\n      ...state,\r\n    };\r\n  },\r\n  methodCreator: () =>\r\n    createMethod((action) => {\r\n      if (action.strategy && action.strategy.data) {\r\n        const strategy = action.strategy;\r\n        const data = strategyData_select(action.strategy) as ReadDirectoryField;\r\n        data.filesAndDirectories.shift();\r\n        return strategySuccess(strategy, strategyData_unifyData(strategy, data));\r\n      } else {\r\n        return action;\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that will generate a strategy to read, parse, and append to state the output of every FileDirent passed via the data field.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  UnifiedSubject,\r\n  createActionNode,\r\n  createMethodWithState,\r\n  createQualitySetWithPayload,\r\n  createStrategy,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyBegin,\r\n  strategyData_appendFailure,\r\n  strategyFailed,\r\n  strategySequence,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { huirthServerState } from '../huirthServer.concept';\r\nimport { huirthServerSendUpdateParsedProjectData } from '../strategies/client/huirthServerSendUpdateParsedProjectData.helper';\r\n\r\nexport type huirthServerPrepareParsedProjectDataUpdatePayload = {\r\n  name: string,\r\n}\r\n\r\nexport const [\r\n  huirthServerPrepareParsedProjectDataUpdate,\r\n  huirthServerPrepareParsedProjectDataUpdateType,\r\n  huirthServerPrepareParsedProjectDataUpdateQuality\r\n] = createQualitySetWithPayload<huirthServerPrepareParsedProjectDataUpdatePayload>({\r\n  type: 'huirthServer prepare parsed data set to be sent to client',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$, semaphore) =>\r\n    createMethodWithState<huirthServerState>((action, state) => {\r\n      if (action.strategy) {\r\n        const strategy = action.strategy;\r\n        const { name } = selectPayload<huirthServerPrepareParsedProjectDataUpdatePayload>(action);\r\n        const { trainingData } = state;\r\n        for (const dataSet of trainingData) {\r\n          if (dataSet.name === name) {\r\n            console.log('FOUND DATA SET', dataSet);\r\n            const nextStrategy = createStrategy({\r\n              initialNode: createActionNode(huirthServerSendUpdateParsedProjectData(dataSet), {\r\n                successNode: null,\r\n                failureNode: null\r\n              }),\r\n              topic: 'Update Client of Parsed Project'\r\n            });\r\n            strategy.puntedStrategy?.push(nextStrategy);\r\n            return strategySuccess(strategy);\r\n          }\r\n        }\r\n        return strategyFailed(strategy, strategyData_appendFailure(strategy, 'Did not find data set'));\r\n      } else {\r\n        return action;\r\n      }\r\n    }, concepts$ as UnifiedSubject, semaphore as number)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will create a plan which will populate a new data set with the outcome of many\r\nverbose adding strategies.":{"type":"project","content":"import {\r\n  ActionType,\r\n  MethodCreator,\r\n  UnifiedSubject,\r\n  axiumKick,\r\n  createAsyncMethodWithConcepts,\r\n  createQuality,\r\n  nullReducer,\r\n  getAxiumState,\r\n  prepareActionCreator,\r\n  selectState,\r\n  strategyBegin,\r\n  createStage,\r\n  createQualitySet,\r\n  axiumSelectLastStrategy,\r\n} from 'stratimux';\r\nimport { DataSetTypes, NamedDataSet } from '../../huirth/huirth.model';\r\nimport { huirthServerInnerAddField } from './innerAddTo.quality';\r\nimport { huirthServerSaveDataSetStrategy } from '../strategies/saveDataSet.strategy';\r\nimport { FileSystemState, fileSystemName } from '../../fileSystem/fileSystem.concept';\r\nimport { huirthServerVerboseAdditionAndSubtractionStrategy } from '../strategies/verboseAdditionAndSubtraction.strategy';\r\nimport { huirth_convertNumberToStringVerbose } from '../verboseNumber.model';\r\nimport { TRANSFORMATION_DATASET_LIMIT } from '../huirthServer.model';\r\n\r\nexport const [\r\n  huirthServerGenerateVerboseAdditionAndSubtractionStrategy,\r\n  huirthServerGenerateVerboseAdditionAndSubtractionStrategyType,\r\n  huirthServerGenerateVerboseAdditionAndSubtractionStrategyQuality\r\n] = createQualitySet({\r\n  type: 'huirthServer generate a verbose addition and subtraction data set',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$, semaphore) => createAsyncMethodWithConcepts((controller, _, cpts) => {\r\n    const axiumState = getAxiumState(cpts);\r\n    const fileSystemState = selectState<FileSystemState>(cpts, fileSystemName);\r\n    if (concepts$ && fileSystemState) {\r\n      console.log('This had been triggered');\r\n      const limit = TRANSFORMATION_DATASET_LIMIT;\r\n      const named: NamedDataSet = {\r\n        name: 'VerboseAdditionAndSubtraction',\r\n        type: DataSetTypes.general,\r\n        dataSet: [],\r\n        index: 0\r\n      };\r\n      let length = 5;\r\n      let iterations = 0;\r\n      let currentTopic = '';\r\n      const plan = axiumState.concepts$.plan('Verbose Addition and Subtraction data set generation plan',\r\n      [\r\n        createStage((__, dispatch) => {\r\n          console.log('Transformation stage 1', iterations < 100, length < limit);\r\n          if (iterations < 100 && length < limit) {\r\n            const newStrategy = huirthServerVerboseAdditionAndSubtractionStrategy(length);\r\n            newStrategy.topic = iterations + 1 + '.) ' + newStrategy.topic;\r\n            currentTopic = newStrategy.topic;\r\n            console.log('BEGIN STRATEGY', currentTopic);\r\n            dispatch(strategyBegin(newStrategy), {\r\n              iterateStage: true,\r\n              throttle: 1\r\n            });\r\n          } else {\r\n            console.log('END PLAN');\r\n            dispatch(axiumKick(), {\r\n              setStage: 2\r\n            });\r\n          }\r\n        }),\r\n        createStage((concepts, dispatch) => {\r\n          const state = getAxiumState(concepts);\r\n          console.log('Transformation stage 2', iterations, length, currentTopic === state.lastStrategy);\r\n          if (state.lastStrategy === currentTopic) {\r\n            named.dataSet.push({\r\n              prompt: (currentTopic + '.').trim(),\r\n              content: (state.lastStrategyDialog + '\\nThe final sum is ' + huirth_convertNumberToStringVerbose((state.lastStrategyData as huirthServerInnerAddField).sum) + '.').trim()\r\n            });\r\n            console.log('iterations: ', iterations);\r\n            iterations++;\r\n            if (iterations === 100) {\r\n              if (length <= limit) {\r\n                length++;\r\n                iterations = 0;\r\n              }\r\n            }\r\n            console.log('DISPATCH');\r\n            dispatch(axiumKick(), {\r\n              setStage: 0,\r\n              throttle: 0\r\n            });\r\n          }\r\n        }, {beat: 30, selectors: [axiumSelectLastStrategy]}),\r\n        createStage((concepts) => {\r\n          console.log('Transformation stage 3', iterations, length, named.dataSet.length);\r\n          controller.fire(strategyBegin(huirthServerSaveDataSetStrategy(fileSystemState.root, named, 'VerboseAdditionAndSubtraction', concepts)));\r\n          plan.conclude();\r\n        })\r\n      ]);\r\n    }\r\n}, concepts$ as UnifiedSubject, semaphore as number)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will create a plan which will populate a new data set with the outcome of many\r\nverbose subtraction strategies.":{"type":"project","content":"import {\r\n  UnifiedSubject,\r\n  axiumKick,\r\n  createAsyncMethodWithConcepts,\r\n  nullReducer,\r\n  getAxiumState,\r\n  selectState,\r\n  strategyBegin,\r\n  createStage,\r\n  createQualitySet,\r\n  axiumSelectLastStrategy,\r\n} from 'stratimux';\r\nimport { DataSetTypes, NamedDataSet } from '../../huirth/huirth.model';\r\nimport { huirthServerInnerAddField } from './innerAddTo.quality';\r\nimport { huirthServerSaveDataSetStrategy } from '../strategies/saveDataSet.strategy';\r\nimport { FileSystemState, fileSystemName } from '../../fileSystem/fileSystem.concept';\r\nimport { huirthServerVerboseSubtractionStrategy } from '../strategies/verboseSubtraction.strategy';\r\nimport { huirth_convertNumberToStringVerbose } from '../verboseNumber.model';\r\nimport { TRANSFORMATION_DATASET_LIMIT } from '../huirthServer.model';\r\n\r\nexport const [\r\n  huirthServerGenerateVerboseSubtractionStrategy,\r\n  huirthServerGenerateVerboseSubtractionStrategyType,\r\n  huirthServerGenerateVerboseSubtractionStrategyQuality\r\n] = createQualitySet({\r\n  type: 'huirthServer generate a verbose subtraction data set',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$, semaphore) => createAsyncMethodWithConcepts((controller, _, cpts) => {\r\n    const axiumState = getAxiumState(cpts);\r\n    const fileSystemState = selectState<FileSystemState>(cpts, fileSystemName);\r\n    if (concepts$ && fileSystemState) {\r\n      console.log('This had been triggered');\r\n      const limit = TRANSFORMATION_DATASET_LIMIT;\r\n      const named: NamedDataSet = {\r\n        name: 'VerboseSubtraction',\r\n        type: DataSetTypes.general,\r\n        dataSet: [],\r\n        index: 0\r\n      };\r\n      let length = 5;\r\n      let iterations = 0;\r\n      let currentTopic = '';\r\n      const plan = axiumState.concepts$.plan('Verbose Subtraction data set generation plan',\r\n      [\r\n        createStage((__, dispatch) => {\r\n          console.log('Transformation stage 1', iterations < 100, length < limit);\r\n          if (iterations < 100 && length < limit) {\r\n            const newStrategy = huirthServerVerboseSubtractionStrategy(length);\r\n            newStrategy.topic = iterations + 1 + '.) ' + newStrategy.topic;\r\n            currentTopic = newStrategy.topic;\r\n            console.log('BEGIN STRATEGY', currentTopic);\r\n            dispatch(strategyBegin(newStrategy), {\r\n              iterateStage: true,\r\n              throttle: 1\r\n            });\r\n          } else {\r\n            console.log('END PLAN');\r\n            dispatch(axiumKick(), {\r\n              setStage: 2\r\n            });\r\n          }\r\n        }),\r\n        createStage((concepts, dispatch) => {\r\n          const state = getAxiumState(concepts);\r\n          console.log('Transformation stage 2', iterations, length, currentTopic === state.lastStrategy);\r\n          if (state.lastStrategy === currentTopic) {\r\n            named.dataSet.push({\r\n              prompt: (currentTopic + '.').trim(),\r\n              content: ('' + state.lastStrategyDialog + '\\nThe final sum ' + huirth_convertNumberToStringVerbose((state.lastStrategyData as huirthServerInnerAddField).sum) + '.').trim()\r\n            });\r\n            console.log('iterations', iterations);\r\n            iterations++;\r\n            if (iterations === 100) {\r\n              if (length <= limit) {\r\n                length++;\r\n                iterations = 0;\r\n              }\r\n            }\r\n            console.log('DISPATCH');\r\n            dispatch(axiumKick(), {\r\n              setStage: 0,\r\n              throttle: 0\r\n            });\r\n          }\r\n        }, {beat: 30, selectors: [axiumSelectLastStrategy]}),\r\n        createStage((concepts) => {\r\n          console.log('Transformation stage 3', iterations, length, named.dataSet.length);\r\n          controller.fire(strategyBegin(huirthServerSaveDataSetStrategy(fileSystemState.root, named, 'VerboseSubtraction', concepts)));\r\n          plan.conclude();\r\n        })\r\n      ]);\r\n    }\r\n  }, concepts$ as UnifiedSubject, semaphore as number)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that will clone a git repository into the supplied payload path.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  createAsyncMethodDebounce,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyFailed,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport child_process from 'child_process';\r\nimport path from 'path';\r\n\r\nexport type GitPullRepositoryPayload = {\r\n  path: string\r\n};\r\n\r\nexport const [\r\n  huirthServerGitPullRepository,\r\n  huirthServerGitPullRepositoryType,\r\n  huirthServerGitPullRepositoryQuality\r\n] = createQualitySetWithPayload<GitPullRepositoryPayload>({\r\n  type: 'huirthServer pull most recent changes for targeted repository',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethodDebounce((controller, action) => {\r\n      const payload = selectPayload<GitPullRepositoryPayload>(action);\r\n      if (action.strategy) {\r\n        const target = path.join(`${payload.path.split('data')[0]}` + '/server/src/concepts/huirthServer/model/gitPull.sh');\r\n        const process = child_process.spawn('sh', [target, payload.path]);\r\n        process.on('exit', (something) => {\r\n          console.log('CHECK THIS SOMETHING', something);\r\n          const newStrategy =\r\n            strategySuccess(action.strategy as ActionStrategy);\r\n          controller.fire(newStrategy);\r\n        });\r\n        process.on('message', (message) => {\r\n          console.log(message);\r\n        });\r\n        process.on('error', (error) => {\r\n          console.error(error);\r\n          const newStrategy =\r\n            strategyFailed(action.strategy as ActionStrategy);\r\n          controller.fire(newStrategy);\r\n        });\r\n      } else {\r\n        controller.fire(action);\r\n      }\r\n    }, 50)\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that add a number to a sum in the data field.":{"type":"project","content":"import {\r\n  createMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyData_select,\r\n  strategyData_unifyData,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { huirth_convertNumberToStringVerbose } from '../verboseNumber.model';\r\n\r\nexport type huirthServerInnerAddToPayload = {\r\n  addTo: number\r\n};\r\nexport type huirthServerInnerAddField = {\r\n  sum: number\r\n}\r\n\r\nexport const [\r\n  huirthServerInnerAddTo,\r\n  huirthServerInnerAddToType,\r\n  huirthServerInnerAddToQuality\r\n] = createQualitySetWithPayload<huirthServerInnerAddToPayload>({\r\n  type: 'plus',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createMethod((action) => {\r\n      const {addTo} = selectPayload<huirthServerInnerAddToPayload>(action);\r\n      if (action.strategy) {\r\n        const strategy = action.strategy;\r\n        const data = strategyData_select<huirthServerInnerAddField>(strategy);\r\n        if (data) {\r\n          const {sum} = data;\r\n          const final = sum + addTo;\r\n          let verboseSum = huirth_convertNumberToStringVerbose(sum);\r\n          verboseSum = verboseSum[0].toUpperCase() + verboseSum.substring(1);\r\n          strategy.currentNode.actionType = verboseSum.trim() + ' ' + action.type + ' ' + huirth_convertNumberToStringVerbose(addTo).trim() + ', equals ' + huirth_convertNumberToStringVerbose(final).trim();\r\n          strategy.currentNode.successNotes = {\r\n            preposition: ''\r\n          };\r\n          console.log(verboseSum, ' add to ', addTo, ' is ', final);\r\n          return strategySuccess(strategy, strategyData_unifyData(strategy, {\r\n            sum: final\r\n          }));\r\n        }\r\n      }\r\n      return action;\r\n    })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that subtract a number from a total sum in the data field.":{"type":"project","content":"import {\r\n  createMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyData_select,\r\n  strategyData_unifyData,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { huirth_convertNumberToStringVerbose } from '../verboseNumber.model';\r\n\r\nexport type huirthServerInnerSubtractFromPayload = {\r\n  subtractFrom: number\r\n};\r\nexport type huirthServerInnerAddField = {\r\n  sum: number\r\n}\r\n\r\nexport const [\r\n  huirthServerInnerSubtractFrom,\r\n  huirthServerInnerSubtractFromType,\r\n  huirthServerInnerSubtractFromQuality\r\n] = createQualitySetWithPayload<huirthServerInnerSubtractFromPayload>({\r\n  type: 'subtract',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createMethod((action) => {\r\n      const {subtractFrom} = selectPayload<huirthServerInnerSubtractFromPayload>(action);\r\n      if (action.strategy) {\r\n        const strategy = action.strategy;\r\n        const data = strategyData_select<huirthServerInnerAddField>(strategy);\r\n        if (data) {\r\n          const {sum} = data;\r\n          const final = sum - subtractFrom;\r\n          let verboseSum = huirth_convertNumberToStringVerbose(sum);\r\n          verboseSum = verboseSum[0].toUpperCase() + verboseSum.substring(1);\r\n          strategy.currentNode.actionType = verboseSum.trim()  + ' ' + action.type + ' ' + huirth_convertNumberToStringVerbose(subtractFrom).trim() + ', equals ' + huirth_convertNumberToStringVerbose(final).trim();\r\n          strategy.currentNode.successNotes = {\r\n            preposition: ''\r\n          };\r\n          console.log(verboseSum, ' subtract ', subtractFrom, ' equals ', final);\r\n          return strategySuccess(strategy, strategyData_unifyData(strategy, {\r\n            sum: final\r\n          }));\r\n        }\r\n      }\r\n      return action;\r\n    })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that will determine if the data directory is properly step up.":{"type":"project","content":"import {\r\n  createAsyncMethod,\r\n  createQualitySet,\r\n  nullReducer,\r\n  strategyData_select,\r\n  strategyFailed,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { GetDirectoriesAndFilesDataField } from '../../fileSystem/qualities/getDirectoriesAndFiles.quality';\r\nimport { dataDirectories } from '../huirthServer.model';\r\n\r\nexport const [\r\n  huirthServerIsDataDirectorySetUp,\r\n  huirthServerIsDataDirectorySetUpType,\r\n  huirthServerIsDataDirectorySetUpQuality\r\n] = createQualitySet({\r\n  type: 'huirth Server determine if data directory is set up',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethod((controller, action) => {\r\n      if (action.strategy && action.strategy.data) {\r\n        const data = strategyData_select(action.strategy) as GetDirectoriesAndFilesDataField;\r\n        if (data.directories) {\r\n          if (data.directories.length === 0) {\r\n            controller.fire(strategyFailed(action.strategy));\r\n          } else {\r\n            let repoFound = false;\r\n            let setsFound = false;\r\n            data.directories.forEach(directory => {\r\n              if (directory.name === dataDirectories.gitRepo) {\r\n                repoFound = true;\r\n              } else if (directory.name === dataDirectories.sets) {\r\n                setsFound = true;\r\n              }\r\n            });\r\n            if (repoFound && setsFound) {\r\n              controller.fire(strategySuccess(action.strategy));\r\n            } else {\r\n              controller.fire(strategyFailed(action.strategy));\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        controller.fire(action);\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that will parse the contents of a file supplied from the data field for a dataset set by payload.":{"type":"project","content":"import {\r\n  ActionType,\r\n  createAsyncMethod,\r\n  createQuality,\r\n  createQualitySet,\r\n  nullReducer,\r\n  prepareActionCreator,\r\n  strategyData_appendFailure,\r\n  strategyData_select,\r\n  strategyData_unifyData,\r\n  strategyFailed,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { ReadDirectoryField } from '../../fileSystem/qualities/readDir.quality';\r\nimport { BaseDataSet } from '../../huirth/huirth.model';\r\nimport { ReadFileContentsAndAppendToDataField } from '../../fileSystem/qualities/readFileContentsAndAppendToData.quality';\r\nimport { ParsingTokens } from '../huirthServer.model';\r\nimport { FileDirent } from '../../fileSystem/fileSystem.model';\r\n\r\nexport type ParsedFileFromDataField = {\r\n  parsed: BaseDataSet[]\r\n}\r\n\r\nconst recurseExclude = (content: string, file: FileDirent): string => {\r\n  const excludeBegin = content.indexOf(ParsingTokens.excludeBegin);\r\n  if (excludeBegin !== -1) {\r\n    const excludeEnd = content.indexOf(ParsingTokens.excludeEnd) + ParsingTokens.excludeEnd.length;\r\n    if (excludeEnd !== -1) {\r\n      const sliceBegin = content.substring(0, excludeBegin);\r\n      const newContent = sliceBegin + content.substring(excludeEnd);\r\n      const newExclude = newContent.indexOf(ParsingTokens.excludeBegin);\r\n      if (newExclude !== -1 && newContent.length < content.length) {\r\n        return recurseExclude(newContent, file);\r\n      } else if (newContent.length < content.length) {\r\n        return newContent;\r\n      } else {\r\n        console.error('PARSING ERROR @ ', file);\r\n        return '';\r\n      }\r\n    } else {\r\n      return content.substring(0, excludeBegin) + content.substring(excludeBegin + ParsingTokens.excludeBegin.length);\r\n    }\r\n  }\r\n  return content;\r\n};\r\n\r\nconst recursiveParse = (data: BaseDataSet[], content: string, file: FileDirent): BaseDataSet[] => {\r\n  const index = content.indexOf(ParsingTokens.promptBegin);\r\n  const stop = content.indexOf(ParsingTokens.stop);\r\n  const stopExists = stop !== -1;\r\n  const willStop = (i: number) => stopExists ? i < stop : true;\r\n  if (index !== -1 && willStop(index)) {\r\n    let output = '';\r\n    const promptBegin = index + ParsingTokens.promptBegin.length;\r\n    const promptEnd = content.indexOf(ParsingTokens.promptEnd);\r\n    const contentBegin = content.indexOf(ParsingTokens.contentBegin) + ParsingTokens.contentBegin.length;\r\n    const contentEnd = content.indexOf(ParsingTokens.contentEnd);\r\n    const importBegin = content.indexOf(ParsingTokens.importBegin);\r\n    const includeBegin = content.indexOf(ParsingTokens.includeBegin);\r\n    if (importBegin !== -1 && importBegin < contentEnd && willStop(contentEnd)) {\r\n      const begin = importBegin + ParsingTokens.importBegin.length;\r\n      const end = content.indexOf(ParsingTokens.importEnd);\r\n      output += recurseExclude(content.substring(begin, end), file);\r\n    }\r\n    if (includeBegin !== -1 && includeBegin < contentEnd && willStop(contentEnd)) {\r\n      const begin = includeBegin + ParsingTokens.includeBegin.length;\r\n      const end = content.indexOf(ParsingTokens.includeEnd);\r\n      output += content.substring(begin, end);\r\n    }\r\n    if (willStop(promptEnd)) {\r\n      const prompt = content.substring(promptBegin, promptEnd).trim();\r\n      output += recurseExclude(content.substring(contentBegin, contentEnd), file);\r\n      output = output.trim();\r\n      data.push({\r\n        prompt,\r\n        content: output\r\n      });\r\n    }\r\n    const sub = content.substring(contentEnd + ParsingTokens.contentEnd.length);\r\n    const cont = sub.indexOf(ParsingTokens.promptBegin);\r\n    if (cont  !== -1 && willStop(cont)) {\r\n      return recursiveParse(data, sub, file);\r\n    }\r\n  }\r\n  return data;\r\n};\r\n\r\nexport const [\r\n  huirthServerParseFileFromData,\r\n  huirthServerParseFileFromDataType,\r\n  huirthServerParseFileFromDataQuality\r\n] = createQualitySet({\r\n  type: 'huirthServer parse file from data',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethod((controller, action) => {\r\n      if (action.strategy && action.strategy.data) {\r\n        const strategy = action.strategy;\r\n        const data = strategyData_select(action.strategy) as ReadDirectoryField & ReadFileContentsAndAppendToDataField;\r\n        if (data.filesAndDirectories && data.content) {\r\n          // console.log('CHECK CONTENT', data.content);\r\n          const parsed = recursiveParse([], data.content, data.dirent);\r\n          // console.log('CHECK PARSE', parsed);\r\n          controller.fire(strategySuccess(action.strategy, strategyData_unifyData(strategy, {\r\n            parsed,\r\n          })));\r\n        } else {\r\n          controller.fire(strategyFailed(strategy, strategyData_appendFailure(strategy, 'No filesAndData field provided')));\r\n        }\r\n      } else {\r\n        controller.fire(action);\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that reads a data set based on the incoming data field and unifies such back into the ActionStrategy data.":{"type":"project","content":"import {\r\n  createAsyncMethod,\r\n  createQualitySet,\r\n  nullReducer,\r\n  strategyData_appendFailure,\r\n  strategyData_select,\r\n  strategyData_unifyData,\r\n  strategyFailed,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { GetDirectoriesAndFilesDataField } from '../../fileSystem/qualities/getDirectoriesAndFiles.quality';\r\nimport fs from 'fs/promises';\r\nimport { convertSavedFormatToNamedDataSet, huirthServerFailureConditions } from '../huirthServer.model';\r\nimport path from 'path';\r\nimport { FileDirent } from '../../fileSystem/fileSystem.model';\r\nimport { NamedDataSet, TrainingData } from '../../huirth/huirth.model';\r\n\r\nasync function readAllDirectories(fileDirent: FileDirent[]): Promise<TrainingData> {\r\n  const data: TrainingData = [];\r\n  for (const fD of fileDirent) {\r\n    if (fD.isDirectory()) {\r\n      const contents = (await fs.readdir(path.join(fD.path + '/' + fD.name), {\r\n        withFileTypes: true\r\n      }) as FileDirent[]);\r\n      for (const entry of contents) {\r\n        if (entry.isFile()) {\r\n          try {\r\n            const json = JSON.parse((await fs.readFile(path.join(entry.path + '/' + entry.name))).toString());\r\n            const keys = Object.keys(json);\r\n            // eslint-disable-next-line max-depth\r\n            if (json[keys[0]] && Object.keys(json[keys[0]]).includes('content')) {\r\n              const set: NamedDataSet = convertSavedFormatToNamedDataSet(\r\n                json,\r\n                fD.name,\r\n              );\r\n              data.push(set);\r\n            }\r\n          } catch (error) {\r\n            console.error('ERROR AT READ ALL DIRECTORIES huirth SERVER READ FROM DATA TRAINING DATA', error);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return data;\r\n}\r\n\r\nexport type ReadFromDataTrainingDataFromDirectoriesField = {\r\n  trainingData: TrainingData\r\n}\r\n\r\nexport const [\r\n  huirthServerReadFromDataTrainingDataFromDirectories,\r\n  huirthServerReadFromDataTrainingDataFromDirectoriesType,\r\n  huirthServerReadFromDataTrainingDataFromDirectoriesQuality\r\n] = createQualitySet({\r\n  type: 'huirth Server read from File System Data, Directories and Files',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethod((controller, action) => {\r\n      if (action.strategy && action.strategy.data) {\r\n        const strategy = action.strategy;\r\n        const data = strategyData_select(action.strategy) as GetDirectoriesAndFilesDataField;\r\n        console.log('READ FROM DATA TRAINING CHECK', data);\r\n        if (data.directories) {\r\n          if (data.directories.length !== 0) {\r\n            try {\r\n              readAllDirectories(data.directories).then((trainingData) => {\r\n                controller.fire(strategySuccess(strategy, strategyData_unifyData(strategy, {\r\n                  trainingData,\r\n                })));\r\n              });\r\n            } catch (error) {\r\n              controller.fire(strategyFailed(strategy, strategyData_appendFailure(\r\n                strategy,\r\n                huirthServerFailureConditions.failedParsingTrainingData\r\n              )));\r\n            }\r\n          } else {\r\n            controller.fire(strategyFailed(action.strategy, strategyData_appendFailure(\r\n              action.strategy,\r\n              huirthServerFailureConditions.noTrainingData\r\n            )));\r\n          }\r\n        }\r\n      } else {\r\n        controller.fire(action);\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and a Concept huirthServer, generate a quality that parses a DPO data set from the incoming data field and adds such into state.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n  strategyData_select,\r\n} from 'stratimux';\r\nimport { huirthServerState } from '../huirthServer.concept';\r\nimport { convertSaveFormatDPOToDPO } from '../huirthServer.model';\r\nimport { ReadFromDataTrainingDataFromDirectoriesField } from './readFromDataTrainingDataFromDirectory.quality';\r\nimport { DataSetTypes } from '../../huirth/huirth.model';\r\n\r\nexport const [\r\n  huirthServerSetDPOFromData,\r\n  huirthServerSetDPOFromDataType,\r\n  huirthServerSetDPOFromDataQuality\r\n] = createQualitySet({\r\n  type: 'huirthServer set DPO after parsing Training Data from passed Data',\r\n  reducer: (\r\n    state: huirthServerState,\r\n    action: Action\r\n  ): huirthServerState => {\r\n    if (action.strategy && action.strategy.data) {\r\n      const data = strategyData_select(action.strategy) as ReadFromDataTrainingDataFromDirectoriesField;\r\n      const convert = data.trainingData.filter(set => set.type === DataSetTypes.dpo);\r\n      const activeDPO = convert.map(set => convertSaveFormatDPOToDPO(set)).flatMap(set => set);\r\n      if (activeDPO) {\r\n        return {\r\n          ...state,\r\n          activeDPO,\r\n        };\r\n      }\r\n    }\r\n    return {\r\n      ...state,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that sets the initial project status based on their existence in the incoming data field.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n  strategyData_select,\r\n} from 'stratimux';\r\nimport { GetDirectoriesAndFilesDataField } from '../../fileSystem/qualities/getDirectoriesAndFiles.quality';\r\nimport { DPO_DataSet } from '../../../model/huirth';\r\nimport { huirthState } from '../../huirth/huirth.concept';\r\nimport { PhuirEProjects, ProjectStatus } from '../../huirth/huirth.model';\r\n\r\nexport type SetRepositoriesFromDataField = {\r\n  trainingData: DPO_DataSet\r\n}\r\n\r\nexport const [\r\n  huirthServerSetRepositoriesFromData,\r\n  huirthServerSetRepositoriesFromDataType,\r\n  huirthServerSetRepositoriesFromDataQuality\r\n] = createQualitySet({\r\n  type: 'huirth Server set initial project status from data',\r\n  reducer: (state: huirthState, action: Action): huirthState => {\r\n    if (action.strategy) {\r\n      const data = strategyData_select(action.strategy) as GetDirectoriesAndFilesDataField;\r\n      if (data) {\r\n        let stratimuxExists = false;\r\n        let huirthExists = false;\r\n        const projectsStatuses: {name: string, status: ProjectStatus}[] = [];\r\n        for (const dir of data.directories) {\r\n          switch (dir.name.toLowerCase()) {\r\n          case PhuirEProjects.stratimux.toLocaleLowerCase(): {\r\n            stratimuxExists = true;\r\n            break;\r\n          }\r\n          case PhuirEProjects.huirth.toLocaleLowerCase(): {\r\n            huirthExists = true;\r\n            break;\r\n          }\r\n          default: {\r\n            projectsStatuses.push({name: dir.name, status: ProjectStatus.installed});\r\n          }\r\n          }\r\n        }\r\n        console.log('CHECK INSTALLED STATUSES', projectsStatuses);\r\n        return {\r\n          ...state,\r\n          stratimuxStatus: stratimuxExists ? ProjectStatus.installed : ProjectStatus.notInstalled,\r\n          huirthStatus: huirthExists ? ProjectStatus.installed : ProjectStatus.notInstalled,\r\n          projectsStatuses,\r\n        };\r\n      }\r\n    }\r\n    return {\r\n      ...state\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirthServer, generate a quality that parses a series of data sets from the incoming data field and adds such into state's trainingData.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n  strategyData_select,\r\n} from 'stratimux';\r\nimport { huirthServerState } from '../huirthServer.concept';\r\nimport { ReadFromDataTrainingDataFromDirectoriesField } from './readFromDataTrainingDataFromDirectory.quality';\r\n\r\nexport const [\r\n  huirthServerSetTrainingDataFromData,\r\n  huirthServerSetTrainingDataFromDataType,\r\n  huirthServerSetTrainingDataFromDataQuality\r\n] = createQualitySet({\r\n  type: 'huirthServer set parsed Training Data from passed Data',\r\n  reducer: (\r\n    state: huirthServerState,\r\n    action: Action\r\n  ): huirthServerState => {\r\n    if (action.strategy && action.strategy.data) {\r\n      const data = strategyData_select(action.strategy) as ReadFromDataTrainingDataFromDirectoriesField;\r\n      if (data.trainingData) {\r\n        const trainingData = data.trainingData;\r\n        return {\r\n          ...state,\r\n          trainingData,\r\n          dataSetSelection: new Array(data.trainingData.length).fill(false)\r\n        };\r\n      }\r\n    }\r\n    return {\r\n      ...state,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that will trigger the ActionStrategy that will clone a specified git repository.":{"type":"project","content":"import {\r\n  Concepts,\r\n  createMethodDebounceWithConcepts,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  selectState,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { FileSystemState, fileSystemName } from '../../fileSystem/fileSystem.concept';\r\nimport { huirthServerCloneGitRepositoryToDirectoryStrategy } from '../strategies/cloneGitRepositoryToDirectory.strategy';\r\nimport { Subject } from 'rxjs';\r\n\r\nexport type huirthServerTriggerCloneGitRepositoryStrategyPayload = {\r\n  url: string,\r\n  name: string\r\n}\r\n\r\nexport const [\r\n  huirthServerTriggerCloneGitRepositoryStrategy,\r\n  huirthServerTriggerCloneGitRepositoryStrategyType,\r\n  huirthServerTriggerCloneGitRepositoryStrategyQuality\r\n] = createQualitySetWithPayload<huirthServerTriggerCloneGitRepositoryStrategyPayload>({\r\n  type: 'huirthServer trigger clone git repository ActionStrategy',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$, semaphore) =>\r\n    createMethodDebounceWithConcepts(\r\n      (action, concepts) => {\r\n        const {name, url} = selectPayload<huirthServerTriggerCloneGitRepositoryStrategyPayload>(action);\r\n        const fileSystemState = selectState<FileSystemState>(concepts, fileSystemName);\r\n        if (fileSystemState) {\r\n          const strategy = huirthServerCloneGitRepositoryToDirectoryStrategy(fileSystemState.root, url, name);\r\n          return strategyBegin(strategy);\r\n        } else {\r\n          return action;\r\n        }\r\n      }, concepts$ as Subject<Concepts>, semaphore as number, 50\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that will trigger the delete data sets strategy based on passed payload.":{"type":"project","content":"import {\r\n  UnifiedSubject,\r\n  createMethodDebounceWithConcepts,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  selectState,\r\n  selectUnifiedState,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { FileSystemState, fileSystemName } from '../../fileSystem/fileSystem.concept';\r\nimport { huirthServerDeleteDataSetsStrategy } from '../strategies/deleteDataSets.strategy';\r\nimport { huirthState } from '../../huirth/huirth.concept';\r\n\r\nexport type huirthServerTriggerDeleteDataSetsStrategyPayload = {\r\n  names: string[]\r\n}\r\n\r\nexport const [\r\n  huirthServerTriggerDeleteDataSetsStrategy,\r\n  huirthServerTriggerDeleteDataSetsStrategyType,\r\n  huirthServerTriggerDeleteDataSetsStrategyQuality\r\n] = createQualitySetWithPayload<huirthServerTriggerDeleteDataSetsStrategyPayload>({\r\n  type: 'huirthServer trigger delete data sets strategy',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$, semaphore) =>\r\n    createMethodDebounceWithConcepts(\r\n      (action, concepts) => {\r\n        const {names} = selectPayload<huirthServerTriggerDeleteDataSetsStrategyPayload>(action);\r\n        const fileSystemState = selectState<FileSystemState>(concepts, fileSystemName);\r\n        const state = selectUnifiedState<huirthState>(concepts, semaphore as number);\r\n        if (fileSystemState && state) {\r\n          const {trainingData} = state;\r\n          const strategy = huirthServerDeleteDataSetsStrategy(fileSystemState.root, trainingData, names);\r\n          return strategyBegin(strategy);\r\n        } else {\r\n          return action;\r\n        }\r\n      }, concepts$ as UnifiedSubject, semaphore as number, 50\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, create a quality that will trigger the git pull repository strategy":{"type":"project","content":"import {\r\n  UnifiedSubject,\r\n  createMethodDebounceWithConcepts,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  selectState,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { FileSystemState, fileSystemName } from '../../fileSystem/fileSystem.concept';\r\nimport { huirthServerGitPullRepositoryStrategy } from '../strategies/gitPullRepository.strategy';\r\n\r\nexport type huirthServerTriggerGitPullRepositoryStrategyPayload = {\r\n  name: string\r\n}\r\n\r\nexport const [\r\n  huirthServerTriggerGitPullRepositoryStrategy,\r\n  huirthServerTriggerGitPullRepositoryStrategyType,\r\n  huirthServerTriggerGitPullRepositoryStrategyQuality\r\n] = createQualitySetWithPayload<huirthServerTriggerGitPullRepositoryStrategyPayload>({\r\n  type: 'huirthServer trigger git pull repository strategy',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$, semaphore) =>\r\n    createMethodDebounceWithConcepts(\r\n      (action, concepts) => {\r\n        const {name} = selectPayload<huirthServerTriggerGitPullRepositoryStrategyPayload>(action);\r\n        const fileSystemState = selectState<FileSystemState>(concepts, fileSystemName);\r\n        if (fileSystemState) {\r\n          const strategy = huirthServerGitPullRepositoryStrategy(fileSystemState.root, name);\r\n          return strategyBegin(strategy);\r\n        } else {\r\n          return action;\r\n        }\r\n      }, concepts$ as UnifiedSubject, semaphore as number, 50\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that will trigger the parse repository ActionStrategy set by name supplied by the incoming payload.":{"type":"project","content":"import {\r\n  UnifiedSubject,\r\n  createMethodDebounceWithConcepts,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  selectState,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { FileSystemState, fileSystemName } from '../../fileSystem/fileSystem.concept';\r\nimport { huirthServerParseRepositoryStrategy } from '../strategies/parseRepositoryIntoDataSet.strategy';\r\n\r\nexport type huirthServerTriggerParseRepositoryStrategyPayload = {\r\n  name: string\r\n}\r\n\r\nexport const [\r\n  huirthServerTriggerParseRepositoryStrategy,\r\n  huirthServerTriggerParseRepositoryStrategyType,\r\n  huirthServerTriggerParseRepositoryStrategyQuality\r\n] = createQualitySetWithPayload<huirthServerTriggerParseRepositoryStrategyPayload>({\r\n  type: 'huirthServer trigger parse repository strategy',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$, semaphore) =>\r\n    createMethodDebounceWithConcepts(\r\n      (action, concepts) => {\r\n        const { name } = selectPayload<huirthServerTriggerParseRepositoryStrategyPayload>(action);\r\n        const fileSystemState = selectState<FileSystemState>(concepts, fileSystemName);\r\n        if (fileSystemState) {\r\n          const strategy = huirthServerParseRepositoryStrategy(fileSystemState.root, name);\r\n          return strategyBegin(strategy);\r\n        } else {\r\n          return action;\r\n        }\r\n      }, concepts$ as UnifiedSubject, semaphore as number, 50\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that will trigger the save data set selection ActionStrategy.":{"type":"project","content":"import {\r\n  UnifiedSubject,\r\n  createMethodDebounceWithConcepts,\r\n  createQualitySetWithPayload,\r\n  selectPayload,\r\n  selectState,\r\n  selectUnifiedState,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { FileSystemState, fileSystemName } from '../../fileSystem/fileSystem.concept';\r\nimport { huirthServerSaveDataSetSelectionStrategy } from '../strategies/saveDataSetSelection.strategy';\r\nimport { huirthServerState } from '../huirthServer.concept';\r\n\r\nexport type huirthServerTriggerSaveDataSetSelectionStrategyPayload = {\r\n  names: string[]\r\n}\r\n\r\nexport const [\r\n  huirthServerTriggerSaveDataSetSelectionStrategy,\r\n  huirthServerTriggerSaveDataSetSelectionStrategyType,\r\n  huirthServerTriggerSaveDataSetSelectionStrategyQuality\r\n] = createQualitySetWithPayload<huirthServerTriggerSaveDataSetSelectionStrategyPayload>({\r\n  type: 'huirthServer trigger save data set selection strategy',\r\n  reducer: (state: huirthServerState): huirthServerState => {\r\n    return {\r\n      ...state,\r\n      dataSetSelection: state.dataSetSelection.map(() => false)\r\n    };\r\n  },\r\n  methodCreator: (concepts$, semaphore) =>\r\n    createMethodDebounceWithConcepts(\r\n      (action, concepts) => {\r\n        const {names} = selectPayload<huirthServerTriggerSaveDataSetSelectionStrategyPayload>(action);\r\n        const state = selectUnifiedState<huirthServerState>(concepts, semaphore as number);\r\n        const fileSystemState = selectState<FileSystemState>(concepts, fileSystemName);\r\n        if (fileSystemState && state) {\r\n          const {trainingData} = state;\r\n          console.log('CHECK TRIGGER', fileSystemState.root, trainingData.length, names);\r\n          const strategy = huirthServerSaveDataSetSelectionStrategy(fileSystemState.root, trainingData, names);\r\n          return strategyBegin(strategy);\r\n        } else {\r\n          return action;\r\n        }\r\n      }, concepts$ as UnifiedSubject, semaphore as number, 50\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that will trigger the save DPO ActionStrategy.":{"type":"project","content":"import {\r\n  UnifiedSubject,\r\n  createMethodDebounceWithConcepts,\r\n  createQualitySet,\r\n  nullReducer,\r\n  selectState,\r\n  selectUnifiedState,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthServerState } from '../huirthServer.concept';\r\nimport { FileSystemState, fileSystemName } from '../../fileSystem/fileSystem.concept';\r\nimport { huirthServerSaveDPOStrategy } from '../strategies/saveDPO.strategy';\r\n\r\nexport const [\r\n  huirthServerTriggerSaveDPOStrategy,\r\n  huirthServerTriggerSaveDPOStrategyType,\r\n  huirthServerTriggerSaveDPOStrategyQuality\r\n] = createQualitySet({\r\n  type: 'huirthServer trigger save DPO strategy',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$, semaphore) =>\r\n    createMethodDebounceWithConcepts(\r\n      (action, concepts) => {\r\n        const state = selectUnifiedState<huirthServerState>(concepts, semaphore as number);\r\n        const fileSystemState = selectState<FileSystemState>(concepts, fileSystemName);\r\n        if (state && fileSystemState) {\r\n          const strategy = huirthServerSaveDPOStrategy(fileSystemState.root, state.activeDPO);\r\n          return strategyBegin(strategy);\r\n        } else {\r\n          return action;\r\n        }\r\n      }, concepts$ as UnifiedSubject, semaphore as number, 50\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a quality that will trigger the save training data ActionStrategy.":{"type":"project","content":"import {\r\n  Concepts,\r\n  UnifiedSubject,\r\n  createMethodDebounceWithConcepts,\r\n  createQualitySet,\r\n  nullReducer,\r\n  selectState,\r\n  selectUnifiedState,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthServerState } from '../huirthServer.concept';\r\nimport { FileSystemState, fileSystemName } from '../../fileSystem/fileSystem.concept';\r\nimport { huirthServerSaveTrainingDataStrategy } from '../strategies/saveTrainingData.strategy';\r\nimport { Subject } from 'rxjs';\r\n\r\nexport const [\r\n  huirthServerTriggerSaveTrainingDataStrategy,\r\n  huirthServerTriggerSaveTrainingDataStrategyType,\r\n  huirthServerTriggerSaveTrainingDataStrategyQuality\r\n] = createQualitySet({\r\n  type: 'huirthServer trigger save training data strategy',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createMethodDebounceWithConcepts(\r\n      (action, concepts) => {\r\n        const state = selectUnifiedState<huirthServerState>(concepts, semaphore as number);\r\n        const fileSystemState = selectState<FileSystemState>(concepts, fileSystemName);\r\n        if (state && fileSystemState) {\r\n          const strategy = huirthServerSaveTrainingDataStrategy(fileSystemState.root);\r\n          return strategyBegin(strategy);\r\n        } else {\r\n          return action;\r\n        }\r\n      }, concepts$ as UnifiedSubject, semaphore as number, 50\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth, generate a quality that will trigger the currently selected transformation strategy if it has been imported.":{"type":"project","content":"import {\r\n  axiumLog,\r\n  createActionNode,\r\n  createMethodDebounce,\r\n  createQualitySetWithPayload,\r\n  createStrategy,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { huirthVerboseAddingStrategySelect, huirthVerboseAdditionAndSubtractionStrategySelect, huirthVerboseSubtractionStrategySelect } from '../../huirth/huirth.model';\r\nimport { huirthServerGenerateVerboseAddingStrategy } from './generateVerboseAddingDataSet.quality';\r\nimport { huirthServerGenerateVerboseSubtractionStrategy } from './generateVerboseSubtractionDataSet.quality';\r\nimport { huirthServerGenerateVerboseAdditionAndSubtractionStrategy } from './generateVerboseAdditionAndSubtractionDataSet.quality';\r\n\r\nexport type huirthServerTriggerSelectTransformationStrategyPayload = {\r\n  selection: string\r\n}\r\n\r\nexport const [\r\n  huirthServerTriggerSelectTransformationStrategy,\r\n  huirthServerTriggerSelectTransformationStrategyType,\r\n  huirthServerTriggerSelectTransformationStrategyQuality\r\n] = createQualitySetWithPayload<huirthServerTriggerSelectTransformationStrategyPayload>({\r\n  type: 'huirthServer trigger passed transformation strategy from payload',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createMethodDebounce(\r\n      (act) => {\r\n        const { selection } = selectPayload<huirthServerTriggerSelectTransformationStrategyPayload>(act);\r\n        let action;\r\n        switch (selection) {\r\n        case huirthVerboseAddingStrategySelect: {\r\n          action = huirthServerGenerateVerboseAddingStrategy({agreement: 600000});\r\n          break;\r\n        }\r\n        case huirthVerboseSubtractionStrategySelect: {\r\n          action = huirthServerGenerateVerboseSubtractionStrategy({agreement: 600000});\r\n          break;\r\n        }\r\n        case huirthVerboseAdditionAndSubtractionStrategySelect: {\r\n          action = huirthServerGenerateVerboseAdditionAndSubtractionStrategy({agreement: 600000});\r\n          break;\r\n        }\r\n        default: {\r\n          break;\r\n        }\r\n        }\r\n        // action = axiumLog();\r\n        // action.payload = {\r\n        //   time: Date.now(),\r\n        //   agreement: 6000000\r\n        // };\r\n        console.log('This is the trigger action', action);\r\n        if (action) {\r\n          return strategyBegin(\r\n            createStrategy({\r\n              topic: 'Begin Transformation Strategy',\r\n              initialNode: createActionNode(action, {\r\n                agreement: 600000\r\n              })\r\n            })\r\n          );\r\n        }\r\n        return act;\r\n      }, 50\r\n    )\r\n});"},"For the graph programming framework Stratimux and a Concept huirth Server, generate the a helper to send the update a parsed project's data to the client and set the status to parsed.":{"type":"project","content":"import { userInterfaceServerSendActionToClient } from '../../../userInterfaceServer/strategies/sendActionToClient.helper';\r\nimport { NamedDataSet } from '../../../huirth/huirth.model';\r\nimport { huirthUpdateParsedProjectDataSet } from '../../../huirth/qualities/updateParsedProjectDataSet.quality';\r\n\r\nexport const huirthServerSendUpdateParsedProjectData = (dataSet: NamedDataSet) =>\r\n  (userInterfaceServerSendActionToClient(huirthUpdateParsedProjectDataSet({dataSet})));"},"For the graph programming framework Stratimux and a Concept huirth Server, generate the a helper to send the update project status to the client.":{"type":"project","content":"import { userInterfaceServerSendActionToClient } from '../../../userInterfaceServer/strategies/sendActionToClient.helper';\r\nimport { huirthUpdateProjectStatus } from '../../../huirth/qualities/updateProjectToStatus.quality';\r\nimport { ProjectStatus } from '../../../huirth/huirth.model';\r\n\r\nexport const huirthServerSendUpdateProjectToInstalled = (name: string) =>\r\n  (userInterfaceServerSendActionToClient(huirthUpdateProjectStatus({name, status: ProjectStatus.installed})));"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a ActionStrategy that will clone a git repository to a target directory":{"type":"project","content":"import path from 'path';\r\nimport { createActionNode, createStrategy } from 'stratimux';\r\nimport { huirthServerSendUpdateProjectToInstalled } from './client/huirthServerSendUpdateProjectToInstalled.helper';\r\nimport { fileSystemRemoveTargetDirectory } from '../../fileSystem/qualities/removeTargetDirectory.quality';\r\nimport { huirthServerGitCloneRepoToDirectory } from '../qualities/gitCloneRepoToDirectory.quality';\r\nimport { webSocketServerAppendToActionQue } from '../../webSocketServer/qualities/appendActionQue.quality';\r\nimport { huirthUpdateProjectStatus } from '../../huirth/qualities/updateProjectToStatus.quality';\r\nimport { ProjectStatus } from '../../huirth/huirth.model';\r\n\r\nexport const huirthServerCloneGitRepositoryToDirectoryTopic = 'huirthServer clone git repository to directory';\r\nexport const huirthServerCloneGitRepositoryToDirectoryStrategy = (root: string, url: string, name:string) => {\r\n  const dataPath = path.join(root + '/data/repositories/' + name);\r\n  // Step 3 Update status to installed by name as payload\r\n  console.log('CLONING ', url, name);\r\n  const stepUpdateProjectToUninstalled = createActionNode(webSocketServerAppendToActionQue({ actionQue: [\r\n    huirthUpdateProjectStatus({\r\n      name,\r\n      status: ProjectStatus.notInstalled\r\n    })\r\n  ]}));\r\n  const stepUpdateProjectToInstalled = createActionNode(huirthServerSendUpdateProjectToInstalled(name));\r\n  // Step 2 Git clone into that directory by name\r\n  const stepCloneRepo = createActionNode(huirthServerGitCloneRepoToDirectory({\r\n    url,\r\n    path: dataPath\r\n  }), {\r\n    successNode: stepUpdateProjectToInstalled,\r\n    // TODO: If failed we can use open to load a window with the git install webpage\r\n    failureNode: stepUpdateProjectToUninstalled,\r\n    agreement: 600000\r\n  });\r\n  // Step 1 Remove directory if exists based on name\r\n  const stepRemoveDirectory = createActionNode(fileSystemRemoveTargetDirectory({path: dataPath}), {\r\n    successNode: stepCloneRepo,\r\n    agreement: 60000\r\n  });\r\n  return createStrategy({\r\n    topic: huirthServerCloneGitRepositoryToDirectoryTopic,\r\n    initialNode: stepRemoveDirectory,\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a ActionStrategy that will delete data sets from the file system.":{"type":"project","content":"import { axiumLog, axiumStitch, axium_createStitchNode, createActionNode, createStrategy } from 'stratimux';\r\nimport path from 'path';\r\nimport { fileSystemRemoveTargetDirectory } from '../../fileSystem/qualities/removeTargetDirectory.quality';\r\nimport { huirthServerSendUpdateProjectToInstalled } from './client/huirthServerSendUpdateProjectToInstalled.helper';\r\nimport { DataSetTypes, TrainingData } from '../../huirth/huirth.model';\r\n\r\nconst huirthServerDeleteDataSetsStrategyTopic = 'huirthServer delete data sets from file system';\r\nexport const huirthServerDeleteDataSetsStrategy = (root: string, trainingData: TrainingData, names: string[]) => {\r\n  // If repositories doesn't exist\r\n  // stepFour does folder repositories exists?\r\n  let first;\r\n  let previous;\r\n  for (const name of names) {\r\n    const dataSetDirectory = path.join(root + '/data/sets/' + name);\r\n    const isProject = (() => {\r\n      for (const data of trainingData) {\r\n        if (data.name === name) {\r\n          return data.type === DataSetTypes.project;\r\n        }\r\n      }\r\n      return false;\r\n    })();\r\n    const action = isProject ? huirthServerSendUpdateProjectToInstalled(name) : axiumStitch();\r\n    if (first === undefined) {\r\n      const updateStatus = createActionNode(action);\r\n      first = createActionNode(fileSystemRemoveTargetDirectory({path: dataSetDirectory}), {\r\n        successNode: updateStatus,\r\n      });\r\n      previous = updateStatus;\r\n    } else if (previous) {\r\n      const updateStatus = createActionNode(action);\r\n      const next = createActionNode(fileSystemRemoveTargetDirectory({path: dataSetDirectory}), {\r\n        successNode: updateStatus,\r\n      });\r\n      previous.successNode = next;\r\n      previous = updateStatus;\r\n    }\r\n  }\r\n  return createStrategy({\r\n    topic: huirthServerDeleteDataSetsStrategyTopic,\r\n    initialNode: first ? first : createActionNode(axiumLog(), { successNode: null, failureNode: null}),\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a ActionStrategy that will git pull a targeted repository and inform the client if the repository was updated.":{"type":"project","content":"import path from 'path';\r\nimport { createActionNode, createStrategy } from 'stratimux';\r\nimport { huirthServerGitPullRepository } from '../qualities/gitPullRepository.quality';\r\nimport { ProjectStatus } from '../../huirth/huirth.model';\r\nimport { webSocketServerAppendToActionQue } from '../../webSocketServer/qualities/appendActionQue.quality';\r\nimport { huirthUpdateProjectStatus } from '../../huirth/qualities/updateProjectToStatus.quality';\r\n\r\nexport const huirthServerGitPullRepositoryTopic = 'huirthServer git pull target repository';\r\nexport const huirthServerGitPullRepositoryStrategy = (root: string, name:string) => {\r\n  const dataPath = path.join(root + '/data/repositories/' + name);\r\n  const stepUpdateProjectStatusToPulled = createActionNode(webSocketServerAppendToActionQue({\r\n    actionQue: [\r\n      huirthUpdateProjectStatus({\r\n        name,\r\n        status: ProjectStatus.pulled\r\n      })\r\n    ]\r\n  }));\r\n  const stepGitPull = createActionNode(huirthServerGitPullRepository({\r\n    path: dataPath\r\n  }), {\r\n    successNode: stepUpdateProjectStatusToPulled,\r\n    agreement: 60000\r\n  });\r\n  return createStrategy({\r\n    topic: huirthServerGitPullRepositoryTopic,\r\n    initialNode: stepGitPull,\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a ActionStrategy that will set up the data directory as needed, otherwise will record its contents to the state.":{"type":"project","content":"import { createActionNode, createStrategy } from 'stratimux';\r\nimport path from 'path';\r\nimport { fileSystemGetDirectoriesAndFiles } from '../../fileSystem/qualities/getDirectoriesAndFiles.quality';\r\nimport { huirthServerReadFromDataTrainingDataFromDirectories } from '../qualities/readFromDataTrainingDataFromDirectory.quality';\r\nimport { huirthServerSetDPOFromData } from '../qualities/setDPOFromData.quality';\r\nimport { huirthServerIsDataDirectorySetUp } from '../qualities/isDataDirectorySetUp.quality';\r\nimport { fileSystemCreateTargetDirectory } from '../../fileSystem/qualities/createTargetDirectory.quality';\r\nimport { dataDirectories } from '../huirthServer.model';\r\nimport { huirthServerSetRepositoriesFromData } from '../qualities/setRepositoriesFromData.quality';\r\nimport { huirthServerSetTrainingDataFromData } from '../qualities/setTrainingDataFromData.quality';\r\nimport { huirthSetTrainingDataInitialized } from '../../huirth/qualities/setTrainingDataInitialized.quality';\r\n\r\nconst huirthServerInitializationStrategyTopic = 'huirth Server Initialization Strategy';\r\nexport const huirthServerInitializationStrategy = (root: string) => {\r\n  const dataDirectory = path.join(root + '/data/');\r\n  const dataSetsDirectory = path.join(root + '/data/sets/');\r\n  // const DPODirectory = path.join(root + '/data/huirth');\r\n  const gitRepoDirectory = path.join(root + '/data/' + dataDirectories.gitRepo + '/');\r\n  const gitSetsDirectory = path.join(root + '/data/' + dataDirectories.sets + '/');\r\n  // If repositories doesn't exist\r\n  // stepFour does folder repositories exists?\r\n  const stepSetTrainingDataInitialized = createActionNode(huirthSetTrainingDataInitialized());\r\n  const stepSetTrainingDataFromData = createActionNode(huirthServerSetTrainingDataFromData(), {\r\n    successNode: stepSetTrainingDataInitialized\r\n  });\r\n  const stepReadTrainingDataFromData = createActionNode(huirthServerReadFromDataTrainingDataFromDirectories(), {\r\n    successNode: stepSetTrainingDataFromData,\r\n  });\r\n  const stepVerifyDataSets = createActionNode(fileSystemGetDirectoriesAndFiles({path: dataSetsDirectory}), {\r\n    successNode: stepReadTrainingDataFromData,\r\n  });\r\n  // const stepSetDPO_data = createActionNode(huirthServerSetDPOFromData(), {\r\n  //   successNode: stepVerifyDataSets,\r\n  // });\r\n  // const stepReadDPOFromData = createActionNode(huirthServerReadFromDataTrainingDataFromDirectories(), {\r\n  //   successNode: stepSetDPO_data,\r\n  // });\r\n  // const stepVerifyDPOData = createActionNode(fileSystemGetDirectoriesAndFiles({path: DPODirectory}), {\r\n  //   successNode: stepReadDPOFromData,\r\n  // });\r\n  const stepSetRepositoriesFromData = createActionNode(huirthServerSetRepositoriesFromData(), {\r\n    // No need to worry about setting status beyond installed here. In the next steps we will verify all currently installed data sources.\r\n    successNode: stepVerifyDataSets,\r\n  });\r\n  const stepReadDataRepoDirectory = createActionNode(fileSystemGetDirectoriesAndFiles({path: gitRepoDirectory}), {\r\n    successNode: stepSetRepositoriesFromData,\r\n  });\r\n  const stepCreateSetsDirectory = createActionNode(fileSystemCreateTargetDirectory({path: gitSetsDirectory}), {\r\n    successNode: stepVerifyDataSets,\r\n    agreement: 20000\r\n  });\r\n  const stepCreateRepoDirectory = createActionNode(fileSystemCreateTargetDirectory({path: gitRepoDirectory}), {\r\n    successNode: stepCreateSetsDirectory,\r\n    agreement: 20000\r\n  });\r\n  const stepIsTheDataDirectorySetUp = createActionNode(huirthServerIsDataDirectorySetUp(), {\r\n    successNode: stepReadDataRepoDirectory,\r\n    failureNode: stepCreateRepoDirectory\r\n  });\r\n  const stepReadDataDirectoryAgain = createActionNode(fileSystemGetDirectoriesAndFiles({path: dataDirectory}), {\r\n    successNode: stepIsTheDataDirectorySetUp,\r\n  });\r\n  const stepFailedFindingDataDirector = createActionNode(fileSystemCreateTargetDirectory({path: dataDirectory}), {\r\n    successNode: stepReadDataDirectoryAgain\r\n  });\r\n  const stepReadDataDirectory = createActionNode(fileSystemGetDirectoriesAndFiles({path: dataDirectory}), {\r\n    successNode: stepIsTheDataDirectorySetUp,\r\n    failureNode: stepFailedFindingDataDirector\r\n  });\r\n  return createStrategy({\r\n    topic: huirthServerInitializationStrategyTopic,\r\n    initialNode: stepReadDataDirectory,\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a strategy that will read an installed repository in the data directory and parse it into a data set to be loaded into state.":{"type":"project","content":"import { createActionNode, createStrategy } from 'stratimux';\r\nimport path from 'path';\r\nimport { fileSystemReadDirectory } from '../../fileSystem/qualities/readDir.quality';\r\nimport { fileSystemFilterFilesAndDirectories } from '../../fileSystem/qualities/filterFilesAndDirectories.quality';\r\nimport { huirthServerDetermineReadParseAppendStrategy } from '../qualities/determineReadParseAppendStrategy.quality';\r\nimport { DataSetTypes } from '../../huirth/huirth.model';\r\n\r\nexport const huirthServerParseRepositoryTopic = 'huirthServer read Repository, then parse the contents into a DataSet';\r\nexport const huirthServerParseRepositoryStrategy = (root: string, name:string) => {\r\n  const dataPath = path.join(root + '/data/repositories/' + name);\r\n  // Generate parse files and add them all to an array to be added to state at the end.\r\n  const stepDetermineReadAndParseStrategy = createActionNode(huirthServerDetermineReadParseAppendStrategy({\r\n    name,\r\n    type: DataSetTypes.project\r\n  }));\r\n  // Step 1 Remove directory if exists based on name\r\n  const stepFilter = createActionNode(fileSystemFilterFilesAndDirectories({\r\n    isTokens: ['.ts'],\r\n    notTokens: [path.join('/context/')]\r\n  }), {\r\n    successNode: stepDetermineReadAndParseStrategy,\r\n  });\r\n  const stepReadDirectory = createActionNode(fileSystemReadDirectory({target: dataPath}), {\r\n    // successNode: stepCreateDirectory,\r\n    successNode: stepFilter,\r\n    agreement: 20000\r\n  });\r\n  return createStrategy({\r\n    topic: huirthServerParseRepositoryTopic,\r\n    initialNode: stepReadDirectory,\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a strategy that will save a selection of data sets by the passed parameter of names, to the file system, and to their own directory.":{"type":"project","content":"import { axiumLog, createActionNode, createStrategy } from 'stratimux';\r\nimport { TrainingData  } from '../../huirth/huirth.model';\r\nimport path from 'path';\r\nimport { fileSystemRemoveTargetDirectory } from '../../fileSystem/qualities/removeTargetDirectory.quality';\r\nimport { fileSystemCreateTargetDirectory } from '../../fileSystem/qualities/createTargetDirectory.quality';\r\nimport { fileSystemCreateFileWithContentsIndex } from '../../fileSystem/qualities/createFileWithContents.quality';\r\nimport { convertNamedDataSetToSaveFormat } from '../huirthServer.model';\r\nimport { huirthServerSendProjectStatusToSaved } from './client/huirthServerSendUpdateProjectStatusToSaved.helper';\r\n\r\nexport const huirthServerSaveDataSetSelectionStrategyTopic = 'Save a selection of data sets to their own directories';\r\nexport const huirthServerSaveDataSetSelectionStrategy = (root: string, trainingData: TrainingData, names: string[]) => {\r\n  const dataPaths = names.map(name => path.join(root + '/data/sets/' + name));\r\n  let first;\r\n  let previous;\r\n  for (const [i, p] of dataPaths.entries()) {\r\n    const name = names[i];\r\n    const dataSet = (() => {\r\n      let possible;\r\n      for (const data of trainingData) {\r\n        if (data.name === name) {\r\n          possible = data;\r\n          break;\r\n        }\r\n      }\r\n      return possible;\r\n    })();\r\n    if (dataSet) {\r\n      const saveFormat  = convertNamedDataSetToSaveFormat(dataSet);\r\n      const stepUpdateProjectStatusToSavedOnClient = createActionNode(huirthServerSendProjectStatusToSaved(dataSet.name));\r\n      const stepCreateFileWithContents = createActionNode(fileSystemCreateFileWithContentsIndex({\r\n        target: path.join(p + '/' + dataSet.name + '.json'),\r\n        content: JSON.stringify(saveFormat)\r\n      }), {\r\n        successNode: stepUpdateProjectStatusToSavedOnClient\r\n      });\r\n      const stepCreateDirectory = createActionNode(fileSystemCreateTargetDirectory({path: p}), {\r\n        successNode: stepCreateFileWithContents,\r\n        agreement: 20000\r\n      });\r\n      const stepRemoveDirectory = createActionNode(fileSystemRemoveTargetDirectory({path: p}), {\r\n        successNode: stepCreateDirectory,\r\n        agreement: 20000\r\n      });\r\n      if (first === undefined) {\r\n        first = stepRemoveDirectory;\r\n        previous = stepUpdateProjectStatusToSavedOnClient;\r\n      } else if (previous) {\r\n        previous.successNode = stepRemoveDirectory;\r\n        previous = stepUpdateProjectStatusToSavedOnClient;\r\n      }\r\n    }\r\n  }\r\n  if (first === undefined) {\r\n    first = createActionNode(axiumLog());\r\n    first.payload = {\r\n      message: 'No data sets provided to save selection strategy'\r\n    };\r\n  }\r\n  return createStrategy({\r\n    topic: huirthServerSaveDataSetSelectionStrategyTopic,\r\n    initialNode: first,\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a strategy that will save the current DPO data onto the file system.":{"type":"project","content":"import { createActionNode, createStrategy } from 'stratimux';\r\nimport { Active_DPO  } from '../../huirth/huirth.model';\r\nimport path from 'path';\r\nimport { fileSystemRemoveTargetDirectory } from '../../fileSystem/qualities/removeTargetDirectory.quality';\r\nimport { fileSystemCreateTargetDirectory } from '../../fileSystem/qualities/createTargetDirectory.quality';\r\nimport { fileSystemCreateFileWithContentsIndex } from '../../fileSystem/qualities/createFileWithContents.quality';\r\nimport { SavedFormat, convertDPOToSaveFormatDPO } from '../huirthServer.model';\r\n\r\nexport const huirthServerSaveDPOStrategyTopic = 'Save training data currently loaded in state';\r\nexport const huirthServerSaveDPOStrategy = (root: string, DPO: Active_DPO[]) => {\r\n  const saveFormat: SavedFormat = convertDPOToSaveFormatDPO(DPO);\r\n  const dataPath = path.join(root + '/data/huirth/');\r\n  const stepCreateFileWithContents = createActionNode(fileSystemCreateFileWithContentsIndex({\r\n    target: path.join(dataPath + 'dpo.json'),\r\n    content: JSON.stringify(saveFormat)\r\n  }), {\r\n    agreement: 20000\r\n  });\r\n  const stepCreateDirectory = createActionNode(fileSystemCreateTargetDirectory({path: dataPath}), {\r\n    successNode: stepCreateFileWithContents,\r\n    agreement: 20000\r\n  });\r\n  const stepRemoveDirectory = createActionNode(fileSystemRemoveTargetDirectory({path: dataPath}), {\r\n    successNode: stepCreateDirectory,\r\n    agreement: 20000\r\n  });\r\n  return createStrategy({\r\n    topic: huirthServerSaveDPOStrategyTopic,\r\n    initialNode: stepRemoveDirectory,\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth Server, generate a strategy that will save the currently loaded dataset into state.":{"type":"project","content":"import { createActionNode, createStrategy } from 'stratimux';\r\nimport { TrainingData  } from '../../huirth/huirth.model';\r\nimport path from 'path';\r\nimport { fileSystemRemoveTargetDirectory } from '../../fileSystem/qualities/removeTargetDirectory.quality';\r\nimport { fileSystemCreateTargetDirectory } from '../../fileSystem/qualities/createTargetDirectory.quality';\r\n\r\nexport const huirthServerSaveTrainingDataStrategyTopic = 'Save training data currently loaded in state';\r\nexport const huirthServerSaveTrainingDataStrategy = (root: string) => {\r\n  const dataPath = path.join(root + '/data/huirth/');\r\n  // Still need to create the rest of the steps here.\r\n  const stepCreateDirectory = createActionNode(fileSystemCreateTargetDirectory({path: dataPath}), {\r\n    agreement: 20000\r\n  });\r\n  const stepRemoveDirectory = createActionNode(fileSystemRemoveTargetDirectory({path: dataPath}), {\r\n    successNode: stepCreateDirectory,\r\n    agreement: 20000\r\n  });\r\n  return createStrategy({\r\n    topic: huirthServerSaveTrainingDataStrategyTopic,\r\n    initialNode: stepRemoveDirectory,\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate a strategy that in isolation will transform a count within itself and count out the changes to the number in its action list.":{"type":"project","content":"import { Action, ActionStrategy, axium_createGatherNode, createStrategy } from 'stratimux';\r\nimport { huirth_convertNumberToStringVerbose } from '../verboseNumber.model';\r\nimport { huirthServerInnerAddTo } from '../qualities/innerAddTo.quality';\r\n\r\nfunction getRandomRange(min: number, max: number) {\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\nexport const huirthServerVerboseAddingStrategyTopic = (length: number): string => 'Sum ' + huirth_convertNumberToStringVerbose(length) + ' random numbers together and then output the final sum';\r\nexport const huirthServerVerboseAddingStrategy = (length: number): ActionStrategy => {\r\n  const actions: Action[] = [];\r\n  for (let i = 0; i < length; i++) {\r\n    const addTo = Math.round(getRandomRange(1, 100));\r\n    actions.push(huirthServerInnerAddTo({addTo}));\r\n  }\r\n  return createStrategy({\r\n    topic: huirthServerVerboseAddingStrategyTopic(length),\r\n    initialNode: axium_createGatherNode({actions}),\r\n    data: {\r\n      sum: 0\r\n    }\r\n  });\r\n};"},"For the graph programming framework Stratimux and a Concept huirth, generate a strategy that in isolation will start with a sum of zero then subtract a series of random numbers from that sum.":{"type":"project","content":"import { Action, ActionStrategy, axium_createGatherNode, createStrategy } from 'stratimux';\r\nimport { huirth_convertNumberToStringVerbose } from '../verboseNumber.model';\r\nimport { huirthServerInnerSubtractFrom } from '../qualities/innerSubtractFrom.quality';\r\n\r\nfunction getRandomRange(min: number, max: number) {\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\nexport const huirthServerVerboseSubtractionStrategyTopic = (length: number): string => 'Starting from zero subtract ' + huirth_convertNumberToStringVerbose(length) + ' random numbers from a total sum, and then output the final sum';\r\nexport const huirthServerVerboseSubtractionStrategy = (length: number): ActionStrategy => {\r\n  const actions: Action[] = [];\r\n  for (let i = 0; i < length; i++) {\r\n    const subtractFrom = Math.round(getRandomRange(1, 100));\r\n    actions.push(huirthServerInnerSubtractFrom({subtractFrom}));\r\n  }\r\n  return createStrategy({\r\n    topic: huirthServerVerboseSubtractionStrategyTopic(length),\r\n    initialNode: axium_createGatherNode({actions}),\r\n    data: {\r\n      sum: 0\r\n    }\r\n  });\r\n};"},"For the graph programming framework Stratimux generate a Server Concept, that accepts an initial port.":{"type":"project","content":"import { serverPrinciple } from './server.principle';\r\nimport { createConcept } from 'stratimux';\r\nimport express, {Application} from 'express';\r\n\r\nexport type ServerState = {\r\n    port: number;\r\n    server: Application\r\n}\r\n\r\nexport const serverName = 'server';\r\n\r\nconst initialServerState = (port?: number): ServerState => {\r\n  return {\r\n    port: port ? port : 7637,\r\n    server: express()\r\n  };\r\n};\r\n\r\nexport const createServerConcept = (port?: number) => {\r\n  return createConcept(\r\n    serverName,\r\n    initialServerState(port),\r\n    [],\r\n    [serverPrinciple]\r\n  );\r\n};"},"For the graph programming framework Stratimux and a Server Concept, generate a principle that will listen on the port passed in its initial state.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport { ServerState } from './server.concept';\r\nimport { Action, Concepts, PrincipleFunction, UnifiedSubject, selectUnifiedState } from 'stratimux';\r\n\r\nexport const serverPrinciple: PrincipleFunction = (_: Subscriber<Action>, concepts: Concepts, __: UnifiedSubject, semaphore: number) => {\r\n  const HOST = '0.0.0.0';\r\n  const initialServerState = selectUnifiedState(concepts, semaphore) as ServerState;\r\n  const server = initialServerState.server;\r\n  server.listen(initialServerState.port, HOST, () => {\r\n    console.log(`Running on http://${HOST}:${initialServerState.port}}`);\r\n  });\r\n};"},"For the graph programming framework Stratimux and the User Interface Concept, generate a quality that will add a page and its compositions to the state, while update the cached selectors to enable atomic operations.":{"type":"project","content":"import {\r\n  Action,\r\n  KeyedSelector,\r\n  createMethod,\r\n  createQualitySet,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { BoundSelectors, Composition, userInterface_selectPage } from '../../../model/userInterface';\r\nimport { UserInterfaceState } from '../userInterface.concept';\r\n\r\nexport const [\r\n  userInterfaceAddComposedPageToState,\r\n  userInterfaceAddComposedPageToStateType,\r\n  userInterfaceAddComposedPageToStateQuality\r\n] = createQualitySet({\r\n  type: 'User Interface add composed Page to State',\r\n  reducer: (state: UserInterfaceState, action: Action): UserInterfaceState => {\r\n    if (action.strategy) {\r\n      const boundSelectors: Record<string, BoundSelectors[]> = {};\r\n      const mapSelectors: Map<string, KeyedSelector> = new Map();\r\n      const page = userInterface_selectPage(action.strategy);\r\n      console.log('CHECK PAGE COUNT', state.pages.length);\r\n      const newComponents = [...state.components];\r\n      const cachedComponentSelectors: BoundSelectors[] = [];\r\n      const isUnique: Record<string, boolean> = {};\r\n      const newPages = state.pages.filter(_page => {\r\n        return page.title !== _page.title;\r\n      });\r\n      newPages.push(page);\r\n      for (const [i, p] of newPages.entries()) {\r\n        const cachedSelectors: BoundSelectors[] = [];\r\n        for (const [compIndex, comp] of p.compositions.entries()) {\r\n          if (!comp.universal) {\r\n            for (const bound of comp.boundSelectors) {\r\n              bound.semaphore = [i, compIndex];\r\n              // console.log('SET', bound.action, bound.semaphore);\r\n              comp.boundSelectors.forEach(b => {\r\n                b.selectors.forEach(s => {\r\n                  if (boundSelectors[s.keys]) {\r\n                    boundSelectors[s.keys].push(b);\r\n                  } else {\r\n                    mapSelectors.set(s.keys, s);\r\n                    boundSelectors[s.keys] = [b];\r\n                  }\r\n                });\r\n              });\r\n              cachedSelectors.push(bound);\r\n            }\r\n          } else if (comp.universal) {\r\n            // let unique = true;\r\n            let possibleSemaphore = -1;\r\n            for (const [index, cmp] of state.components.entries()) {\r\n              // eslint-disable-next-line max-depth\r\n              // eslint-disable-next-line max-depth\r\n              if (cmp.action.type === comp.action.type) {\r\n                possibleSemaphore = index;\r\n                break;\r\n              }\r\n            }\r\n            // console.log('CHECK UNIQUE', comp.action.type, unique, isUnique[comp.action.type]);\r\n            if (isUnique[comp.action.type] === undefined) {\r\n              isUnique[comp.action.type] = false;\r\n              const setIndex = newComponents.length;\r\n              comp.componentSemaphore = setIndex;\r\n              comp.boundSelectors.forEach((bound) => {\r\n                // -1 to throw error if this is ever improperly handled\r\n                bound.semaphore = [-1, setIndex];\r\n                cachedComponentSelectors.push(bound);\r\n                bound.selectors.forEach(s => {\r\n                  if (boundSelectors[s.keys]) {\r\n                    boundSelectors[s.keys].push(bound);\r\n                  } else {\r\n                    boundSelectors[s.keys] = [bound];\r\n                  }\r\n\r\n                  mapSelectors.set(s.keys, s);\r\n                });\r\n              });\r\n              const composition: Composition = {...comp};\r\n              newComponents.push(composition);\r\n            } else if (possibleSemaphore !== -1) {\r\n              p.compositions[compIndex] = {\r\n                ...state.components[possibleSemaphore]\r\n              };\r\n              p.compositions[compIndex].boundSelectors.forEach(bound => {\r\n                cachedComponentSelectors.push(bound);\r\n              });\r\n            }\r\n          }\r\n        }\r\n        p.cachedSelectors = cachedSelectors;\r\n        p.cachedComponentSelectors = cachedComponentSelectors;\r\n      }\r\n      const selectors: KeyedSelector[] = [];\r\n      mapSelectors.forEach((keyed) => {\r\n        selectors.push(keyed);\r\n      });\r\n      return {\r\n        ...state,\r\n        pages: newPages,\r\n        components: newComponents,\r\n        pagesCached: true,\r\n        boundSelectors,\r\n        selectors\r\n      };\r\n    }\r\n    return {\r\n      ...state,\r\n    };\r\n  },\r\n  methodCreator: () => createMethod(action => {\r\n    if (action.strategy) {\r\n      const {strategy} = action;\r\n      return strategySuccess(strategy);\r\n    } else {\r\n      return action;\r\n    }\r\n  })\r\n});"},"For the graph programming framework Stratimux and the User Interface Concept, generate a quality that will add a page strategy to state, then dispatch that same strategy in the method.\r\nTo be later added back into state via the add composed page to state quality.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { PageStrategyCreators } from '../../../model/userInterface';\r\nimport { UserInterfaceState } from '../userInterface.concept';\r\n\r\nexport type UserInterfaceAddNewPagePayload = {\r\n  // name: string,\r\n  pageStrategy: PageStrategyCreators,\r\n}\r\n\r\nexport const [\r\n  userInterfaceAddNewPage,\r\n  userInterfaceAddNewPageType,\r\n  userInterfaceAddNewPageQuality\r\n] = createQualitySetWithPayload<UserInterfaceAddNewPagePayload>({\r\n  type: 'User Interface Add New Page Strategy to state',\r\n  reducer: (state: UserInterfaceState, action: Action): UserInterfaceState => {\r\n    const payload = selectPayload<UserInterfaceAddNewPagePayload>(action);\r\n    const {pageStrategies} = state;\r\n    pageStrategies.push(payload.pageStrategy);\r\n    return {\r\n      ...state,\r\n      pageStrategies\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and the User Interface Concept, generate a pure quality that will end a strategy without effecting the Axium's dialog system, simply by not including a method and using the default reducer.":{"type":"project","content":"import {\r\n  createQualitySet,\r\n  nullReducer,\r\n} from 'stratimux';\r\n\r\nexport const [\r\n  userInterfaceEnd,\r\n  userInterfaceEndType,\r\n  userInterfaceEndQuality\r\n] = createQualitySet({\r\n  type: 'User Interface End Strategy',\r\n  reducer: nullReducer,\r\n});"},"For the graph programming framework Stratimux and the User Interface Concept, generate a quality that will backtrack to the previous node and call the next successive action.":{"type":"project","content":"import {\r\n  createMethod,\r\n  createQualitySet,\r\n  nullReducer,\r\n  strategy,\r\n} from 'stratimux';\r\n\r\nexport const [\r\n  userInterfaceNext,\r\n  userInterfaceNextType,\r\n  userInterfaceNextQuality\r\n] = createQualitySet({\r\n  type: 'User Interface Next Strategy',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createMethod(action => {\r\n    const st = action.strategy;\r\n    if (st) {\r\n      const prev = strategy.backTrack(st);\r\n      if (prev.strategy) {\r\n        return strategy.success(prev.strategy);\r\n      } else {\r\n        return prev;\r\n      }\r\n    } else {\r\n      return action;\r\n    }\r\n  })\r\n});"},"For the graph programming framework Stratimux and the User Interface Concept, generate a quality that will refresh the current cached bound selectors and the associated semaphores to enable safe atomic operations.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySet,\r\n  defaultMethodCreator,\r\n} from 'stratimux';\r\nimport { BoundSelectors } from '../../../model/userInterface';\r\nimport { UserInterfaceState } from '../userInterface.concept';\r\n\r\nexport const [\r\n  userInterfaceRefreshCachedSelectors,\r\n  userInterfaceRefreshCachedSelectorsType,\r\n  userInterfaceRefreshCachedSelectorsQuality\r\n] = createQualitySet({\r\n  type: 'User Interface refresh cached selectors',\r\n  reducer: (state: UserInterfaceState, action: Action): UserInterfaceState => {\r\n    if (action.strategy) {\r\n      const newPages = {...state.pages};\r\n      for (const [i, p] of newPages.entries()) {\r\n        const cachedSelectors: BoundSelectors[] = [];\r\n        const cachedComponentSelectors: BoundSelectors[] = [];\r\n        for (const [compIndex, comp] of p.compositions.entries()) {\r\n          for (const bound of comp.boundSelectors) {\r\n            if (!comp.universal) {\r\n              cachedSelectors.push({\r\n                ...bound,\r\n                semaphore: [i, compIndex]\r\n              });\r\n            } else {\r\n              state.components.forEach(c => {\r\n                if (comp.action.type === c.action.type) {\r\n                  comp.boundSelectors.forEach(b => {\r\n                    cachedComponentSelectors.push(b);\r\n                  });\r\n                }\r\n              });\r\n            }\r\n          }\r\n        }\r\n        p.cachedSelectors = cachedSelectors;\r\n        p.cachedComponentSelectors = cachedComponentSelectors;\r\n      }\r\n      return {\r\n        ...state,\r\n        pages: newPages,\r\n      };\r\n    }\r\n    return {\r\n      ...state,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and the User Interface Concept, generate a quality that will remove a page and page strategy creator from state based on the provided name in the payload.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { BoundSelectors, Page, PageStrategyCreators } from '../../../model/userInterface';\r\nimport { UserInterfaceState } from '../userInterface.concept';\r\n\r\nexport type UserInterfaceRemovePagePayload = {\r\n  name: string,\r\n}\r\n\r\nexport const [\r\n  userInterfaceRemovePage,\r\n  userInterfaceRemovePageType,\r\n  userInterfaceRemovePageQuality\r\n] = createQualitySetWithPayload<UserInterfaceRemovePagePayload>({\r\n  type: 'User Interface Remove Page',\r\n  reducer: (state: UserInterfaceState, action: Action): UserInterfaceState => {\r\n    const payload = selectPayload<UserInterfaceRemovePagePayload>(action);\r\n    const {pageStrategies, pages} = state;\r\n    const newPageStrategies: PageStrategyCreators[] = [];\r\n    const newPages: Page[] = [];\r\n    for (const [i, page] of pages.entries()) {\r\n      if (page.title !== payload.name) {\r\n        const cachedSelectors: BoundSelectors[] = [];\r\n        for (const [compIndex, comp] of page.compositions.entries()) {\r\n          if (comp.boundSelectors) {\r\n            for (const bound of comp.boundSelectors) {\r\n              cachedSelectors.push({\r\n                ...bound,\r\n                semaphore: [i, compIndex]\r\n              });\r\n            }\r\n          }\r\n        }\r\n        page.cachedSelectors = cachedSelectors;\r\n        newPageStrategies.push(pageStrategies[i]);\r\n        newPages.push(page);\r\n      }\r\n    }\r\n    return {\r\n      ...state,\r\n      pages: newPages,\r\n      pageStrategies: newPageStrategies\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and the User Interface Concept, generate a quality that will update a specific page and composition based on the incoming payload. And set by the data field supplied by the strategy.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { BoundSelectors, userInterface_selectPage } from '../../../model/userInterface';\r\nimport { UserInterfaceState } from '../userInterface.concept';\r\n\r\nexport type UserInterfaceUpdateAtomicPageCompositionPayload = {\r\n  bound: BoundSelectors\r\n}\r\n\r\nexport const [\r\n  userInterfaceUpdateAtomicPageComposition,\r\n  userInterfaceUpdateAtomicPageCompositionType,\r\n  userInterfaceUpdateAtomicPageCompositionQuality\r\n] = createQualitySetWithPayload<UserInterfaceUpdateAtomicPageCompositionPayload>({\r\n  type: 'User Interface atomic update composition to State',\r\n  reducer: (state: UserInterfaceState, action: Action): UserInterfaceState => {\r\n    const payload = selectPayload<UserInterfaceUpdateAtomicPageCompositionPayload>(action);\r\n    if (action.strategy) {\r\n      const pageData = userInterface_selectPage(action.strategy);\r\n      const composition = pageData.compositions.filter(comp => comp.id === payload.bound.id)[0];\r\n      const newPages = [...state.pages];\r\n      const target = newPages[payload.bound.semaphore[0]];\r\n      if (target) {\r\n        target.compositions[payload.bound.semaphore[1]] = composition;\r\n      }\r\n      return {\r\n        ...state,\r\n        pages: newPages,\r\n      };\r\n    }\r\n    return {\r\n      ...state,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and the User Interface Concept, generate a quality that will update a specified universal component based on the incoming bound selector.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { BoundSelectors, userInterface_selectPage } from '../../../model/userInterface';\r\nimport { UserInterfaceState } from '../userInterface.concept';\r\n\r\nexport type UserInterfaceUpdateUniversalComponentPayload = {\r\n  bound: BoundSelectors\r\n}\r\n\r\nexport const [\r\n  userInterfaceUpdateUniversalComponent,\r\n  userInterfaceUpdateUniversalComponentType,\r\n  userInterfaceUpdateUniversalComponentQuality\r\n] = createQualitySetWithPayload<UserInterfaceUpdateUniversalComponentPayload>({\r\n  type: 'User Interface update universal component',\r\n  reducer: (state: UserInterfaceState, action: Action): UserInterfaceState => {\r\n    const payload = selectPayload<UserInterfaceUpdateUniversalComponentPayload>(action);\r\n    if (action.strategy) {\r\n      const pageData = userInterface_selectPage(action.strategy);\r\n      const composition = pageData.compositions.filter(comp => comp.id === payload.bound.id)[0];\r\n      const newComponents = [...state.components];\r\n      const newPages = [...state.pages];\r\n      composition.componentSemaphore = payload.bound.semaphore[1];\r\n      composition.boundSelectors.forEach(bound => { bound.semaphore = payload.bound.semaphore; });\r\n      newComponents[payload.bound.semaphore[1]] = composition;\r\n      newPages.forEach(page => page.compositions.forEach((comp, i) => {\r\n        if (comp.action.type === composition.action.type && comp.universal) {\r\n          page.compositions[i] = composition;\r\n        }\r\n      }));\r\n      return {\r\n        ...state,\r\n        components: newComponents,\r\n        pages: newPages\r\n      };\r\n    }\r\n    return {\r\n      ...state,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and the User Interface Concept, generate a ActionStrategy that will generate a page based on its loaded action strategy stitch components and assign such to the strategies data field.":{"type":"project","content":"import {\r\n  ActionNode,\r\n  ActionStrategy,\r\n  createActionNode,\r\n  createActionNodeFromStrategy,\r\n  createStrategy\r\n} from 'stratimux';\r\nimport { ActionComponentPayload, ActionStrategyComponentStitch, Page } from '../../../model/userInterface';\r\nimport { htmlBegin } from '../../html/qualities/htmlBegin.quality';\r\nimport { htmlHeadBegin } from '../../html/qualities/headBegin.quality';\r\nimport { htmlBodyBegin } from '../../html/qualities/bodyBegin.quality';\r\nimport { htmlBodyEnd } from '../../html/qualities/bodyEnd.quality';\r\nimport { htmlEnd } from '../../html/qualities/htmlEnd';\r\nimport { htmlHeadEnd } from '../../html/qualities/headEnd.quality';\r\n\r\nexport const userInterfaceCreatePageTopic = 'User Interface create Page Strategy';\r\n/**\r\n * Returns a Strategy with Data that must be handled by a final strategy\r\n *  This approach allows us to atomically edit each composition based on their keyedSelector on client and server.\r\n * @param title - Denotes the working composition page title\r\n * @param body - Is an array of StrategyStitches that create their own compositions that can be added to the body.\r\n * @param headerStitch - Any extra header compositions including style and script.\r\n * @param language - The language of your page, defaults to english.\r\n * @returns [ActionNode, ActionStrategy] ActionStrategy with data of type Composition\r\n */\r\nexport function userInterfaceCreatePageStrategy(\r\n  title: string,\r\n  pageData: Page,\r\n  body: ActionStrategyComponentStitch[],\r\n  headerStitch?: ActionStrategyComponentStitch,\r\n  language?: string\r\n): [ActionNode, ActionStrategy] {\r\n  const payload: ActionComponentPayload = {\r\n    pageTitle: title\r\n  };\r\n  const stepHtmlEnd = createActionNode(htmlEnd(payload), {\r\n    successNode: null,\r\n    failureNode: null\r\n  });\r\n\r\n  const stepBodyEnd = createActionNode(htmlBodyEnd(payload), {\r\n    successNode: stepHtmlEnd,\r\n    failureNode: null\r\n  });\r\n\r\n  const stepBodyBegin = createActionNode(htmlBodyBegin(payload), {\r\n    successNode: stepBodyEnd,\r\n    failureNode: null\r\n  });\r\n\r\n  let prevHead = stepBodyBegin;\r\n  for (let i = 0; i < body.length; i++) {\r\n    const [\r\n      stitchEnd,\r\n      stitchStrategy\r\n    ] = body[i](payload);\r\n    const stitchHead = createActionNodeFromStrategy(stitchStrategy);\r\n    prevHead.successNode = stitchHead;\r\n    // console.log('PREV HEAD', prevHead, i);\r\n    prevHead = stitchEnd;\r\n    // console.log('STITCH HEAD', stitchHead, i);\r\n  }\r\n  prevHead.successNode = stepBodyEnd;\r\n  // console.log('FINAL', prevHead);\r\n\r\n  const [\r\n    headEnd,\r\n    header\r\n  ] = createHeaderStrategy(payload, headerStitch);\r\n  const stepHeader = createActionNodeFromStrategy(header);\r\n\r\n  headEnd.successNode = stepBodyBegin;\r\n\r\n  const stepHtmlBegin = createActionNode(htmlBegin({language, pageTitle: title}), {\r\n    successNode: stepHeader,\r\n    failureNode: null,\r\n  });\r\n\r\n  return [\r\n    stepHtmlEnd,\r\n    createStrategy({\r\n      topic: title,\r\n      initialNode: stepHtmlBegin,\r\n      data: pageData\r\n    })\r\n  ];\r\n}\r\n\r\nconst createHeaderStrategy = (payload: ActionComponentPayload, stitch?: ActionStrategyComponentStitch): [ActionNode, ActionStrategy] => {\r\n  const stepHeadEnd = createActionNode(htmlHeadEnd(payload), {\r\n    successNode: null,\r\n    failureNode: null\r\n  });\r\n  const stepHeadBegin = createActionNode(htmlHeadBegin(payload), {\r\n    successNode: stepHeadEnd,\r\n    failureNode: null\r\n  });\r\n  if (stitch) {\r\n    const [\r\n      stitchEnd,\r\n      stitchStrategy\r\n    ] = stitch(payload);\r\n    stitchEnd.successNode = stepHeadEnd;\r\n    const stitched = createActionNodeFromStrategy(stitchStrategy);\r\n    stepHeadBegin.successNode = stitched;\r\n  }\r\n  return [\r\n    stepHeadEnd,\r\n    createStrategy({\r\n      topic: 'Header Strategy',\r\n      initialNode: stepHeadBegin,\r\n    })\r\n  ];\r\n};"},"For the graph programming framework Stratimux and the User Interface Concept, generate a strategy that will create a hello world page to be loaded onto the client.":{"type":"project","content":"import {\r\n  ActionStrategyParameters,\r\n  ActionStrategyStitch,\r\n  axium_createStitchNode,\r\n  createActionNode,\r\n  createStrategy\r\n} from 'stratimux';\r\nimport { htmlHelloWorld } from '../../html/qualities/helloWorld.quality';\r\nimport { helloWorldName } from '../../helloWorld/helloWorld.concept';\r\nimport { PageStrategyCreators, userInterface_createPage } from '../../../model/userInterface';\r\nimport { userInterfaceCreatePageStrategy } from './createPage.strategy';\r\n\r\nexport const helloWorldPageTopic = 'Hello World Page';\r\nexport const helloWorldPageStrategy: PageStrategyCreators = () => () => {\r\n  const stepStitch = axium_createStitchNode();\r\n  const stepOne = createActionNode(htmlHelloWorld({\r\n    pageTitle: helloWorldPageTopic\r\n  }), {\r\n    successNode: stepStitch,\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: helloWorldPageTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  const pageData =  userInterface_createPage({\r\n    title: 'helloWorld',\r\n    compositions: [],\r\n    cachedSelectors: [],\r\n    cachedComponentSelectors: [],\r\n    conceptAndProps: [\r\n      {\r\n        name: helloWorldName,\r\n      }\r\n    ]\r\n  });\r\n\r\n  const helloWorldBody: ActionStrategyStitch = () => [stepStitch, createStrategy(params)];\r\n  return userInterfaceCreatePageStrategy(helloWorldPageTopic, pageData, [helloWorldBody]);\r\n};"},"For the graph programming framework Stratimux and the User Interface Concept, generate an ActionStrategy that will recompose a page creation strategy to add its final composition to the state.":{"type":"project","content":"import { ActionNode, ActionStrategy, ActionStrategyStitch, axiumLog, createActionNode, createStrategy } from 'stratimux';\r\nimport { userInterfaceAddComposedPageToState } from '../qualities/addComposedPageToState.quality';\r\n\r\n/**\r\n * Has no topic of its own, uses incoming Page Strategy\r\n * @param stitch Page Strategy\r\n * @returns ActionStrategy\r\n */\r\nexport function userInterfacePageToStateStrategy(stitch: ActionStrategyStitch): ActionStrategy {\r\n  const stepAddToState = createActionNode(userInterfaceAddComposedPageToState());\r\n\r\n  const [\r\n    end,\r\n    strategy\r\n  ] = stitch();\r\n  // const log = createActionNode(axiumLog(), {\r\n  //   successNode: stepAddToState\r\n  // });\r\n  end.successNode = stepAddToState;\r\n\r\n  return createStrategy({\r\n    topic: strategy.topic,\r\n    initialNode: strategy.currentNode,\r\n    data: strategy.data\r\n  });\r\n}\r\n\r\nexport function userInterfacePageToStateStrategyStitch(stitch: ActionStrategyStitch): [ActionNode, ActionStrategy] {\r\n  const stepAddToState = createActionNode(userInterfaceAddComposedPageToState());\r\n\r\n  const [\r\n    end,\r\n    strategy\r\n  ] = stitch();\r\n  // const log = createActionNode(axiumLog(), {\r\n  //   successNode: stepAddToState\r\n  // });\r\n  end.successNode = stepAddToState;\r\n\r\n  return [\r\n    stepAddToState,\r\n    createStrategy({\r\n      topic: strategy.topic,\r\n      initialNode: strategy.currentNode,\r\n      data: strategy.data\r\n    })\r\n  ];\r\n}"},"For the graph programming framework Stratimux and the User Interface Concept, generate a strategy that will remove a page by name and its union pageStrategy":{"type":"project","content":"import { ActionStrategy, createActionNode, createStrategy } from 'stratimux';\r\nimport { userInterfaceRemovePage } from '../qualities/removePage.quality';\r\n\r\nexport const userInterfaceRemovePageStrategyTopic = 'User Interface remove page strategy. ';\r\nexport function userInterfaceRemovePageStrategy(name: string): ActionStrategy {\r\n  const stepRemoveFromState = createActionNode(userInterfaceRemovePage({\r\n    name,\r\n  }));\r\n\r\n  return createStrategy({\r\n    topic: userInterfaceRemovePageStrategyTopic,\r\n    initialNode: stepRemoveFromState,\r\n    priority: 600\r\n  });\r\n}"},"For the graph programming framework Stratimux and the User Interface Concept, generate a principle that will dispatch a sequence of page to state strategies that will cache the required pages for the client.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport {\r\n  Action,\r\n  PrincipleFunction,\r\n  UnifiedSubject,\r\n  strategySequence,\r\n  strategyBegin,\r\n  selectUnifiedState,\r\n  Concepts,\r\n  axiumRegisterStagePlanner,\r\n  axiumSelectOpen,\r\n  ActionStrategy,\r\n  getUnifiedName,\r\n  getAxiumState,\r\n  createStage,\r\n  selectSlice,\r\n  KeyedSelector,\r\n  axiumKick,\r\n} from 'stratimux';\r\nimport { UserInterfaceState } from './userInterface.concept';\r\nimport { userInterfacePageToStateStrategy } from './strategies.ts/pageToState.strategy';\r\nimport { userInterface_isClient } from '../../model/userInterface';\r\nimport { UserInterfaceClientState } from '../userInterfaceClient/userInterfaceClient.concept';\r\nimport { userInterface_createPagesSelector } from './userInterface.selector';\r\n\r\nexport const userInterfaceInitializationPrinciple: PrincipleFunction =\r\n  (___: Subscriber<Action>, cpts: Concepts, concepts$: UnifiedSubject, semaphore: number) => {\r\n    const _diag = concepts$.subscribe(val => {\r\n      const axiumState = getAxiumState(val);\r\n      if (axiumState.badActions.length > 0) {\r\n        console.error('BAD ACTIONS: ', axiumState.badActions);\r\n      }\r\n      // console.log('BAD PLANS', axiumState.badPlans);\r\n      // console.log('CHECK FOR SIDEBAR CONTENT', val[1].qualities[56]);\r\n    });\r\n    const plan = concepts$.plan('User Interface Page to State initialization plan', [\r\n      createStage((concepts, dispatch) => {\r\n        console.log('USER INTERFACE PAGE TO STATE INIT 1');\r\n        const name = getUnifiedName(concepts, semaphore);\r\n        if (name && selectSlice(concepts, axiumSelectOpen) === true) {\r\n          dispatch(axiumRegisterStagePlanner({conceptName: name, stagePlanner: plan}), {\r\n            iterateStage: true\r\n          });\r\n        } else if (name === undefined) {\r\n          console.log('THIS IS CONCLUDING EARLY', name, selectSlice(concepts, axiumSelectOpen));\r\n          plan.conclude();\r\n        }\r\n      }, { priority: 1000, selectors: [axiumSelectOpen]}),\r\n      createStage((concepts, dispatch) => {\r\n        const uiState = selectUnifiedState<UserInterfaceState>(concepts, semaphore);\r\n        console.log('USER INTERFACE PAGE TO STATE INIT 2', uiState?.pages.length, uiState?.pageStrategies.length);\r\n        if (uiState) {\r\n          if (uiState.pageStrategies.length === 1) {\r\n            dispatch(strategyBegin(userInterfacePageToStateStrategy(uiState.pageStrategies[0](concepts))), {\r\n              iterateStage: true,\r\n            });\r\n          } else if (uiState.pageStrategies.length > 1) {\r\n            const isClient = userInterface_isClient();\r\n            const list: ActionStrategy[] = [];\r\n            uiState.pageStrategies.forEach(creator => {\r\n              if (isClient) {\r\n                const pageCreator = creator(concepts);\r\n                const title = pageCreator()[1].topic;\r\n                const currentPage = (uiState as UserInterfaceClientState).currentPage;\r\n                if (title === currentPage) {\r\n                  list.push(userInterfacePageToStateStrategy(pageCreator));\r\n                }\r\n              } else {\r\n                list.push(userInterfacePageToStateStrategy(creator(concepts)));\r\n              }\r\n            });\r\n            const strategy = strategySequence(list);\r\n            if (strategy) {\r\n              // console.log('DISPATCHED', uiState.pages.length, strategy);\r\n              dispatch(strategyBegin(strategy), {\r\n                iterateStage: true,\r\n              });\r\n            }\r\n          } else {\r\n            if (getAxiumState(concepts).logging) {\r\n              console.log('No pages initialized');\r\n            }\r\n            plan.conclude();\r\n          }\r\n        }\r\n      }, { selectors: [userInterface_createPagesSelector(cpts, semaphore) as KeyedSelector]}),\r\n      createStage((____, _____) => {\r\n        console.log('USER INTERFACE PAGE TO STATE INIT 3');\r\n        plan.conclude();\r\n      })\r\n    ]);\r\n  };"},"For the graph programming framework Stratimux and the brand Concept huirth, generate a series of unified selector creators that will select slices of the user interface state.":{"type":"project","content":"import { Concepts, createUnifiedKeyedSelector  } from 'stratimux';\r\nimport { UserInterfaceState } from './userInterface.concept';\r\n\r\nexport const userInterface_createBoundSelectorsSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector<UserInterfaceState>(concepts, semaphore, 'boundSelectors');\r\n};\r\nexport const userInterface_createPagesSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector<UserInterfaceState>(concepts, semaphore, 'pages');\r\n};"},"For the graph programming framework Stratimux and the User Interface Client Concept, generate a quality that will atomically update the page html of any new changes.":{"type":"project","content":"import {\r\n  Action,\r\n  ActionNode,\r\n  ActionStrategy,\r\n  createActionNode,\r\n  createActionNodeFromStrategy,\r\n  createMethod,\r\n  createQualitySetWithPayload,\r\n  createStrategy,\r\n  nullReducer,\r\n  refreshAction,\r\n  selectPayload,\r\n  strategyBegin,\r\n} from 'stratimux';\r\nimport { BoundSelectors } from '../../../model/userInterface';\r\nimport { userInterfaceClientReplaceOuterHtml } from './replaceOuterHtml.quality';\r\nimport { Subject } from 'rxjs';\r\nimport { userInterfaceClientDetermineBindings } from './clientDetermineBindings.quality';\r\nimport { userInterfaceEnd } from '../../userInterface/qualities/end.quality';\r\n\r\nexport type UserInterfaceClientAssembleAtomicUpdateCompositionStrategyPayload = {\r\n  action$: Subject<Action>\r\n  boundActionQue: BoundSelectors[]\r\n}\r\n\r\nconst stitchUpdatedLayers = (\r\n  bound: BoundSelectors,\r\n): [ActionNode, ActionStrategy] => {\r\n  const stepEnd = createActionNode(userInterfaceEnd());\r\n  const stepReplaceOuterHtml = createActionNode(userInterfaceClientReplaceOuterHtml({id: bound.id}), {\r\n    successNode: stepEnd,\r\n  });\r\n  const stepAction = createActionNode(refreshAction(bound.action), {\r\n    successNode: stepReplaceOuterHtml,\r\n  });\r\n  return [\r\n    stepReplaceOuterHtml,\r\n    createStrategy({\r\n      initialNode: stepAction,\r\n      topic: 'STITCH ATOMIC COMPOSITION UPDATE'\r\n    })\r\n  ];\r\n};\r\n\r\nexport const [\r\n  userInterfaceClientAssembleAtomicUpdateCompositionStrategy,\r\n  userInterfaceClientAssembleAtomicUpdateCompositionStrategyType,\r\n  userInterfaceClientAssembleAtomicUpdateCompositionStrategyQuality\r\n] = createQualitySetWithPayload<UserInterfaceClientAssembleAtomicUpdateCompositionStrategyPayload>({\r\n  type: 'User Interface Client assemble update atomic compositions strategy',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createMethod(action => {\r\n    const payload = selectPayload<UserInterfaceClientAssembleAtomicUpdateCompositionStrategyPayload>(action);\r\n    const boundActionQue = payload.boundActionQue;\r\n    const action$ = payload.action$;\r\n    let previous: ActionNode | undefined;\r\n    let first: ActionNode | undefined;\r\n    for (const bound of boundActionQue) {\r\n      const [\r\n        stitchEnd,\r\n        stitchStrategy\r\n      ] = stitchUpdatedLayers(bound);\r\n      if (previous) {\r\n        const stitchNode = createActionNodeFromStrategy(stitchStrategy);\r\n        previous.successNode = stitchNode;\r\n        previous = stitchEnd;\r\n      } else {\r\n        const stitchNode = createActionNodeFromStrategy(stitchStrategy);\r\n        first = stitchNode;\r\n        previous = stitchEnd;\r\n      }\r\n    }\r\n    if (previous && boundActionQue.length > 0) {\r\n      previous.successNode = createActionNode(userInterfaceClientDetermineBindings({action$}));\r\n    } else if (previous) {\r\n      previous.successNode = createActionNode(userInterfaceEnd());\r\n    }\r\n\r\n    if (first) {\r\n      return strategyBegin(createStrategy({\r\n        initialNode: first,\r\n        topic: 'User Interface atomic update compositions'\r\n      }));\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and the User Interface Client Concept, generate a quality that will generate an ActionStrategy to bind the page's actions to the document based on the composition.":{"type":"project","content":"import {\r\n  Action,\r\n  ActionNode,\r\n  createActionNode,\r\n  createMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { UserInterfaceBindings, userInterface_selectPage } from '../../../model/userInterface';\r\nimport { Subject } from 'rxjs';\r\nimport { userInterfaceEnd } from '../../userInterface/qualities/end.quality';\r\nimport { documentObjectModelBind } from '../../documentObjectModel/qualities/bind.quality';\r\n\r\nexport type UserInterfaceClientActionQueStrategyClientPayload = {\r\n  action$: Subject<Action>\r\n}\r\nconst createBindingActionNode = (\r\n  action$: Subject<Action>,\r\n  bindings: UserInterfaceBindings\r\n): ActionNode => {\r\n  let first: ActionNode | undefined;\r\n  let previous: ActionNode | undefined;\r\n  const bindingKeys = Object.keys(bindings);\r\n  for (const key of bindingKeys) {\r\n    for (const bind of bindings[key]) {\r\n      if (previous) {\r\n        const node = createActionNode(documentObjectModelBind({action$, binding: bind, id: key}));\r\n        previous.successNode = node;\r\n        previous = node;\r\n      } else {\r\n        const node = createActionNode(documentObjectModelBind({action$, binding: bind, id: key}));\r\n        first = node;\r\n        previous = node;\r\n      }\r\n    }\r\n  }\r\n  const end = createActionNode(userInterfaceEnd());\r\n  if (previous) {\r\n    previous.successNode = end;\r\n  } else {\r\n    return end;\r\n  }\r\n  return first as ActionNode;\r\n};\r\n\r\nexport const [\r\n  userInterfaceClientDetermineBindings,\r\n  userInterfaceClientDetermineBindingsType,\r\n  userInterfaceClientDetermineBindingsQuality\r\n] = createQualitySetWithPayload<UserInterfaceClientActionQueStrategyClientPayload>({\r\n  type: 'User Interface determine bindings of all passed compositions',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createMethod(action => {\r\n    if (action.strategy) {\r\n      const payload = selectPayload<UserInterfaceClientActionQueStrategyClientPayload>(action);\r\n      let bindings: UserInterfaceBindings = {};\r\n      userInterface_selectPage(action.strategy).compositions.forEach(comp => {\r\n        if (comp.bindings) {\r\n          bindings = {\r\n            ...bindings,\r\n            ...comp.bindings\r\n          };\r\n        }\r\n      });\r\n      const action$ = payload.action$;\r\n      if (Object.keys(bindings).length > 0) {\r\n        const stepBinding = createBindingActionNode(action$, bindings);\r\n        action.strategy.currentNode.successNode = stepBinding;\r\n        return strategySuccess(action.strategy);\r\n      }\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and the User Interface Concept, generate a ActionStrategy that will create bindings for the first page provided from a list":{"type":"project","content":"import {\r\n  Action,\r\n  ActionStrategy,\r\n  createActionNode,\r\n  createStrategy,\r\n  strategySequence\r\n} from 'stratimux';\r\nimport { Page } from '../../../model/userInterface';\r\nimport { userInterfaceClientDetermineBindings } from './clientDetermineBindings.quality';\r\nimport { Subject } from 'rxjs';\r\n\r\nexport const userInterfaceInitialBindingTopic = 'User Interface create Page Strategy';\r\n\r\nexport function userInterfaceInitialBindingStrategy(\r\n  action$: Subject<Action>,\r\n  pages: Page[],\r\n): ActionStrategy {\r\n  const initialStep = createActionNode(userInterfaceClientDetermineBindings({action$}));\r\n  const initialStrategy = createStrategy({\r\n    topic: userInterfaceInitialBindingTopic,\r\n    initialNode: initialStep,\r\n    data: pages[0]\r\n  });\r\n  // const sequence: ActionStrategy[] = [initialStrategy];\r\n  // for (let i = 1; i < pages.length; i++) {\r\n  //   sequence.push(\r\n  //     createStrategy({\r\n  //       topic: userInterfaceInitialBindingTopic,\r\n  //       initialNode: initialStep,\r\n  //       data: pages[i]\r\n  //     })\r\n  //   );\r\n  // }\r\n  // return strategySequence(sequence) as ActionStrategy;\r\n  return initialStrategy;\r\n}"},"For the graph programming framework Stratimux and the User Interface Client Concept, generate a quality that will replace the outer html of a document's element based on the incoming id.":{"type":"project","content":"import {\r\n  createMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { userInterface_selectPage } from '../../../model/userInterface';\r\n\r\nexport type UserInterfaceClientReplaceOuterHtmlPayload = {\r\n  id: string,\r\n};\r\n\r\nexport const [\r\n  userInterfaceClientReplaceOuterHtml,\r\n  userInterfaceClientReplaceOuterHtmlType,\r\n  userInterfaceClientReplaceOuterHtmlQuality\r\n] = createQualitySetWithPayload({\r\n  type: 'User Interface Client assemble update atomic compositions strategy client',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createMethod(action => {\r\n    if (action.strategy) {\r\n      const payload = selectPayload<UserInterfaceClientReplaceOuterHtmlPayload>(action);\r\n      const composition = userInterface_selectPage(action.strategy).compositions.filter(comp => comp.id === payload.id)[0];\r\n      const element = document.getElementById(composition.id);\r\n      const checkActive = document.activeElement?.id;\r\n      const start = (() => {\r\n        const active = document.activeElement;\r\n        if (active) {\r\n          if ((active as HTMLInputElement).focus) {\r\n            return (active as HTMLInputElement).selectionStart;\r\n          }\r\n        }\r\n        return undefined;\r\n      })();\r\n      if (element) {\r\n        element.outerHTML = composition.html;\r\n      }\r\n      if (checkActive && start !== undefined) {\r\n        const activeElement = document.getElementById(checkActive);\r\n        if (activeElement && document.activeElement?.id && document.activeElement.id !== checkActive && activeElement['focus']) {\r\n          try {\r\n            (activeElement as HTMLInputElement).selectionStart = start;\r\n            activeElement.focus();\r\n          } catch (err) {\r\n            //\r\n          }\r\n        }\r\n      }\r\n      return strategySuccess(action.strategy);\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the graph programming framework Stratimux and the User Interface Client Concept, generate a helper that will add the passed action to the send to the actionQue utilized by the web socket concept.":{"type":"project","content":"import { Action } from 'stratimux';\r\nimport { webSocketClientAppendToActionQue } from '../../webSocketClient/qualities/appendActionQue.quality';\r\n\r\nexport const userInterfaceClientSendActionToServer = (action: Action): Action => {\r\n  return webSocketClientAppendToActionQue({actionQue: [action]});\r\n};"},"For the graph programming framework Stratimux generate a User Interface Client Concept, that will unify itself with the User Interface and incoming Brand concept to be loaded onto the client.":{"type":"project","content":"import { Concept, createConcept, unifyConcepts } from 'stratimux';\r\nimport { createHtmlConcept } from '../html/html.concepts';\r\nimport { UserInterfaceState, createUserInterfaceConcept } from '../userInterface/userInterface.concept';\r\nimport { userInterfaceClientAssembleAtomicUpdateCompositionStrategyQuality } from './qualities/clientAssembleAtomicUpdateCompositionStrategy.quality';\r\nimport { userInterfaceClientDetermineBindingsQuality } from './qualities/clientDetermineBindings.quality';\r\nimport { userInterfaceClientReplaceOuterHtmlQuality } from './qualities/replaceOuterHtml.quality';\r\nimport { userInterfaceClientOnChangePrinciple } from './userInterfaceClient.principle';\r\nimport { createWebSocketClientConcept } from '../webSocketClient/webSocketClient.concept';\r\n\r\nexport const userInterfaceClientName = 'userInterfaceClient';\r\n\r\nexport type UserInterfaceClientState = {\r\n  currentPage: string;\r\n} & UserInterfaceState;\r\n\r\nconst createUserInterfaceClientState = (): UserInterfaceClientState => {\r\n  const id = document.querySelector('[id^=\"page#\"]')?.id;\r\n  if (id) {\r\n    return {\r\n      pages: [],\r\n      components: [],\r\n      pagesCached: false,\r\n      pageStrategies: [],\r\n      currentPage: id.split('page#')[1],\r\n      boundSelectors: {},\r\n      selectors: []\r\n    };\r\n  } else {\r\n    return {\r\n      pages: [],\r\n      components: [],\r\n      pageStrategies: [],\r\n      pagesCached: false,\r\n      currentPage: '',\r\n      boundSelectors: {},\r\n      selectors: []\r\n    };\r\n  }\r\n};\r\n\r\nexport const createUserInterfaceClientConcept = (state?: Record<string, unknown>, brandCreator?: () => Concept): Concept => {\r\n  const newState: Record<string, unknown> = {};\r\n  if (state) {\r\n    const stateKeys = Object.keys(state);\r\n    for (const key of stateKeys) {\r\n      if (key !== 'pages' && key !== 'pageStrategies' && key !== 'pagesCached' && key !== 'currentPage' && key !== 'actionQue') {\r\n        newState[key] = state[key];\r\n      }\r\n    }\r\n  }\r\n  const unified = brandCreator ? unifyConcepts([\r\n    createHtmlConcept(),\r\n    createWebSocketClientConcept(),\r\n    createUserInterfaceConcept([]),\r\n    createConcept(\r\n      '',\r\n      createUserInterfaceClientState(),\r\n      [\r\n        userInterfaceClientAssembleAtomicUpdateCompositionStrategyQuality,\r\n        userInterfaceClientDetermineBindingsQuality,\r\n        userInterfaceClientReplaceOuterHtmlQuality\r\n      ],\r\n      [\r\n        userInterfaceClientOnChangePrinciple\r\n      ]\r\n    ),\r\n    brandCreator(),\r\n  ],\r\n  createConcept(\r\n    userInterfaceClientName,\r\n    newState,\r\n  )) : unifyConcepts([\r\n    createHtmlConcept(),\r\n    createWebSocketClientConcept(),\r\n    createUserInterfaceConcept([]),\r\n    createConcept(\r\n      '',\r\n      createUserInterfaceClientState(),\r\n      [\r\n        userInterfaceClientAssembleAtomicUpdateCompositionStrategyQuality,\r\n        userInterfaceClientDetermineBindingsQuality,\r\n        userInterfaceClientReplaceOuterHtmlQuality\r\n      ],\r\n      [\r\n        userInterfaceClientOnChangePrinciple\r\n      ]\r\n    ),\r\n  ],\r\n  createConcept(\r\n    userInterfaceClientName,\r\n    newState,\r\n  ));\r\n  return unified;\r\n};"},"For the graph programming framework Stratimux and the User Interface Client Concept,\r\ngenerate a principle that will detect changes on the client state based on the currently loaded page bound selectors, and dispatch the associated action if changed.\r\nThis will set up and bind the selectors to state to determine which atomic operation that should be dispatched to update the UI.":{"type":"project","content":"import {\r\n  Action,\r\n  Concepts,\r\n  KeyedSelector,\r\n  PrincipleFunction,\r\n  UnifiedSubject,\r\n  axiumKick,\r\n  axiumRegisterStagePlanner,\r\n  axiumSelectOpen,\r\n  createStage,\r\n  getAxiumState,\r\n  getUnifiedName,\r\n  selectSlice,\r\n  selectUnifiedState,\r\n  strategyBegin,\r\n  updateUnifiedKeyedSelector,\r\n} from 'stratimux';\r\nimport { UserInterfaceClientState } from './userInterfaceClient.concept';\r\nimport { BoundSelectors } from '../../model/userInterface';\r\nimport { Subscriber } from 'rxjs';\r\nimport {\r\n  UserInterfaceClientAssembleAtomicUpdateCompositionStrategyPayload,\r\n  userInterfaceClientAssembleAtomicUpdateCompositionStrategy\r\n} from './qualities/clientAssembleAtomicUpdateCompositionStrategy.quality';\r\nimport { userInterface_createBoundSelectorsSelector, userInterface_createPagesSelector } from '../userInterface/userInterface.selector';\r\nimport { huirth_createDialogSelector } from '../huirth/huirth.selector';\r\nimport { userInterfaceInitialBindingStrategy } from './qualities/initialBinding.strategy';\r\n\r\nexport const userInterfaceClientOnChangePrinciple: PrincipleFunction =\r\n  (___: Subscriber<Action>, cpts: Concepts, concepts$: UnifiedSubject, semaphore: number) => {\r\n    // const atomicCachedState: Record<string, unknown> = {};\r\n    const boundSelectorsSelector = userInterface_createBoundSelectorsSelector(cpts, semaphore) as KeyedSelector;\r\n    const beat = 100;\r\n    const plan = concepts$.plan('User Interface Server on Change', [\r\n      createStage((concepts, dispatch) => {\r\n        const name = getUnifiedName(concepts, semaphore);\r\n        if (name && selectSlice(concepts, axiumSelectOpen) === true) {\r\n          dispatch(axiumRegisterStagePlanner({conceptName: name, stagePlanner: plan}), {\r\n            iterateStage: true\r\n          });\r\n        } else if (name === undefined) {\r\n          plan.conclude();\r\n        }\r\n      }, {selectors: [axiumSelectOpen]}),\r\n      createStage((concepts, dispatch) => {\r\n        //\r\n        const pages = selectUnifiedState<UserInterfaceClientState>(concepts, semaphore)?.pages;\r\n        if (pages) {\r\n          if (pages.length > 0) {\r\n            dispatch(strategyBegin(userInterfaceInitialBindingStrategy(getAxiumState(concepts).action$, pages)), {\r\n              iterateStage: true,\r\n            });\r\n          }\r\n        } else {\r\n          plan.conclude();\r\n        }\r\n      }, { selectors: [userInterface_createPagesSelector(cpts, semaphore) as KeyedSelector] }),\r\n      createStage((concepts, dispatch, changes) => {\r\n        // console.log('Get unified name', getUnifiedName(concepts, semaphore));\r\n        const uiState = selectUnifiedState<UserInterfaceClientState>(concepts, semaphore);\r\n        if (uiState && uiState.pagesCached) {\r\n          const newSelectors = [boundSelectorsSelector, ...uiState.selectors];\r\n          const changed: Record<string, boolean> = {};\r\n          const payload: UserInterfaceClientAssembleAtomicUpdateCompositionStrategyPayload = {\r\n            action$: getAxiumState(concepts).action$,\r\n            boundActionQue: [],\r\n          };\r\n          changes?.forEach(change => {\r\n            const bound = uiState.boundSelectors[change.keys];\r\n            if (bound) {\r\n              bound.forEach(b => {\r\n                const exists = changed[b.semaphore.toString()];\r\n                if (exists === undefined) {\r\n                  changed[b.semaphore.toString()] = true;\r\n                  b.action.conceptSemaphore = semaphore;\r\n                  payload.boundActionQue.push(b);\r\n                }\r\n              });\r\n            }\r\n          });\r\n          if (payload.boundActionQue.length > 0) {\r\n            dispatch(userInterfaceClientAssembleAtomicUpdateCompositionStrategy(payload), {\r\n              throttle: 0,\r\n              newSelectors\r\n            });\r\n          } else {\r\n            dispatch(axiumKick(), {\r\n              throttle: 0,\r\n              newSelectors\r\n            });\r\n          }\r\n        } else if (uiState === undefined) {\r\n          console.log('SHOULDN\\'T CONCLUDE, unless removed');\r\n          plan.conclude();\r\n        }\r\n      }, {beat, selectors: [boundSelectorsSelector]}),\r\n    ]\r\n    );\r\n  };"},"For the graph programming framework Stratimux and the User Interface Server Concept, generate a quality that will build trigger a build script within the context directory.":{"type":"project","content":"import {\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyData_appendFailure,\r\n  strategyFailed,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport {exec} from 'child_process';\r\n\r\nexport type BuildContextPayload = {contextDir: string};\r\n\r\nexport const [\r\n  userInterfaceServerBuildContext,\r\n  userInterfaceServerBuildContextType,\r\n  userInterfaceServerBuildContextQuality\r\n] = createQualitySetWithPayload<BuildContextPayload>({\r\n  type: 'User Interface Server build Context',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createAsyncMethod(\r\n    (controller, action) => {\r\n      const payload = selectPayload<BuildContextPayload>(action);\r\n      if (action.strategy) {\r\n        exec(`cd ${payload.contextDir} & npm run build`, (error, stdout, stderr) => {\r\n          if (action.strategy) {\r\n            if (error) {\r\n              console.error(`error: ${error}, stdout: ${stdout}, stderr: ${stderr}`);\r\n              controller.fire(\r\n                strategyFailed(action.strategy, strategyData_appendFailure(action.strategy, stderr))\r\n              );\r\n            } else {\r\n              console.log('stdout:', stdout);\r\n              controller.fire(\r\n                strategySuccess(action.strategy)\r\n              );\r\n            }\r\n          } else {\r\n            controller.fire(axiumConclude());\r\n          }\r\n          console.log('stdout:', stdout);\r\n        });\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and the User Interface Server Concept, generate a quality that will create the context's index file to dictate the execution of the client page script.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { PrimedConceptAndProperties } from '../../../model/userInterface';\r\nimport { createContextIndexContent } from '../../../model/contextIndex';\r\n\r\nexport type CreateContextIndexPayload = {\r\n  primedConcepts: PrimedConceptAndProperties[],\r\n  root: string,\r\n  directoryMap: string[]\r\n};\r\n\r\nexport const [\r\n  userInterfaceServerCreateContextIndex,\r\n  userInterfaceServerCreateContextIndexType,\r\n  userInterfaceServerCreateContextIndexQuality\r\n] = createQualitySetWithPayload<CreateContextIndexPayload>({\r\n  type: 'User Interface Server create Context index.ts',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createAsyncMethod(\r\n    (controller, action) => {\r\n      const payload = selectPayload<CreateContextIndexPayload>(action);\r\n      if (action.strategy) {\r\n        const indexTs = path.join(payload.root + '/context/src/index.ts');\r\n        const content = createContextIndexContent(payload.primedConcepts, payload.directoryMap);\r\n        fs.writeFile(indexTs, content).then(() => {\r\n          const newStrategy =\r\n            strategySuccess(action.strategy as ActionStrategy);\r\n          controller.fire(newStrategy);\r\n        });\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and the User Interface Server Concept, generate a quality that will create a html document for each currently loaded page in the target directory.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  UnifiedSubject,\r\n  axiumConclude,\r\n  createAsyncMethodWithState,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport { UserInterfaceServerState } from '../userInterfaceServer.concept';\r\n\r\nexport type CreateEachPageHtmlPayload = {\r\n  targetDir: string\r\n};\r\n\r\nexport const [\r\n  userInterfaceServerCreateEachPageHtml,\r\n  userInterfaceServerCreateEachPageHtmlType,\r\n  userInterfaceServerCreateEachPageHtmlQuality\r\n] = createQualitySetWithPayload<CreateEachPageHtmlPayload>({\r\n  type: 'User Interface Server create each page\\'s html file',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$, semaphore) =>\r\n    createAsyncMethodWithState<UserInterfaceServerState>((controller, action, state) => {\r\n      const payload = selectPayload<CreateEachPageHtmlPayload>(action);\r\n      const pages = [];\r\n      for (const page of state.pages) {\r\n        if (page.title.toLocaleLowerCase().indexOf('error') !== -1) {\r\n          pages.push({\r\n            html: page.compositions.map(comp => {\r\n              if (comp.universal) {\r\n                return state.components[comp.componentSemaphore as number].html;\r\n              }\r\n              return comp.html;\r\n            }).join(''),\r\n            fileName: path.resolve(payload.targetDir + 404 + '.html')\r\n          });\r\n        } else {\r\n          pages.push({\r\n            html: page.compositions.map(comp => {\r\n              if (comp.universal) {\r\n                return state.components[comp.componentSemaphore as number].html;\r\n              }\r\n              return comp.html;\r\n            }).join(''),\r\n            fileName: path.resolve(payload.targetDir + page.title + '.html')\r\n          });\r\n        }\r\n      }\r\n      if (action.strategy) {\r\n        for (const page of pages) {\r\n          fs.writeFile(page.fileName, page.html, (err) => {\r\n            console.log('CHECK', err);\r\n            if (err) { throw err; }\r\n          });\r\n        }\r\n        const newStrategy =\r\n            strategySuccess(action.strategy as ActionStrategy);\r\n        controller.fire(newStrategy);\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    }, concepts$ as UnifiedSubject, semaphore as number)\r\n});"},"For the graph programming framework Stratimux and the User Interface Server Concept, generate a quality that will run a format script within the context directory.":{"type":"project","content":"import {\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyData_appendFailure,\r\n  strategyFailed,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport {exec} from 'child_process';\r\n\r\nexport type FormatContextPayload = {contextDir: string};\r\n\r\nexport const [\r\n  userInterfaceServerFormatContext,\r\n  userInterfaceServerFormatContextType,\r\n  userInterfaceServerFormatContextQuality\r\n] = createQualitySetWithPayload<FormatContextPayload>({\r\n  type: 'User Interface Server format Context',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createAsyncMethod(\r\n    (controller, action) => {\r\n      const payload = selectPayload<FormatContextPayload>(action);\r\n      if (action.strategy) {\r\n        exec(`cd ${payload.contextDir} & npm run prettier-format`, (error, stdout, stderr) => {\r\n          if (action.strategy) {\r\n            if (error) {\r\n              console.error('stderr:', stderr);\r\n              controller.fire(\r\n                strategyFailed(action.strategy, strategyData_appendFailure(action.strategy, stderr))\r\n              );\r\n            } else {\r\n              console.log('stdout:', stdout);\r\n              controller.fire(\r\n                strategySuccess(action.strategy)\r\n              );\r\n            }\r\n          } else {\r\n            controller.fire(axiumConclude());\r\n          }\r\n          console.log('stdout:', stdout);\r\n        });\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    }\r\n  )\r\n});"},"For the graph programming framework Stratimux and the User Interface Server Concept, generate a quality that will create recursively a html document for each page presented in the payload in the target directory.":{"type":"project","content":"import {\r\n  axiumConclude,\r\n  createAsyncMethod,\r\n  createQualitySetWithPayload,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyRecurse,\r\n  strategySuccess\r\n} from 'stratimux';\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { Page } from '../../../model/userInterface';\r\n\r\nexport type RecursivelyCreateEachPageHtmlPayload = {\r\n  targetDir: string,\r\n  pages: Page[]\r\n};\r\n\r\nexport const [\r\n  userInterfaceServerRecursivelyCreateEachPageHtml,\r\n  userInterfaceServerRecursivelyCreateEachPageHtmlType,\r\n  userInterfaceServerRecursivelyCreateEachPageHtmlQuality\r\n] = createQualitySetWithPayload<RecursivelyCreateEachPageHtmlPayload>({\r\n  type: 'User Interface Server recursively create each page\\'s html file',\r\n  reducer: nullReducer,\r\n  methodCreator: () =>\r\n    createAsyncMethod((controller, action) => {\r\n      const payload = selectPayload<RecursivelyCreateEachPageHtmlPayload>(action);\r\n      const targetPage = payload.pages.shift();\r\n      if (targetPage) {\r\n        let page;\r\n        if (targetPage.title.toLocaleLowerCase().indexOf('error') !== -1) {\r\n          page = {\r\n            html: targetPage.compositions.map(comp => comp.html).join(''),\r\n            fileName: path.resolve(payload.targetDir + 404 + '.html')\r\n          };\r\n        } else {\r\n          page = {\r\n            html: targetPage.compositions.map(comp => comp.html).join(''),\r\n            fileName: path.resolve(payload.targetDir + targetPage.title + '.html')\r\n          };\r\n        }\r\n        fs.writeFile(page.fileName, page.html).then(() => {\r\n          if (action.strategy) {\r\n            if (payload.pages.length > 0) {\r\n              controller.fire(strategyRecurse(action.strategy, {\r\n                payload,\r\n              }));\r\n            } else {\r\n              controller.fire(strategySuccess(action.strategy));\r\n            }\r\n          } else {\r\n            controller.fire(axiumConclude());\r\n          }\r\n        });\r\n      } else if (action.strategy) {\r\n        controller.fire(strategySuccess(action.strategy));\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    })\r\n});"},"For the graph programming framework Stratimux and the User Interface Server Concept, generate a quality that will generate a new strategy that will atomically update the composition currently loaded in the pages property.":{"type":"project","content":"/*<$\r\nFor the graph programming framework Stratimux and the User Interface Server Concept, generate a quality that will generate a new strategy that will atomically update the composition currently loaded in the pages property.\r\n$>*/\r\n/*<#*/"},"For the graph programming framework Stratimux and the User Interface Server Concept, generate a strategy stitch that will assemble the context directory to contain the necessary concepts dictated by the generated index file.":{"type":"project","content":"import { ActionNode, ActionStrategy, ActionStrategyParameters, axiumLog, createActionNode, createStrategy } from 'stratimux';\r\nimport { fileSystemRemoveTargetDirectory } from '../../fileSystem/qualities/removeTargetDirectory.quality';\r\nimport path from 'path';\r\nimport {\r\n  RecursivelyCopyMoveTargetDirectoriesPayload,\r\n  fileSystemRecursivelyCopyMoveTargetDirectories\r\n} from '../../fileSystem/qualities/recursivelyCopyMoveDirectories.quality';\r\nimport { userInterfaceServerBuildContext } from '../qualities/buildContext.quality';\r\nimport { ConceptAndProperties, PrimedConceptAndProperties } from '../../../model/userInterface';\r\nimport { userInterfaceServerCreateContextIndex } from '../qualities/createContextIndex.quality';\r\nimport { serverName } from '../../server/server.concept';\r\nimport { userInterfaceServerFormatContext } from '../qualities/formatContext.quality';\r\nimport { webSocketClientName } from '../../webSocketClient/webSocketClient.concept';\r\n\r\nexport const userInterfaceServerPrepareContextConceptsTopic = 'User Interface Server prepare Context Concepts';\r\nexport function userInterfaceServerPrepareContextConceptsStitch(\r\n  root: string,\r\n  conceptsAndProps: ConceptAndProperties[],\r\n  unifiedConcepts: string[],\r\n  initialDirectoryMap: string[]\r\n): [ActionNode, ActionStrategy] {\r\n  const conceptNames = [];\r\n  const copyMovePayload: RecursivelyCopyMoveTargetDirectoriesPayload = {\r\n    directories: []\r\n  };\r\n  const directoryMap: string[] = [];\r\n  const contextConcepts = path.join(root + '/context/src/concepts/');\r\n  const contextModel = path.join(root + '/context/src/model/');\r\n  const modelDirectory = {\r\n    name: 'model',\r\n    newLocation: path.join(root + '/context/src/model/'),\r\n    target: path.join(root + '/server/src/model/')\r\n  };\r\n  // Server only concepts should not be unified into the server concept\r\n  // As the userInterface, is an interoperable concept between server and client\r\n  // Therefore you should only unify what would be needed for both\r\n  unifiedConcepts.forEach(name => {\r\n    if (!name.toLowerCase().includes(serverName.toLowerCase())) {\r\n      for (const directory of initialDirectoryMap) {\r\n        if (directory === name) {\r\n          copyMovePayload.directories.push({\r\n            name,\r\n            newLocation: path.join(root + '/context/src/concepts/' + name),\r\n            target: path.join(root + '/server/src/concepts/' + name)\r\n          });\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  });\r\n  const primedConcepts: PrimedConceptAndProperties[] = conceptsAndProps.map(conceptAndProps => {\r\n    conceptNames.push(conceptAndProps.name);\r\n    for (const directory of initialDirectoryMap) {\r\n      const isSet = copyMovePayload.directories.filter(d => d.name === conceptAndProps.name).length > 0;\r\n      if (directory === conceptAndProps.name && !isSet) {\r\n        copyMovePayload.directories.push({\r\n          name: conceptAndProps.name,\r\n          newLocation: path.join(root + '/context/src/concepts/' + conceptAndProps.name),\r\n          target: path.join(root + '/server/src/concepts/' + conceptAndProps.name)\r\n        });\r\n      }\r\n      if (directory === conceptAndProps.name) {\r\n        directoryMap.push(conceptAndProps.name);\r\n        break;\r\n      }\r\n    }\r\n    return {\r\n      name: conceptAndProps.name,\r\n      nameCapitalized: conceptAndProps.name[0].toUpperCase() + conceptAndProps.name.substring(1),\r\n      properties: conceptAndProps.properties\r\n    };\r\n  });\r\n  copyMovePayload.directories.push({\r\n    name: webSocketClientName,\r\n    newLocation: path.join(root + '/context/src/concepts/' + webSocketClientName),\r\n    target: path.join(root + '/server/src/concepts/' + webSocketClientName)\r\n  });\r\n  const stepLog = createActionNode(axiumLog());\r\n  const stepContextBuild = createActionNode(userInterfaceServerBuildContext({contextDir: path.join(root + '/context/')}), {\r\n    failureNode: stepLog,\r\n    agreement: 7000\r\n  });\r\n  const stepContextFormat = createActionNode(userInterfaceServerFormatContext({contextDir: path.join(root + '/context/')}), {\r\n    successNode: stepContextBuild,\r\n    failureNode: stepLog,\r\n    agreement: 7000\r\n  });\r\n  const stepCreateContextIndex = createActionNode(userInterfaceServerCreateContextIndex({\r\n    primedConcepts,\r\n    root,\r\n    directoryMap\r\n  }), {\r\n    successNode: stepContextFormat,\r\n  });\r\n  const stepCopyMoveModel = createActionNode(fileSystemRecursivelyCopyMoveTargetDirectories({directories: [modelDirectory]}), {\r\n    successNode: stepCreateContextIndex,\r\n  });\r\n  const stepContextModelRemove = createActionNode(fileSystemRemoveTargetDirectory({path: contextModel}), {\r\n    successNode: stepCopyMoveModel,\r\n    agreement: 20000\r\n  });\r\n  const stepCopyMoveConcepts = createActionNode(fileSystemRecursivelyCopyMoveTargetDirectories(copyMovePayload), {\r\n    successNode: stepContextModelRemove,\r\n  });\r\n  const stepContextConceptRemove = createActionNode(fileSystemRemoveTargetDirectory({path: contextConcepts}), {\r\n    successNode: stepCopyMoveConcepts,\r\n    agreement: 20000\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: userInterfaceServerPrepareContextConceptsTopic,\r\n    initialNode: stepContextConceptRemove,\r\n  };\r\n\r\n  return [stepContextBuild, createStrategy(params)];\r\n}"},"For the graph programming framework Stratimux and the User Interface Server Concept, generate an ActionStrategy the composes the prepare context concepts stich as its beginning the prepares a static deployment.\r\nBy create all the necessary page html files and moving context directories that those fils would utilize in production.":{"type":"project","content":"/*<$\r\nFor the graph programming framework Stratimux and the User Interface Server Concept, generate an ActionStrategy the composes the prepare context concepts stich as its beginning the prepares a static deployment.\r\nBy create all the necessary page html files and moving context directories that those fils would utilize in production.\r\n$>*/\r\n/*<#*/"},"For the graph programming framework Stratimux and the User Interface Server Concept, generate a helper that will send the passed action to the client via the Web Socket Concept.":{"type":"project","content":"import { Action } from 'stratimux';\r\nimport { webSocketServerAppendToActionQue } from '../../webSocketServer/qualities/appendActionQue.quality';\r\n\r\nexport const userInterfaceServerSendActionToClient = (action: Action): Action => {\r\n  return webSocketServerAppendToActionQue({actionQue: [action]});\r\n};"},"For the graph programming framework Stratimux generate a User Interface Server Concept, that will unify itself with the User Interface and incoming Brand concept to be loaded on the server.":{"type":"project","content":"import { Concept, PrincipleFunction, Quality, createConcept, unifyConcepts } from 'stratimux';\r\nimport { createServerConcept } from '../server/server.concept';\r\nimport { userInterfaceServerOnChangePrinciple, userInterfaceServerPrinciple } from './userInterfaceServer.principle';\r\nimport { commandLineInterfaceGoals } from '../../model/commandLineInterface';\r\nimport {\r\n  UserInterfaceState,\r\n  createUserInterfaceConcept,\r\n} from '../userInterface/userInterface.concept';\r\nimport { userInterfaceServerBuildContextQuality } from './qualities/buildContext.quality';\r\nimport { userInterfaceServerContextPrinciple } from './userInterfaceServer.context.principle';\r\nimport { userInterfaceServerCreateEachPageHtmlQuality } from './qualities/createEachPageHtml.quality';\r\nimport { userInterfaceServerRecursivelyCreateEachPageHtmlQuality } from './qualities/recursivelyCreateEachPageHtml.quality';\r\nimport { userInterfaceServerCreateContextIndexQuality } from './qualities/createContextIndex.quality';\r\nimport { helloWorldPageStrategy } from '../userInterface/strategies.ts/helloWorldPage.strategy';\r\nimport { userInterfaceServerFormatContextQuality } from './qualities/formatContext.quality';\r\nimport { PageStrategyCreators } from '../../model/userInterface';\r\nimport { userInterfaceServerAssembleUpdateAtomicCompositionStrategyQuality } from './qualities/serverAssembleUpdateAtomicCompositionStrategy.quality';\r\nimport { createWebSocketServerConcept } from '../webSocketServer/webSocketServer.concept';\r\n\r\n// eslint-disable-next-line no-shadow\r\nexport enum workingConceptCategory {\r\n  folder = 'folder',\r\n  import = 'import'\r\n}\r\n\r\nexport const userInterfaceServerName = 'userInterfaceServer';\r\n\r\nexport type UserInterfaceServerState = {\r\n  createClientIndexQue: string[];\r\n  brand?: string;\r\n  goal: string,\r\n} & UserInterfaceState\r\n\r\nconst createUserInterfaceServerState =\r\n  (pageStrategies: PageStrategyCreators[], goal: commandLineInterfaceGoals): UserInterfaceServerState => {\r\n    return {\r\n      pages: [],\r\n      components: [],\r\n      pageStrategies,\r\n      pagesCached: false,\r\n      createClientIndexQue: [],\r\n      goal,\r\n      boundSelectors: {},\r\n      selectors: []\r\n    };\r\n  };\r\n\r\nconst principleGoal = (goal: commandLineInterfaceGoals): PrincipleFunction[] => {\r\n  switch (goal) {\r\n  case commandLineInterfaceGoals.simulate: {\r\n    return [\r\n      userInterfaceServerOnChangePrinciple\r\n    ];\r\n  }\r\n  case commandLineInterfaceGoals.none: {\r\n    return [];\r\n  }\r\n  default: {\r\n    return [\r\n      userInterfaceServerContextPrinciple,\r\n      userInterfaceServerOnChangePrinciple\r\n    ];\r\n  }\r\n  }\r\n};\r\n\r\nconst qualityGoal = (goal: commandLineInterfaceGoals): Quality[] => {\r\n  switch (goal) {\r\n  case commandLineInterfaceGoals.simulate: {\r\n    return [\r\n      userInterfaceServerAssembleUpdateAtomicCompositionStrategyQuality\r\n    ];\r\n  }\r\n  default: {\r\n    return [\r\n      userInterfaceServerCreateEachPageHtmlQuality,\r\n      userInterfaceServerRecursivelyCreateEachPageHtmlQuality,\r\n      userInterfaceServerCreateContextIndexQuality,\r\n      userInterfaceServerBuildContextQuality,\r\n      userInterfaceServerFormatContextQuality,\r\n      userInterfaceServerAssembleUpdateAtomicCompositionStrategyQuality\r\n    ];\r\n  }\r\n  }\r\n};\r\n\r\nconst baseUserInterfaceServerConcept = (goal: commandLineInterfaceGoals, pageStrategies: PageStrategyCreators[]) => {\r\n  return unifyConcepts([\r\n    createUserInterfaceConcept([]),\r\n  ],\r\n  createConcept(\r\n    userInterfaceServerName,\r\n    createUserInterfaceServerState(pageStrategies, goal),\r\n    [\r\n      userInterfaceServerBuildContextQuality,\r\n      ...qualityGoal(goal)\r\n    ],\r\n    [\r\n      userInterfaceServerPrinciple,\r\n      ...principleGoal(goal),\r\n    ],\r\n  ));\r\n};\r\n\r\nconst unifyBrandConcept = (goal: commandLineInterfaceGoals, brand: {\r\n  concept: Concept,\r\n}) => {\r\n  const base = baseUserInterfaceServerConcept(goal, []);\r\n  base.name = '';\r\n  const unified = unifyConcepts([\r\n    base,\r\n    brand.concept,\r\n  ],\r\n  createConcept(\r\n    userInterfaceServerName,\r\n    {}\r\n  )\r\n  );\r\n  (unified.state as UserInterfaceServerState).brand = brand.concept.name;\r\n  return unified;\r\n};\r\n\r\nconst userInterfaceServerConcept = (goal: commandLineInterfaceGoals, brand?: {\r\n  concept: Concept,\r\n}): Concept =>  {\r\n  if (brand) {\r\n    return unifyBrandConcept(goal, brand);\r\n  }\r\n  return baseUserInterfaceServerConcept(goal, [helloWorldPageStrategy]);\r\n};\r\n\r\nexport const createUserInterfaceServerConcept = (goal: commandLineInterfaceGoals, brand?: {\r\n  concept: Concept,\r\n}, port?: number) => {\r\n  const serverConcept = createServerConcept(port);\r\n  const unified = unifyConcepts([createWebSocketServerConcept(), serverConcept], userInterfaceServerConcept(goal, brand));\r\n  return unified;\r\n};"},"For the graph programming framework Stratimux and the User Interface Server Concept,\r\ngenerate a principle that will manager a generated context based upon the the configuration of the server. This context will be treated as the client run time.":{"type":"project","content":"import {\r\n  Action,\r\n  Concepts,\r\n  PrincipleFunction,\r\n  UnifiedSubject,\r\n  areConceptsLoaded,\r\n  axiumRegisterStagePlanner,\r\n  axiumSelectOpen,\r\n  createStage,\r\n  getAxiumState,\r\n  primeAction,\r\n  selectSlice,\r\n  selectState,\r\n  selectUnifiedState,\r\n  strategyBegin\r\n} from 'stratimux';\r\nimport { Subscriber } from 'rxjs';\r\nimport { FileSystemState, fileSystemName } from '../fileSystem/fileSystem.concept';\r\nimport { UserInterfaceServerState, userInterfaceServerName } from './userInterfaceServer.concept';\r\nimport {\r\n  ConceptAndProperties,\r\n  UserInterfaceBindings,\r\n  UserInterfacePageBindings,\r\n  userInterface_pageBindingsToString\r\n} from '../../model/userInterface';\r\nimport { userInterfaceServerPrepareContextConceptsStitch } from './strategies/prepareContextConcepts.strategy';\r\nimport { userInterfaceServerSetConceptDirectoriesFromDataStrategy } from './strategies/setConceptDirectories.strategy';\r\nimport { documentObjectModelName } from '../documentObjectModel/documentObjectModel.concept';\r\nimport { commandLineInterfaceGoals } from '../../model/commandLineInterface';\r\nimport { userInterfaceServerPrepareStaticConceptsStrategy } from './strategies/prepareStaticConcepts.strategy';\r\nimport { userInterfaceClientName } from '../userInterfaceClient/userInterfaceClient.concept';\r\n\r\nexport const userInterfaceServerContextPrinciple: PrincipleFunction = (\r\n  _: Subscriber<Action>,\r\n  _concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  const plan = concepts$.plan('User Interface Context Principle Plan', [\r\n    createStage((concepts, dispatch, changes) => {\r\n      console.log('CHECK IF THIS HITS', selectSlice(concepts, axiumSelectOpen), getAxiumState(concepts).modeIndex, axiumSelectOpen.keys, changes , 'stuff');\r\n      if (selectSlice(concepts, axiumSelectOpen) === true) {\r\n        const fileSystemExists = areConceptsLoaded(concepts, [fileSystemName]);\r\n        if (!fileSystemExists) {\r\n          console.log('FILE SYSTEM NOT LOADED, CONTEXT PRINCIPLE CONCLUDE');\r\n          plan.conclude();\r\n        } else {\r\n          dispatch(primeAction(concepts, axiumRegisterStagePlanner({conceptName: userInterfaceServerName, stagePlanner: plan})), {\r\n            iterateStage: true,\r\n          });\r\n        }\r\n      }\r\n    }, { selectors: [axiumSelectOpen] }),\r\n    createStage((concepts, dispatch) => {\r\n      console.log('CHECK IF THIS HITS 2');\r\n      const fileSystemState = selectState<FileSystemState>(concepts, fileSystemName);\r\n      if (fileSystemState) {\r\n        dispatch(strategyBegin(userInterfaceServerSetConceptDirectoriesFromDataStrategy(fileSystemState.root)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      console.log('CHECK IF THIS HITS 3');\r\n      const fileSystemState = selectState<FileSystemState>(concepts, fileSystemName);\r\n      const uiState = selectUnifiedState<UserInterfaceServerState>(concepts, semaphore);\r\n      if (fileSystemState && uiState) {\r\n        if (fileSystemState.conceptDirectoryMap.length > 0 && uiState.pageStrategies.length > 0) {\r\n          if (uiState.pageStrategies.length === uiState.pages.length) {\r\n            const conceptsAndProps: ConceptAndProperties[] = [];\r\n            const finalBindingsList: UserInterfacePageBindings = {};\r\n            for (const page of uiState.pages) {\r\n              page.conceptAndProps.forEach(conceptAndProp => {\r\n                let exists = false;\r\n                conceptsAndProps.forEach(cap => {\r\n                  if (cap.name === conceptAndProp.name) {\r\n                    exists = true;\r\n                  }\r\n                });\r\n                if (!exists) {\r\n                  conceptsAndProps.push({\r\n                    name: conceptAndProp.name,\r\n                    properties: conceptAndProp.properties\r\n                  });\r\n                }\r\n                if (uiState.brand) {\r\n                  let bindingsList: UserInterfaceBindings = {};\r\n                  for (const comp of page.compositions) {\r\n                    if (comp.bindings) {\r\n                      bindingsList = {\r\n                        ...bindingsList,\r\n                        ...comp.bindings\r\n                      };\r\n                    }\r\n                  }\r\n                  finalBindingsList[page.title] = bindingsList;\r\n                }\r\n              });\r\n            }\r\n            conceptsAndProps.push({\r\n              name: documentObjectModelName,\r\n              properties: [userInterface_pageBindingsToString(finalBindingsList)],\r\n            });\r\n            if (uiState.brand) {\r\n              conceptsAndProps.push({\r\n                name: userInterfaceClientName,\r\n                properties: ['state', uiState.brand]\r\n              });\r\n            } else {\r\n              conceptsAndProps.push({\r\n                name: userInterfaceClientName,\r\n                properties: ['state']\r\n              });\r\n            }\r\n            if (uiState.goal === commandLineInterfaceGoals.dynamicDeployment) {\r\n              console.log('CHECK IF THIS HITS');\r\n              const [____, contextStrategy] = userInterfaceServerPrepareContextConceptsStitch(\r\n                fileSystemState.root,\r\n                conceptsAndProps,\r\n                concepts[semaphore].unified,\r\n                fileSystemState.conceptDirectoryMap\r\n              );\r\n              dispatch(strategyBegin(contextStrategy), {\r\n                iterateStage: true\r\n              });\r\n            } else {\r\n              const contextStrategy = userInterfaceServerPrepareStaticConceptsStrategy(\r\n                fileSystemState.root,\r\n                conceptsAndProps,\r\n                concepts[semaphore].unified,\r\n                fileSystemState.conceptDirectoryMap,\r\n                uiState.pages\r\n              );\r\n              dispatch(strategyBegin(contextStrategy), {\r\n                iterateStage: true\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }),\r\n    createStage(() => {\r\n      plan.conclude();\r\n    }),\r\n  ]);\r\n};"},"For the graph programming framework Stratimux and the User Interface Server Concept, generate a principle that will create a plan that synchronizes the server's state with the client state.\r\nWhile ignoring certain parts to allow for this recursive connection to be halting complete.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport { ServerState } from '../server/server.concept';\r\nimport express from 'express';\r\nimport {\r\n  Action,\r\n  Concepts,\r\n  KeyedSelector,\r\n  PrincipleFunction,\r\n  UnifiedSubject,\r\n  axiumKick,\r\n  axiumRegisterStagePlanner,\r\n  axiumSelectOpen,\r\n  createStage,\r\n  getUnifiedName,\r\n  refreshAction,\r\n  select,\r\n  selectSlice,\r\n  selectState,\r\n  selectUnifiedState,\r\n  updateUnifiedKeyedSelector,\r\n} from 'stratimux';\r\nimport { BoundSelectors, Composition, Page } from '../../model/userInterface';\r\nimport path from 'path';\r\nimport { FileSystemState, fileSystemName } from '../fileSystem/fileSystem.concept';\r\nimport { findRoot } from '../../model/findRoot';\r\nimport { UserInterfaceServerState } from './userInterfaceServer.concept';\r\nimport {\r\n  UserInterfaceServerAssembleUpdateAtomicCompositionStrategyPayload,\r\n  userInterfaceServerAssembleUpdateAtomicCompositionStrategy\r\n} from './qualities/serverAssembleUpdateAtomicCompositionStrategy.quality';\r\n\r\nexport const userInterfaceServerPrinciple: PrincipleFunction =\r\n  (_: Subscriber<Action>, cpts: Concepts, concepts$: UnifiedSubject, semaphore: number) => {\r\n    const newState = selectUnifiedState(cpts, semaphore) as Record<string, unknown>;\r\n    const body = 'body response';\r\n    let pages: Page[] = [];\r\n    let components: Composition[] = [];\r\n    let errorPage: undefined | string;\r\n    concepts$.subscribe(concepts => {\r\n      const uiState = selectUnifiedState<UserInterfaceServerState>(concepts, semaphore);\r\n      if (uiState) {\r\n        // console.log('CHECK PAGES LENGTH', uiState.pages.length);\r\n        components = uiState.components;\r\n        if (uiState.pages.length > 0) {\r\n          // body = uiState.pages[0].compositions.map(comp => comp.html).join('');\r\n          for (let i = 1; i < uiState.pages.length; i++) {\r\n            const c = components;\r\n            if (uiState.pages[i].title === 'error') {\r\n              errorPage = uiState.pages[i].compositions.map(comp => {\r\n                if (comp.universal) {\r\n                  return c[comp.componentSemaphore as number].html;\r\n                }\r\n                return comp.html;\r\n              }).join('');\r\n              break;\r\n            }\r\n            // else if (page.title === 'index') {\r\n            //   body = page.compositions.flatMap(comp => comp.cachedHtml)[0];\r\n            // }\r\n          }\r\n          pages = uiState.pages;\r\n        }\r\n      }\r\n    });\r\n    const plan = concepts$.plan('State Sync Client Init', [\r\n      createStage((concepts, dispatch) => {\r\n        const name = getUnifiedName(concepts, semaphore);\r\n        if (name) {\r\n          dispatch(axiumRegisterStagePlanner({conceptName: name, stagePlanner: plan}), {\r\n            iterateStage: true\r\n          });\r\n        } else {\r\n          plan.conclude();\r\n        }\r\n      }),\r\n      createStage((concepts, __) => {\r\n        const state = selectUnifiedState<Record<string, unknown>>(concepts, semaphore);\r\n        if (state) {\r\n          const stateKeys = Object.keys(state);\r\n          for (const key of stateKeys) {\r\n            if (key !== 'pages' && key !== 'pageStrategies' && key !== 'pagesCached' && key !== 'currentPage' && key !== 'actionQue') {\r\n              newState[key] = state[key];\r\n            }\r\n          }\r\n        } else {\r\n          plan.conclude();\r\n        }\r\n      })\r\n    ]);\r\n\r\n    const initialServerState = selectUnifiedState(cpts, semaphore) as ServerState;\r\n    const initialFileSystemState = selectState<FileSystemState>(cpts, fileSystemName);\r\n    const server = initialServerState.server;\r\n    server.get('/', (__, res) => {\r\n      res.set({\r\n        'Cache-Control': 'no-store, must-revalidate',\r\n        'Pragma': 'no-cache',\r\n        'Expires': 0\r\n      });\r\n      let found = false;\r\n      for (const page of pages) {\r\n        if (page.title === 'index') {\r\n          const c = components;\r\n          res.send(page.compositions.map(comp => {\r\n            if (comp.universal) {\r\n              return c[comp.componentSemaphore as number].html;\r\n            }\r\n            return comp.html;\r\n          }).join(''));\r\n          found = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!found && errorPage !== undefined) {\r\n        res.send(errorPage);\r\n      } else if (!found) {\r\n        res.send(body);\r\n      }\r\n    });\r\n    server.get('/stateSync', (__, res) => {\r\n      res.json(newState);\r\n    });\r\n    server.get('/:title', (req, res) => {\r\n      res.set({\r\n        'Cache-Control': 'no-store, must-revalidate',\r\n        'Pragma': 'no-cache',\r\n        'Expires': 0\r\n      });\r\n      let found = false;\r\n      for (const page of pages) {\r\n        if (page.title === req.params.title) {\r\n          const c = components;\r\n          res.send(page.compositions.map(comp => {\r\n            if (comp.universal) {\r\n              return c[comp.componentSemaphore as number].html;\r\n            }\r\n            return comp.html;\r\n          }).join(''));\r\n          found = true;\r\n          break;\r\n        }\r\n      }\r\n      // console.log('Check', found, errorPage);\r\n      if (!found && errorPage !== undefined) {\r\n        res.send(errorPage);\r\n      } else if (!found) {\r\n        res.send('404');\r\n      }\r\n    });\r\n\r\n    let root;\r\n    if (initialFileSystemState) {\r\n      root = initialFileSystemState.root;\r\n    } else {\r\n      root = findRoot();\r\n    }\r\n    const contextPublic = path.join(root + '/context/public');\r\n    server.use('/static', (req, res, next) => {\r\n      express.static(contextPublic)(req, res, next);\r\n    });\r\n  };\r\n\r\nexport const userInterfaceServerOnChangePrinciple: PrincipleFunction =\r\n  (___: Subscriber<Action>, cpts: Concepts, concepts$: UnifiedSubject, semaphore: number) => {\r\n    const plan = concepts$.plan('User Interface Server on Change', [\r\n      createStage((concepts, dispatch) => {\r\n        console.log('INIT USER INTERFACE SERVER ON CHANGE');\r\n        const name = getUnifiedName(concepts, semaphore);\r\n        if (name && selectSlice(concepts, axiumSelectOpen) === true) {\r\n          dispatch(axiumRegisterStagePlanner({conceptName: name, stagePlanner: plan}), {\r\n            iterateStage: true\r\n          });\r\n        } else if (name === undefined) {\r\n          plan.conclude();\r\n        }\r\n      }, {selectors: [axiumSelectOpen]}),\r\n      // createStage((concepts, dispatch) => {\r\n      //   const uiState = selectUnifiedState<UserInterfaceServerState>(concepts, semaphore);\r\n      //   if (uiState && uiState.pagesCached) {\r\n      //     // console.log('PAGES: ', uiState.pages.map(page => page.title).join(', '));\r\n      //     const selectors: BoundSelectors[] = [];\r\n      //     uiState.pages.forEach(page => {\r\n      //       page.cachedSelectors.forEach(bound => {\r\n      //         bound.action.conceptSemaphore = semaphore;\r\n      //         selectors.push(bound);\r\n      //       });\r\n      //     });\r\n      //     uiState.components.forEach(comp => {\r\n      //       comp.boundSelectors.forEach(bound => {\r\n      //         bound.action.conceptSemaphore = semaphore;\r\n      //         selectors.push(bound);\r\n      //       });\r\n      //     });\r\n      //     const payload: UserInterfaceServerAssembleUpdateAtomicCompositionStrategyPayload = {\r\n      //       boundActionQue: []\r\n      //     };\r\n      //     const changes: string[] = [];\r\n      //     const changedSelectors: KeyedSelector[] = [];\r\n      //     selectors.forEach(bound => {\r\n      //       for (const ks of bound.selectors) {\r\n      //         const s = updateUnifiedKeyedSelector(concepts, semaphore, ks) as KeyedSelector;\r\n      //         const value = select.slice(concepts, s);\r\n      //         let changed = false;\r\n      //         if (typeof value !== 'object') {\r\n      //           changed = (atomicCachedState as Record<string, unknown>)[s.keys] !== value;\r\n      //         } else {\r\n      //           const object = (atomicCachedState as Record<string, unknown>)[s.keys];\r\n      //           if (object === undefined) {\r\n      //             changed = true;\r\n      //           } else {\r\n      //             changed = !Object.is(object, value);\r\n      //           }\r\n      //         }\r\n      //         if (changed) {\r\n      //           if (!changes.includes(s.keys)) {\r\n      //             changes.push(s.keys);\r\n      //             changedSelectors.push(s);\r\n      //           }\r\n      //           let exists = false;\r\n      //           for (const b of payload.boundActionQue) {\r\n      //             if (b.id === bound.id) {\r\n      //               exists = true;\r\n      //               break;\r\n      //             }\r\n      //           }\r\n      //           if (!exists) {\r\n      //             payload.boundActionQue.push(bound);\r\n      //           }\r\n      //         }\r\n      //       }\r\n      //     });\r\n      //     for (let i = 0; i < changes.length; i++) {\r\n      //       atomicCachedState[changes[i]] = selectSlice(concepts, changedSelectors[i]);\r\n      //     }\r\n      //     if (payload.boundActionQue.length > 0) {\r\n      //       dispatch(userInterfaceServerAssembleUpdateAtomicCompositionStrategy(payload), {\r\n      //         throttle: 1\r\n      //       });\r\n      //     }\r\n      //   } else if (uiState === undefined) {\r\n      //     plan.conclude();\r\n      //   }\r\n      // }, {beat: 333}),\r\n\r\n      createStage((concepts, dispatch, changes) => {\r\n        // console.log('Get unified name', getUnifiedName(concepts, semaphore));\r\n        const uiState = selectUnifiedState<UserInterfaceServerState>(concepts, semaphore);\r\n        if (uiState && uiState.pagesCached) {\r\n          const newSelectors = uiState.selectors.map(keyed => updateUnifiedKeyedSelector(concepts, semaphore, keyed) as KeyedSelector);\r\n          const changed: Record<string, boolean> = {};\r\n          const payload: UserInterfaceServerAssembleUpdateAtomicCompositionStrategyPayload = {\r\n            boundActionQue: []\r\n          };\r\n          // console.log('CHANGES: ', changes);\r\n          changes?.forEach(change => {\r\n            // const chunk = change.keys.split('Server');\r\n            // const client = chunk[0] + 'Client' + chunk[1];\r\n            const bound = uiState.boundSelectors[change.keys];\r\n            // console.log('HIT', bound, uiState.boundSelectors, chunk, client);\r\n            if (bound) {\r\n              // console.log('CHECK BOUND', bound);\r\n              bound.forEach(b => {\r\n                const exists = changed[b.semaphore.toString()];\r\n                if (exists === undefined) {\r\n                  changed[b.semaphore.toString()] = true;\r\n                  b.action.conceptSemaphore = semaphore;\r\n                  payload.boundActionQue.push(b);\r\n                }\r\n              });\r\n            }\r\n          });\r\n          // console.log('CHECK CHANGES', changes);\r\n          // console.log('CHECK UI STATE SELECTORS', uiState.selectors);\r\n          // console.log('CHECK NEW SELECTORS', newSelectors);\r\n          // console.log('CHECK BOUND SELECTORS', Object.keys(uiState.boundSelectors).map(key => {\r\n          //   return uiState.boundSelectors[key].map(b => b).map(some => `${key} ${some.semaphore}`);\r\n          // }));\r\n          // console.log('CHECK PAYLOAD', payload);\r\n          // console.log('CHECK COMPONENTS', uiState.components);\r\n          if (payload.boundActionQue.length > 0) {\r\n            // console.log('ATOMIC UPDATE', payload.boundActionQue.map(bound => bound.semaphore));\r\n            dispatch(userInterfaceServerAssembleUpdateAtomicCompositionStrategy(payload), {\r\n              throttle: 0,\r\n              newSelectors\r\n            });\r\n          } else {\r\n            dispatch(axiumKick(), {\r\n              throttle: 0,\r\n              newSelectors\r\n            });\r\n          }\r\n        } else if (uiState === undefined) {\r\n          console.log('SHOULDN\\'T CONCLUDE, unless removed');\r\n          plan.conclude();\r\n        }\r\n      }, {beat: 33}),\r\n    ]\r\n    );\r\n  };"},"For the graph programming framework Stratimux and the Web Socket Client Concept, generate a quality that will append a series of actions to that state's action que.\r\nThis action que will later be dispatch by the Web Socket Client Principle to the server.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  refreshAction,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { WebSocketClientState } from '../webSocketClient.concept';\r\n\r\nexport type WebSocketClientAppendToActionQuePayload = {\r\n  actionQue: Action[]\r\n}\r\n\r\nexport const [\r\n  webSocketClientAppendToActionQue,\r\n  webSocketClientAppendToActionQueType,\r\n  webSocketClientAppendToActionQueQuality\r\n] = createQualitySetWithPayload<WebSocketClientAppendToActionQuePayload>({\r\n  type: 'Web Socket Client append to action que',\r\n  reducer: (state: WebSocketClientState, action: Action): WebSocketClientState => {\r\n    const payload = selectPayload<WebSocketClientAppendToActionQuePayload>(action);\r\n    console.log('APPENDING TO SEND', payload);\r\n    const actionQue = state.actionQue;\r\n    payload.actionQue.forEach(act => {\r\n      actionQue.push(refreshAction(act));\r\n    });\r\n    return {\r\n      ...state,\r\n      actionQue: [\r\n        ...actionQue\r\n      ]\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and the Web Socket Client Concept, generate a quality that will force the server state to sync to client via\r\nan incoming set of keys from action payload.":{"type":"project","content":"import {\r\n  ActionStrategy,\r\n  UnifiedSubject,\r\n  createActionNode,\r\n  createMethodWithState,\r\n  createQualitySetWithPayload,\r\n  createStrategy,\r\n  nullReducer,\r\n  selectPayload,\r\n  strategyBegin,\r\n  strategyPunt,\r\n  strategySuccess,\r\n} from 'stratimux';\r\nimport { webSocketClientAppendToActionQue } from './appendActionQue.quality';\r\nimport { webSocketServerSyncClientState } from '../strategies/server/syncServerState.helper';\r\n\r\nexport type WebSocketClientForceSyncPayload = {\r\n  keys: string[]\r\n}\r\n\r\nexport const [\r\n  webSocketClientForceSync,\r\n  webSocketClientForceSyncType,\r\n  webSocketClientForceSyncQuality\r\n] = createQualitySetWithPayload<WebSocketClientForceSyncPayload>({\r\n  type: 'Web Socket Client force client sync',\r\n  reducer: nullReducer,\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  methodCreator: (concepts$, semaphore) => createMethodWithState<any>((action, state) => {\r\n    const syncState: Record<string, unknown> = {};\r\n    const {keys} = selectPayload<WebSocketClientForceSyncPayload>(action);\r\n    keys.forEach(key => {\r\n      syncState[key] = state[key];\r\n    });\r\n    const sync = createActionNode(webSocketClientAppendToActionQue({\r\n      actionQue: [webSocketServerSyncClientState({state: syncState}, {priority: 5000})]\r\n    }));\r\n    console.log('FORCE SYNC STATE', syncState);\r\n    if (action.strategy) {\r\n      return strategyBegin(strategyPunt(strategySuccess(action.strategy).strategy as ActionStrategy, createStrategy({\r\n        initialNode: sync,\r\n        topic: 'FORCE SYNC STATE',\r\n        priority: 3000\r\n      })));\r\n    } else {\r\n      return strategyBegin(createStrategy({\r\n        initialNode: sync,\r\n        topic: 'FORCE SYNC STATE',\r\n        priority: 3000\r\n      }));\r\n    }\r\n  }, concepts$ as UnifiedSubject, semaphore as number)\r\n});"},"For the graph programming framework Stratimux and the Web Socket Client Concept, generate a quality that will set the server's semaphore.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { WebSocketClientState } from '../webSocketClient.concept';\r\n\r\nexport type WebSocketClientSetServerSemaphorePayload = {\r\n  semaphore: number,\r\n}\r\n\r\nexport const [\r\n  webSocketClientSetServerSemaphore,\r\n  webSocketClientSetServerSemaphoreType,\r\n  webSocketClientSetServerSemaphoreQuality\r\n] = createQualitySetWithPayload<WebSocketClientSetServerSemaphorePayload>({\r\n  type: 'Web Socket Client set Server Semaphore',\r\n  reducer: (state: WebSocketClientState, action: Action): WebSocketClientState => {\r\n    const payload = selectPayload<WebSocketClientSetServerSemaphorePayload>(action);\r\n    console.log('SET SERVER SEMAPHORE HELLO WORLD', payload);\r\n    return {\r\n      ...state,\r\n      serverSemaphore: payload.semaphore\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and the Web Socket Client Concept, generate a helper that will the creation of an action to set the server's client semaphore property for this connection.":{"type":"project","content":"import { createAction } from 'stratimux';\r\n\r\nexport const webSocketClientSetClientSemaphore = (payload: {\r\n  semaphore: number\r\n}) => (createAction('Web Socket Server set Client Semaphore', {payload}));"},"For the graph programming framework Stratimux and the Web Socket Client Concept, generate a helper that will synchronize the server state with the client's state.":{"type":"project","content":"import { ActionOptions, createAction } from 'stratimux';\r\n\r\nexport const webSocketServerSyncClientState = (payload: { state: Record<string, unknown>\r\n}, options?: ActionOptions) => (createAction('Web Socket Server sync State to provided Client State', {payload, ...options}));"},"For the graph programming framework Stratimux generate a Web Socket Client Concept, that will create a message stream between the client and server.\r\nThis message stream should establish each governing concept's semaphore so that messages are not invalidated.":{"type":"project","content":"import { webSocketClientAppendToActionQueQuality } from './qualities/appendActionQue.quality';\r\nimport { webSocketClientForceSyncQuality } from './qualities/forceSync.quality';\r\nimport { webSocketClientSetServerSemaphoreQuality } from './qualities/setServerSemaphore.quality';\r\nimport { webSocketClientPrinciple } from './webSocketClient.principle';\r\nimport { Action, createConcept } from 'stratimux';\r\n\r\nexport type WebSocketClientState = {\r\n  actionQue: Action[],\r\n  serverSemaphore: number,\r\n};\r\n\r\nexport const webSocketClientName = 'webSocketClient';\r\n\r\nconst initialWebSocketClientState = (): WebSocketClientState => {\r\n  return {\r\n    actionQue: [],\r\n    serverSemaphore: -1\r\n  };\r\n};\r\n\r\nexport const createWebSocketClientConcept = () => {\r\n  return createConcept(\r\n    webSocketClientName,\r\n    initialWebSocketClientState(),\r\n    [\r\n      webSocketClientAppendToActionQueQuality,\r\n      webSocketClientSetServerSemaphoreQuality,\r\n      webSocketClientForceSyncQuality\r\n    ],\r\n    [webSocketClientPrinciple]\r\n  );\r\n};"},"For the graph programming framework Stratimux and the Web Socket Client Concept, generate a principle that will establish a connection with a server, and pass its semaphore.\r\nThen create a plan to notify the server of state changes, while ignoring values that would disallow this process from being halting complete.\r\nAs well as receive actions from the server, the parse and dispatch them into the client's action stream.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport {\r\n  Action,\r\n  Concepts,\r\n  KeyedSelector,\r\n  PrincipleFunction,\r\n  UnifiedSubject,\r\n  axiumKick,\r\n  axiumKickType,\r\n  axiumRegisterStagePlanner,\r\n  createStage,\r\n  getAxiumState,\r\n  getUnifiedName,\r\n  selectUnifiedState,\r\n} from 'stratimux';\r\nimport _ws from 'express-ws';\r\nimport { WebSocketClientState } from './webSocketClient.concept';\r\nimport { webSocketClientSetClientSemaphore } from './strategies/server/setClientSemaphore.helper';\r\nimport { webSocketServerSyncClientState } from './strategies/server/syncServerState.helper';\r\nimport { webSocketClient_createActionQueSelector } from './webSocketClient.selectors';\r\nimport { WebSocketServerState } from '../webSocketServer/webSocketServer.concept';\r\n\r\nconst notKeys = (key: string) => {\r\n  return (\r\n    key !== 'pages'\r\n    && key !== 'clientSemaphore'\r\n    && key !== 'serverSemaphore'\r\n    && key !== 'pageStrategies'\r\n  );\r\n};\r\n\r\nexport const webSocketClientPrinciple: PrincipleFunction =\r\n  (observer: Subscriber<Action>, cpts: Concepts, concepts$: UnifiedSubject, conceptSemaphore: number) => {\r\n    const url = 'ws://' + window.location.host + '/axium';\r\n    const ws = new WebSocket(url);\r\n    const syncState: Record<string, unknown> = {};\r\n    ws.addEventListener('open', () => {\r\n      console.log('SEND');\r\n      ws.send(JSON.stringify(webSocketClientSetClientSemaphore({semaphore: conceptSemaphore})));\r\n      const plan = concepts$.plan('Web Socket Planner', [\r\n        createStage((concepts, dispatch) => {\r\n          const name = getUnifiedName(concepts, conceptSemaphore);\r\n          if (name) {\r\n            dispatch(axiumRegisterStagePlanner({conceptName: name, stagePlanner: plan}), {\r\n              iterateStage: true\r\n            });\r\n          } else {\r\n            plan.conclude();\r\n          }\r\n        }),\r\n        createStage((concepts, __) => {\r\n          const state = selectUnifiedState<WebSocketClientState>(concepts, conceptSemaphore);\r\n          if (state) {\r\n            if (state.actionQue.length > 0) {\r\n              const que = state.actionQue;\r\n              console.log('ATTEMPTING TO SEND', que);\r\n              const emptyQue = () => {\r\n                if (que.length) {\r\n                  const action = que.shift();\r\n                  if (action) {\r\n                    console.log('SENDING', action);\r\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                    action.conceptSemaphore = (state as any).clientSemaphore;\r\n                    ws.send(JSON.stringify(action));\r\n                  }\r\n                }\r\n              };\r\n              emptyQue();\r\n            }\r\n          } else {\r\n            plan.conclude();\r\n          }\r\n        }, {beat: 3, selectors: [webSocketClient_createActionQueSelector(cpts, conceptSemaphore) as KeyedSelector]})\r\n      ]);\r\n      const planOnChange = concepts$.plan('Web Socket Server On Change', [\r\n        createStage((concepts, dispatch) => {\r\n          const name = getUnifiedName(concepts, conceptSemaphore);\r\n          if (name) {\r\n            dispatch(axiumRegisterStagePlanner({conceptName: name, stagePlanner: planOnChange}), {\r\n              iterateStage: true\r\n            });\r\n          } else {\r\n            planOnChange.conclude();\r\n          }\r\n        }),\r\n        createStage((concepts) => {\r\n          // Bucket State\r\n          const state: Record<string, unknown> = {};\r\n          const newState = selectUnifiedState<Record<string, unknown>>(concepts, conceptSemaphore);\r\n          if (newState) {\r\n            const stateKeys = Object.keys(newState);\r\n            if (Object.keys(syncState).length === 0) {\r\n              for (const key of stateKeys) {\r\n                if (notKeys(key)) {\r\n                  syncState[key] = newState[key];\r\n                  state[key] = newState[key];\r\n                }\r\n              }\r\n              ws.send(JSON.stringify(webSocketServerSyncClientState({state})));\r\n            } else {\r\n              let changed = false;\r\n              for (const key of stateKeys) {\r\n                if (\r\n                  notKeys(key) &&\r\n                  typeof newState[key] !== 'object' &&\r\n                  newState[key] !== syncState[key]\r\n                ) {\r\n                  syncState[key] = newState[key];\r\n                  state[key] = newState[key];\r\n                  changed = true;\r\n                }\r\n                else if (notKeys(key) && typeof newState[key] === 'object' && !Object.is(newState[key], syncState[key])) {\r\n                  syncState[key] = newState[key];\r\n                  state[key] = newState[key];\r\n                  changed = true;\r\n                }\r\n              }\r\n              if (changed) {\r\n                const sync = webSocketServerSyncClientState({state});\r\n                sync.conceptSemaphore = (newState as WebSocketClientState).serverSemaphore;\r\n                // console.log('CHECK SYNC', sync);\r\n                ws.send(JSON.stringify(sync));\r\n              }\r\n            }\r\n          } else {\r\n            planOnChange.conclude();\r\n          }\r\n        }, {priority: 2000}),\r\n        createStage((__, dispatch) => {\r\n          dispatch(axiumKick(), {\r\n            setStage: 1\r\n          });\r\n        }),\r\n      ]);\r\n      ws.addEventListener('close', () => {\r\n        plan.conclude();\r\n      });\r\n    });\r\n    ws.addEventListener('message', (message: any) => {\r\n      // console.log('CHECK MESSAGE', message);\r\n      if (message.data !== 'ping') {\r\n        const act = JSON.parse(message.data);\r\n        if (Object.keys(act).includes('type')) {\r\n          if (getAxiumState(cpts).logging && (act as Action).type !== axiumKickType) {\r\n            console.log('MESSAGE', (act as Action).type);\r\n          }\r\n          observer.next(act);\r\n        }\r\n      }\r\n    });\r\n  };"},"For the graph programming framework Stratimux and the brand Concept huirth, generate a series of unified selector creators that will select slices of the web socket client state.":{"type":"project","content":"import { Concepts, createUnifiedKeyedSelector  } from 'stratimux';\r\nimport { WebSocketClientState } from './webSocketClient.concept';\r\n\r\nexport const webSocketClient_createActionQueSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector<WebSocketClientState>(concepts, semaphore, 'actionQue');\r\n};"},"For the graph programming framework Stratimux and the Web Socket Server Concept, generate a quality will append a series of action to the state's action que.\r\nThis will later be dispatched by the Web Socket Server Principle to the client.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  refreshAction,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { WebSocketServerState } from '../webSocketServer.concept';\r\n\r\nexport type WebSocketServerAppendToActionQuePayload = {\r\n  actionQue: Action[]\r\n}\r\n\r\nexport const [\r\n  webSocketServerAppendToActionQue,\r\n  webSocketServerAppendToActionQueType,\r\n  webSocketServerAppendToActionQueQuality\r\n] = createQualitySetWithPayload<WebSocketServerAppendToActionQuePayload>({\r\n  type: 'Web Socket Server append to action que',\r\n  reducer: (state: WebSocketServerState, action: Action): WebSocketServerState => {\r\n    const payload = selectPayload<WebSocketServerAppendToActionQuePayload>(action);\r\n    console.log('APPENDING TO SEND', payload);\r\n    const actionQue = state.actionQue;\r\n    payload.actionQue.forEach(act => {\r\n      actionQue.push(refreshAction(act));\r\n    });\r\n    return {\r\n      ...state,\r\n      actionQue: [\r\n        ...actionQue\r\n      ]\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and the Web Socket Server Concept, generate a quality will set the client's semaphore onto the server to enable safe message passing.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { WebSocketServerState } from '../webSocketServer.concept';\r\n\r\nexport type WebSocketServerSetClientSemaphorePayload = {\r\n  semaphore: number,\r\n}\r\n\r\nexport const [\r\n  webSocketServerSetClientSemaphore,\r\n  webSocketServerSetClientSemaphoreType,\r\n  webSocketServerSetClientSemaphoreQuality\r\n] = createQualitySetWithPayload<WebSocketServerSetClientSemaphorePayload>({\r\n  type: 'Web Socket Server set Client Semaphore',\r\n  reducer: (state: WebSocketServerState, action: Action): WebSocketServerState => {\r\n    const payload = selectPayload<WebSocketServerSetClientSemaphorePayload>(action);\r\n    console.log('CHECK', action);\r\n    return {\r\n      ...state,\r\n      clientSemaphore: payload.semaphore\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux and the Web Socket Server Concept, generate a quality will synchronize the state while excluding\r\nproperties that would prevent provable termination or should be defined only by the client.":{"type":"project","content":"import {\r\n  Action,\r\n  createQualitySetWithPayload,\r\n  defaultMethodCreator,\r\n  selectPayload,\r\n} from 'stratimux';\r\nimport { WebSocketServerState } from '../webSocketServer.concept';\r\n\r\nexport type WebSocketServerSyncStatePayload = {\r\n  state: Record<string, unknown>,\r\n}\r\n\r\nexport const [\r\n  webSocketServerSyncState,\r\n  webSocketServerSyncStateType,\r\n  webSocketServerSyncStateQuality\r\n] = createQualitySetWithPayload<WebSocketServerSyncStatePayload>({\r\n  type: 'Web Socket Server sync State to provided Client State',\r\n  reducer: (state: WebSocketServerState, action: Action): WebSocketServerState => {\r\n    const payload = selectPayload<WebSocketServerSyncStatePayload>(action);\r\n    const keys = Object.keys(payload.state);\r\n    const newState: Record<string, unknown> = {};\r\n    for (const key of keys) {\r\n      if (\r\n        key !== 'serverSemaphore' &&\r\n        key !== 'clientSemaphore' &&\r\n        key !== 'pageStrategies' &&\r\n        key !== 'actionQue' &&\r\n        key !== 'boundSelectors' &&\r\n        key !== 'pages' &&\r\n        key !== 'components') {\r\n        newState[key] = payload.state[key];\r\n      }\r\n    }\r\n    return {\r\n      ...state,\r\n      ...newState\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the graph programming framework Stratimux generate a Web Socket Server Concept, that will create a message stream between the server and client.\r\nThis message stream should establish each governing concept's semaphore so that messages are not invalidated.":{"type":"project","content":"/*<$\r\nFor the graph programming framework Stratimux generate a Web Socket Server Concept, that will create a message stream between the server and client.\r\nThis message stream should establish each governing concept's semaphore so that messages are not invalidated.\r\n$>*/\r\n/*<#*/"},"For the graph programming framework Stratimux and the Web Socket Server Concept, generate a principle that will establish a connection with a client.\r\nThat will notify new client's of its own semaphore, then pass new action added to the state action que.\r\nAs well as receive actions from the client, the parse and dispatch them into the server's action stream.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport { ServerState } from '../server/server.concept';\r\nimport {\r\n  Action,\r\n  Concepts,\r\n  KeyedSelector,\r\n  PrincipleFunction,\r\n  UnifiedSubject,\r\n  axiumKick,\r\n  axiumKickType,\r\n  axiumRegisterStagePlanner,\r\n  axiumSelectOpen,\r\n  createStage,\r\n  getAxiumState,\r\n  getUnifiedName,\r\n  primeAction,\r\n  selectSlice,\r\n  selectUnifiedState,\r\n} from 'stratimux';\r\nimport _ws from 'express-ws';\r\nimport { webSocketClientSetServerSemaphore } from '../webSocketClient/qualities/setServerSemaphore.quality';\r\nimport { WebSocketServerState } from './webSocketServer.concept';\r\nimport { webSocketServerSyncStateType } from './qualities/syncState.quality';\r\nimport { webSocketServer_createActionQueSelector } from './webSocketServer.selectors';\r\n// import { webSocketServer_createActionQueSelector } from './webSocketServer.selectors';\r\n\r\n\r\n\r\nexport const webSocketServerPrinciple: PrincipleFunction =\r\n  (observer: Subscriber<Action>, cpts: Concepts, concepts$: UnifiedSubject, semaphore: number) => {\r\n    const initialServerState = selectUnifiedState(cpts, semaphore) as ServerState;\r\n    const server = initialServerState.server;\r\n    const socket = _ws(server);\r\n    let interval: undefined | NodeJS.Timer;\r\n    socket.app.ws('/axium', (ws, req) => {\r\n      const setServerSemaphoreMessage = JSON.stringify(webSocketClientSetServerSemaphore({semaphore}));\r\n      // console.log('CHECK THIS MESSAGE', setServerSemaphoreMessage);\r\n      ws.send(setServerSemaphoreMessage);\r\n      interval = setInterval(() => {\r\n        ws.send('ping');\r\n      }, 3000);\r\n      const plan = concepts$.plan('Web Socket Server Message Que Planner', [\r\n        createStage((concepts, dispatch) => {\r\n          if (selectSlice(concepts, axiumSelectOpen) === true) {\r\n            const name = getUnifiedName(concepts, semaphore);\r\n            if (name) {\r\n              dispatch(axiumRegisterStagePlanner({conceptName: name, stagePlanner: plan}), {\r\n                iterateStage: true\r\n              });\r\n            } else {\r\n              plan.conclude();\r\n            }\r\n          }\r\n        }, {selectors: [axiumSelectOpen]}),\r\n        createStage((concepts) => {\r\n          const state = selectUnifiedState<WebSocketServerState>(concepts, semaphore);\r\n          if (state) {\r\n            if (state.actionQue.length > 0) {\r\n              const que = state.actionQue;\r\n              console.log('ATTEMPTING TO SEND', que);\r\n              const emptyQue = () => {\r\n                if (que.length) {\r\n                  const action = que.shift();\r\n                  if (action) {\r\n                    console.log('SENDING', action);\r\n                    action.conceptSemaphore = (state as WebSocketServerState).clientSemaphore;\r\n                    ws.send(JSON.stringify(action));\r\n                  }\r\n                }\r\n              };\r\n              emptyQue();\r\n            }\r\n          } else {\r\n            console.log('SHOUDN\\'T CONCLUDE');\r\n            plan.conclude();\r\n          }\r\n        }, {priority: 2000, selectors: [webSocketServer_createActionQueSelector(cpts, semaphore) as KeyedSelector]})\r\n      ]);\r\n      ws.addEventListener('close', () => {\r\n        if (interval) {\r\n          clearInterval(interval);\r\n        }\r\n        plan.conclude();\r\n      });\r\n      ws.on('message', (message: any) => {\r\n        if (message.data !== 'ping') {\r\n          const act = JSON.parse(`${message}`);\r\n          // console.log('CHECK ACTION', act);\r\n          if (Object.keys(act).includes('type')) {\r\n            if ((act as Action).type !== webSocketServerSyncStateType) {\r\n              if (getAxiumState(cpts).logging && (act as Action).type !== axiumKickType) {\r\n                console.log('MESSAGE', (act as Action).type);\r\n              }\r\n            }\r\n            act.conceptSemaphore = semaphore;\r\n            observer.next(act);\r\n          }\r\n        }\r\n      });\r\n    });\r\n  };"},"For the graph programming framework Stratimux and the brand Concept huirth, generate a series of unified selector creators that will select slices of the web socket server state.":{"type":"project","content":"import { Concepts, createUnifiedKeyedSelector  } from 'stratimux';\r\nimport { WebSocketServerState } from './webSocketServer.concept';\r\n\r\nexport const webSocketServer_createActionQueSelector = (concepts: Concepts, semaphore: number) => {\r\n  return createUnifiedKeyedSelector<WebSocketServerState>(concepts, semaphore, 'actionQue');\r\n};"},"For the graph programming framework Stratimux, generate a index file for a branded project huirth that utilizes the Stratimux advanced project template to formalize a unified application.":{"type":"project","content":"import { createAxium, unifyConcepts } from 'stratimux';\r\nimport { createFileSystemConcept } from './concepts/fileSystem/fileSystem.concept';\r\nimport { createHuirthConcept } from './concepts/huirth/huirth.concept';\r\n\r\nimport { argv } from 'process';\r\nimport {\r\n  commandLineInterfaceDetermineGoal,\r\n  commandLineInterfaceDeterminePort,\r\n  commandLineInterfaceGoals\r\n} from './model/commandLineInterface';\r\nimport { createUserInterfaceServerConcept } from './concepts/userInterfaceServer/userInterfaceServer.concept';\r\nimport { createHuirthServerConcept } from './concepts/huirthServer/huirthServer.concept';\r\n\r\n(() => {\r\n  const goal = commandLineInterfaceDetermineGoal(argv);\r\n  const port = commandLineInterfaceDeterminePort(argv);\r\n  console.log('GOAL', goal);\r\n  switch (goal) {\r\n  case commandLineInterfaceGoals.simulate: {\r\n    createAxium(`axium ${goal} huirth`, [\r\n      createUserInterfaceServerConcept(goal, {\r\n        concept: unifyConcepts([createHuirthServerConcept()], createHuirthConcept()),\r\n      }, port),\r\n    ], {\r\n      logging: true,\r\n      storeDialog: true,\r\n      // logActionStream: true\r\n    });\r\n    break;\r\n  }\r\n  default: {\r\n    createAxium(`axium ${goal} huirth`, [\r\n      createUserInterfaceServerConcept(goal, {\r\n        concept: unifyConcepts([createHuirthServerConcept()], createHuirthConcept()),\r\n      }, port),\r\n      createFileSystemConcept()\r\n    ], {\r\n      logging: true,\r\n      storeDialog: true,\r\n      // logActionStream: true\r\n    });\r\n    break;\r\n  }\r\n  }\r\n})();"},"For the graph programming framework Stratimux, define a model file that defines a consumer function that returns a most optimum route from a strategy via its line of success.":{"type":"project","content":"import { ActionNode } from 'stratimux';\r\n\r\nexport const listNodeSuccess = (node: ActionNode): string[] => {\r\n  const currentType = node.actionType;\r\n  if (node.successNode !== null) {\r\n    return [\r\n      currentType,\r\n      ...listNodeSuccess(node.successNode)\r\n    ];\r\n  } else {\r\n    return [currentType];\r\n  }\r\n};"},"For the graph programming framework Stratimux and the huirth Project, generate a model for a command line interface that would handle incoming arguments passed upon the processes creation.":{"type":"project","content":"const GOAL = '--goal';\r\nconst PORT = '--port';\r\n\r\n// eslint-disable-next-line no-shadow\r\nexport enum commandLineInterfaceGoals {\r\n  simulate = 'simulate',\r\n  staticDeployment = 'staticDeployment',\r\n  dynamicDeployment = 'dynamicDeployment',\r\n  none = 'none'\r\n}\r\n\r\nexport const commandLineInterfaceDetermineGoal = (args: string[]): commandLineInterfaceGoals => {\r\n  let start = false;\r\n  console.log('CHECK ARGS', args);\r\n  for (const arg of args) {\r\n    if (!start && arg === GOAL) {\r\n      start = true;\r\n    } else if (start && arg.indexOf('--') === -1) {\r\n      // console.log('Checked arg', arg);\r\n      switch (arg) {\r\n      case commandLineInterfaceGoals.simulate: {\r\n        return commandLineInterfaceGoals.simulate;\r\n      }\r\n      case commandLineInterfaceGoals.staticDeployment: {\r\n        return commandLineInterfaceGoals.staticDeployment;\r\n      }\r\n      case commandLineInterfaceGoals.dynamicDeployment: {\r\n        return commandLineInterfaceGoals.dynamicDeployment;\r\n      }\r\n      default: {\r\n        return commandLineInterfaceGoals.none;\r\n      }\r\n      }\r\n    }\r\n  }\r\n  return commandLineInterfaceGoals.none;\r\n};\r\n\r\nexport const commandLineInterfaceDeterminePort = (args: string[]): number => {\r\n  let start = false;\r\n  for (const arg of args) {\r\n    if (!start && arg === PORT) {\r\n      start = true;\r\n    } else if (start && arg.indexOf('--') === -1) {\r\n      const possiblePort = Number(arg);\r\n      if (!Number.isNaN(possiblePort)) {\r\n        return 7637;\r\n      } else {\r\n        return possiblePort;\r\n      }\r\n    }\r\n  }\r\n  return 7637;\r\n};"},"For the graph programming framework Stratimux and the huirth Project, generate a model for to contain the function used to create the context index.ts file.":{"type":"project","content":"import { userInterfaceClientName } from '../concepts/userInterfaceClient/userInterfaceClient.concept';\r\nimport { PrimedConceptAndProperties } from './userInterface';\r\n\r\nexport function createContextIndexContent(primedConcepts: PrimedConceptAndProperties[], directoryMap: string[]): string {\r\n  const axiumImports = ['createAxium'];\r\n  let conceptImports = createConceptImportTemplates(primedConcepts);\r\n  primedConcepts.forEach(concept => {\r\n    let found = false;\r\n    for (const directory of directoryMap) {\r\n      if (directory === concept.name) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!found) {\r\n      axiumImports.push(`create${concept.nameCapitalized}Concept`);\r\n    }\r\n    if (concept.name === userInterfaceClientName && concept.properties?.length === 2) {\r\n      const brand = concept.properties[1];\r\n      const nameCapitalized = brand[0].toUpperCase() + brand.substring(1);\r\n      conceptImports += createConceptImportTemplates([{\r\n        name: brand,\r\n        nameCapitalized,\r\n      }]) + '\\n';\r\n      concept.properties[1] = `create${nameCapitalized}Concept`;\r\n    }\r\n  });\r\n  const creators =\r\n    createConceptCreatorTemplates(primedConcepts);\r\n  const content = /*typescript*/\r\n`/*$ Start template imports $*/\r\nimport { ${axiumImports.join(', ')} } from 'stratimux';\r\n${conceptImports}\r\n/*$ End template imports $*/\r\n\r\n(() => {\r\n  /*$ Start context template code $*/\r\n  let init = false;\r\n  let state: Record<string, unknown> | undefined;\r\n  fetch(window.location.protocol + '//' + window.location.host + '/stateSync').then(response => {\r\n    response.json().then(value => {\r\n      state = value;\r\n      // console.log('FETCH SYNC STATE', state);\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const simmer = (func: ((s?: any) => void)) => {\r\n        setTimeout(() => {\r\n          if (init && state) {\r\n            createAxium(\r\n              'contextAxium',\r\n              [createDocumentObjectModelConcept({}), createUserInterfaceClientConcept(state, createHuirthConcept)],\r\n              {\r\n                logging: true,\r\n                storeDialog: true,\r\n              });\r\n          } else {\r\n            func();\r\n          }\r\n        }, 100);\r\n      };\r\n      simmer(simmer);\r\n    });\r\n  });\r\n  document.onreadystatechange = () => {\r\n    if (!init) {\r\n      init = true;\r\n    }\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  window.onunload = function(){}; \r\n  console.log('AXIUM INIT');\r\n  /*$ End context template code $*/\r\n})();\r\n`;\r\n  return content;\r\n}\r\n\r\nfunction createConceptImportTemplates(concepts: PrimedConceptAndProperties[]): string {\r\n  return concepts.map(concept => createConceptImport(concept)).join('\\n');\r\n}\r\n\r\nfunction createConceptImport(concept: PrimedConceptAndProperties): string {\r\n  return `import { create${concept.nameCapitalized}Concept } from './concepts/${concept.name}/${concept.name}.concept';`;\r\n}\r\n\r\nfunction createConceptCreatorTemplates(concepts: PrimedConceptAndProperties[]): string {\r\n  return concepts.map(concept => {\r\n    return createConceptCreator(concept);\r\n  }).join(',\\n\\t\\t');\r\n}\r\n\r\nfunction createConceptCreator(concept: PrimedConceptAndProperties): string {\r\n  if (concept.properties) {\r\n    const props = concept.properties.join(', ');\r\n    return `create${concept.nameCapitalized}Concept(${props})`;\r\n  } else {\r\n    return `create${concept.nameCapitalized}Concept()`;\r\n  }\r\n}"},"For the graph programming framework Stratimux and the huirth Project, generate a model that would contain the function that would determine the root of the huirth Project.":{"type":"project","content":"import path from 'path';\r\n\r\nexport const findRoot = () => {\r\n  const forwardSlash = process.cwd().split('/');\r\n  const backSlash = process.cwd().split('\\\\');\r\n  const possibleRoot = forwardSlash.length > backSlash.length ? forwardSlash : backSlash;\r\n  const root = [];\r\n  for (let i = 0; i < possibleRoot.length; i++) {\r\n    if (possibleRoot[i] !== 'server' && possibleRoot[i] !== 'context') {\r\n      console.log('Possible root', possibleRoot[i]);\r\n      root.push(possibleRoot[i]);\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n  return path.join(root.join('/'));\r\n};"},"For the graph programming framework Stratimux and the huirth Project, generate a model that contains an enum that contains all document object model \"on\" element bindings.":{"type":"project","content":"/**\r\n * @WindowEvents\r\n * 'onafterprint' |'onbeforeprint' | 'onbeforeupload' | 'onerror' | 'onhashchange' | 'onload' | 'onmessage' |\r\n * 'onoffline' | 'ononline' | 'onpagehide' | 'onpageshow' | 'onpopstate' | 'onresize' | 'onunload' |\r\n * @FormEvents\r\n * 'onblur' | 'onchange' | 'oncontextmenu' | 'onfocus' | 'oninput' | 'oninvalid' | 'onreset' | 'onsearch' | 'onselect' | 'onsubmit' |\r\n * @KeyboardEvents\r\n * 'onkeydown' | 'onkeypress' | 'onkeyup' |\r\n * @MouseEvents\r\n * 'onclick' | 'ondblclick' | 'onmousedown' | 'onmouseout' | 'onmouseover' | 'onmouseup' | 'onwheel' |\r\n * @DragEvents\r\n * 'ondrag' | 'ondragend' | 'ondragenter' | 'ondragleave' | 'ondragover' | 'ondrop' | 'onscroll' |\r\n * @ClipboardEvents\r\n * 'oncopy' | 'oncut' | 'onpaste' |\r\n * @MediaEvents\r\n * 'onabort' | 'oncanplay' | 'oncanplaythrough' | 'oncuechange' | 'ondurationchange' | 'onemptied' | 'onended' | 'onerror' | 'onloadeddata'|\r\n * 'onloadedmetadata' | 'onloadstart' | 'onpause' | 'onplaying' | 'onprogress' | 'onratechange' | 'onseeked' | 'onseeking' | 'onstalled' |\r\n * 'onsuspend' | 'ontimeupdate' | 'onvolumechange' | 'onwaiting' |\r\n * @MiscEvents\r\n * 'ontoggle'\r\n */\r\n// eslint-disable-next-line no-shadow\r\nexport enum elementEventBinding {\r\n  onafterprint = 'onafterprint',\r\n  onbeforeprint = 'onbeforeprint',\r\n  onhashchange = 'onhashchange',\r\n  onload = 'onload',\r\n  onmessage = 'onmessage',\r\n  onoffline = 'onoffline',\r\n  ononline = 'ononline',\r\n  onpagehide = 'onpagehide',\r\n  onpageshow = 'onpageshow',\r\n  onpopstate = 'onpopstate',\r\n  onresize = 'onresize',\r\n  onunload = 'onunload',\r\n  onblur = 'onblur',\r\n  onchange = 'onchange',\r\n  oncontextmenu = 'oncontextmenu',\r\n  onfocus = 'onfocus',\r\n  oninput = 'oninput',\r\n  onreset = 'onreset',\r\n  // onsearch = 'onsearch',\r\n  onsubmit = 'onsubmit',\r\n  onkeydown = 'onkeydown',\r\n  // onkeypress = 'onkeypress',\r\n  onkeyup = 'onkeyup',\r\n  onclick = 'onclick',\r\n  ondblclick = 'ondblclick',\r\n  onmousedown = 'onmousedown',\r\n  onmouseout = 'onmouseout',\r\n  onmouseup = 'onmouseup',\r\n  onwheel = 'onwheel',\r\n  ondrag = 'ondrag',\r\n  ondragend = 'ondragend',\r\n  ondragenter = 'ondragenter',\r\n  ondragover = 'ondragover',\r\n  ondrop = 'ondrop',\r\n  onscroll = 'onscroll',\r\n  oncopy = 'oncopy',\r\n  oncut = 'oncut',\r\n  onpaste = 'onpaste',\r\n  onabort = 'onabort',\r\n  oncanplay = 'oncanplay',\r\n  oncanplaythrough = 'oncanplaythrough',\r\n  oncuechange = 'oncuechange',\r\n  ondurationchange = 'ondurationchange',\r\n  onemptied = 'onemptied',\r\n  onended = 'onended',\r\n  onerror = 'onerror',\r\n  onloadeddata = 'onloadeddata',\r\n  onloadedmetadata = 'onloadedmetadata',\r\n  onloadstart = 'onloadstart',\r\n  onpause = 'onpause',\r\n  onplaying = 'onplaying',\r\n  onprogress = 'onprogress',\r\n  onratechange = 'onratechange',\r\n  onseeked = 'onseeked',\r\n  onseeking = 'onseeking',\r\n  onstalled = 'onstalled',\r\n  onsuspend = 'onsuspend',\r\n  ontimeupdate = 'ontimeupdate',\r\n  onvolumechange = 'onvolumechange',\r\n  onwaiting = 'onwaiting',\r\n  ontoggle = 'ontoggle'\r\n}"},"For the graph programming framework Stratimux and the huirth Project, generate a model that contains the type definitions for the DPO Dataset":{"type":"project","content":"export type DPO = {\r\n  chosen: [{\r\n    content: string\r\n  }],\r\n  rejected: [{\r\n    content: string\r\n  }]\r\n}\r\nexport type DataSet<T> = Record<string, T>;\r\nexport type DPO_DataSet = DataSet<DPO>;"},"For the graph programming framework Stratimux and the huirth Project, generate a test to ensure that the file system is loaded and working as intended.":{"type":"project","content":"import { Concepts, axiumSelectOpen, createAxium, createStage, selectSlice, selectState, strategyBegin } from 'stratimux';\r\nimport { FileSystemState, createFileSystemConcept, fileSystemName } from '../concepts/fileSystem/fileSystem.concept';\r\nimport {\r\n  userInterfaceServerSetConceptDirectoriesFromDataStrategy\r\n} from '../concepts/userInterfaceServer/strategies/setConceptDirectories.strategy';\r\n\r\nfunction selectUnifiedState<T>(concepts: Concepts, semaphore: number): T | undefined {\r\n  const exists = Object.keys(concepts).includes(`${semaphore}`);\r\n  if (exists) {\r\n    return concepts[semaphore].state as T;\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\ntest('FileSystem get Concept Directory Test', (done) => {\r\n  const axium = createAxium('axiumStrategyTest', [\r\n    createFileSystemConcept()\r\n  ]);\r\n  const plan = axium.plan('File System Map Concept Directory Test', [\r\n    createStage((concepts, dispatch) => {\r\n      console.log('CHECK UNIFIED', selectUnifiedState(concepts, 2));\r\n      if (selectSlice(concepts, axiumSelectOpen) === true) {\r\n        const fileSystemState = selectState(concepts, fileSystemName) as FileSystemState;\r\n        dispatch(strategyBegin(userInterfaceServerSetConceptDirectoriesFromDataStrategy(fileSystemState.root)), {\r\n          iterateStage: true,\r\n        });\r\n      }\r\n    }, {selectors: [axiumSelectOpen]}),\r\n    createStage((concepts) => {\r\n      const fileSystemState = selectState(concepts, fileSystemName) as FileSystemState;\r\n      if (fileSystemState.conceptDirectoryMap.length > 1) {\r\n        expect(fileSystemState.conceptDirectoryMap.length).toBe(12);\r\n        console.log('CHECK MAP FORMAT', fileSystemState.conceptDirectoryMap);\r\n        setTimeout(() => {\r\n          done();\r\n        }, 1000);\r\n        plan.conclude();\r\n      }\r\n    })\r\n  ]);\r\n});"},"For the graph programming framework Stratimux and the huirth Project, generate a model that outputs the toString function for UserInterfacePageBindings.":{"type":"project","content":"import { UserInterfacePageBindings, userInterface_pageBindingsToString } from '../model/userInterface';\r\nimport { elementEventBinding } from '../model/html';\r\nimport { axiumLog } from 'stratimux';\r\n\r\ntest('userInterfaceBindingsToString', (done) => {\r\n  const testBindingToString: UserInterfacePageBindings = {\r\n    'somePage': {\r\n      'something': [\r\n        {\r\n          action: axiumLog(),\r\n          eventBinding: elementEventBinding.onclick\r\n        },\r\n        {\r\n          action: {\r\n            type: 'someAction',\r\n            expiration: Date.now() + 5000,\r\n            semaphore: [-1, -1, -1, -1],\r\n          },\r\n          eventBinding: elementEventBinding.onabort\r\n        }\r\n      ]\r\n    }\r\n  };\r\n  console.log('TEST BINDING TO STRING', userInterface_pageBindingsToString(testBindingToString));\r\n  done();\r\n});"},"For the graph programming framework Stratimux and the huirth Project, generate a test to output the current project root.":{"type":"project","content":"import { findRoot } from '../model/findRoot';\r\n\r\ntest('FileSystem get Concept Directory Test', (done) => {\r\n  console.log('Process CWD: ', process.cwd());\r\n  console.log('Possible Root: ', findRoot());\r\n  done();\r\n});"}}