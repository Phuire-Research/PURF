{"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a principle that will manage the Axium's close process.":{"type":"project","content":"export const axiumClosePrinciple: PrincipleFunction = (\r\n  _: Subscriber<Action>,\r\n  __: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  let init = false;\r\n  const plan = concepts$.innerPlan('Plan Axium Close', [\r\n    createStage((concepts, dispatch) => {\r\n      const state = selectUnifiedState<AxiumState>(concepts, semaphore);\r\n      if (!init && state?.prepareClose) {\r\n        init = true;\r\n        concepts$.next({0: concepts[0]});\r\n        dispatch(axiumClose({exit: state.exit}), {\r\n          iterateStage: true\r\n        });\r\n        plan.conclude();\r\n      }\r\n    }, { selectors: [axiumSelectPrepareClose], priority: Infinity}),\r\n    createStage(() => {\r\n      //\r\n    })\r\n  ]);\r\n};"},"For the asynchronous graph programming framework Stratimux generate the Axium Concept that will manage Stratimux's functionality.\r\nThe Axium is a set of concepts that create a greater whole via their associations\r\nwithin strategies, plans, modes, qualities, and principles.":{"type":"project","content":"import { Subject, Subscription } from 'rxjs';\r\nimport { Concept, Concepts } from '../../model/concept';\r\nimport { Action } from '../../model/action';\r\nimport { axiumPrinciple } from './axium.principle';\r\nimport { axiumClosePrinciple } from './axium.close.principle';\r\nimport { blockingMode, permissiveMode } from './axium.mode';\r\nimport { axiumOpenQuality } from './qualities/open.quality';\r\nimport { axiumBadActionQuality } from './qualities/badAction.quality';\r\nimport { axiumCloseQuality } from './qualities/close.quality';\r\nimport { axiumLogQuality } from './qualities/log.quality';\r\nimport { axiumRegisterSubscriberQuality } from './qualities/registerSubscription.quality';\r\nimport { axiumInitializePrinciplesQuality } from './qualities/initializePrinciples.quality';\r\nexport { initializationStrategy } from './strategies/initialization.strategy';\r\nimport { axiumSetBlockingModeQuality } from './qualities/setBlockingMode.quality';\r\nimport { axiumSetDefaultModeQuality } from './qualities/setDefaultMode.quality';\r\nimport { axiumAddConceptsFromQueQuality } from './qualities/addConceptsFromQue.quality';\r\nimport { axiumAppendConceptsToAddQueQuality } from './qualities/appendConceptsToAddQue.quality';\r\nimport { axiumAppendConceptsToRemoveQueQuality } from './qualities/appendConceptsToRemoveQue.quality';\r\nimport { axiumRemoveConceptsViaQueQuality } from './qualities/removeConceptsViaQue.quality';\r\nimport { axiumAppendActionListToDialogQuality } from './qualities/appendActionListToDialog.quality';\r\nimport { createConcept } from '../../model/concept';\r\nimport { axiumSetModeQuality } from './qualities/setMode.quality';\r\nimport { axiumSetDefaultModeIndexQuality } from './qualities/setDefaultModeIndex.quality';\r\nimport { axiumClearDialogQuality } from './qualities/clearDialog.quality';\r\nimport { NamedStagePlanner, Plan, UnifiedSubject } from '../../model/stagePlanner';\r\nimport { axiumClearBadActionTypeFromBadActionListQuality } from './qualities/clearBadActionTypeFromBadActionList.quality';\r\nimport { axiumClearBadStrategyTopicFromBadActionListQuality } from './qualities/clearBadStrategyTopicFromBadActionList.quality';\r\nimport { axiumClearBadPlanFromBadPlanListQuality } from './qualities/clearBadPlanFromBadPlanList.quality';\r\nimport { axiumRegisterStagePlannerQuality } from './qualities/registerStagePlanner.quality';\r\nimport { axiumKickQuality } from './qualities/kick.quality';\r\nimport { axiumPreCloseQuality } from './qualities/preClose.quality';\r\nimport { axiumStitchQuality } from './qualities/stitch.quality';\r\n\r\nexport type NamedSubscription = {\r\n  name: string;\r\n  subscription: Subscription;\r\n}\r\n\r\nexport type AxiumState = {\r\n  // Would be unique identifier on a network\r\n  name: string;\r\n  open: boolean;\r\n  prepareClose: boolean;\r\n  exit: boolean;\r\n  conceptCounter: number;\r\n  logging: boolean;\r\n  logActionStream: boolean;\r\n  dialog: string;\r\n  storeDialog: boolean;\r\n  lastStrategy: string;\r\n  lastStrategyData: unknown;\r\n  lastStrategyDialog: string;\r\n  generation: number;\r\n  cachedSemaphores: Map<string,Map<string,[number,number,number, number]>>\r\n  modeIndex: number;\r\n  defaultModeIndex: number;\r\n  modeNames: string[]\r\n  methodSubscribers: NamedSubscription[];\r\n  principleSubscribers: NamedSubscription[];\r\n  generalSubscribers: NamedSubscription[];\r\n  stagePlanners: NamedStagePlanner[];\r\n  action$: Subject<Action>;\r\n  actionConcepts$: Subject<Concepts>;\r\n  concepts$: UnifiedSubject;\r\n  addConceptQue: Concept[],\r\n  removeConceptQue: Concept[],\r\n  badPlans: Plan[];\r\n  badActions: Action[];\r\n}\r\n\r\nexport const axiumName = 'axium';\r\n\r\nconst createAxiumState = (name: string, storeDialog?: boolean, logging?: boolean, logActionStream?: boolean): AxiumState => {\r\n  return {\r\n    name,\r\n    open: false,\r\n    prepareClose: false,\r\n    exit: false,\r\n    conceptCounter: 0,\r\n    logging: logging ? logging : false,\r\n    logActionStream: logActionStream ? logActionStream : false,\r\n    dialog: '',\r\n    storeDialog: storeDialog ? storeDialog : false,\r\n    lastStrategy: '',\r\n    lastStrategyData: '',\r\n    lastStrategyDialog: '',\r\n    generation: 0,\r\n    cachedSemaphores: new Map<string, Map<string, [number, number, number, number]>>(),\r\n    modeIndex: 0,\r\n    defaultModeIndex: 1,\r\n    modeNames: [axiumName, axiumName],\r\n    methodSubscribers: [] as NamedSubscription[],\r\n    principleSubscribers: [] as NamedSubscription[],\r\n    generalSubscribers: [] as NamedSubscription[],\r\n    stagePlanners: [] as NamedStagePlanner[],\r\n    action$: new Subject<Action>(),\r\n    actionConcepts$: new Subject<Concepts>(),\r\n    concepts$: new UnifiedSubject(),\r\n    addConceptQue: [] as Concept[],\r\n    removeConceptQue: [] as Concept[],\r\n    badPlans: [],\r\n    badActions: []\r\n  };\r\n};\r\n\r\nexport const createAxiumConcept = (name: string, storeDialog?: boolean, logging?: boolean, logActionStream?: boolean): Concept =>  {\r\n  return createConcept(\r\n    axiumName,\r\n    createAxiumState(name, storeDialog, logging, logActionStream),\r\n    [\r\n      axiumKickQuality,\r\n      axiumOpenQuality,\r\n      axiumBadActionQuality,\r\n      axiumCloseQuality,\r\n      axiumPreCloseQuality,\r\n      axiumAppendActionListToDialogQuality,\r\n      axiumClearDialogQuality,\r\n      axiumLogQuality,\r\n      axiumRegisterSubscriberQuality,\r\n      axiumRegisterStagePlannerQuality,\r\n      axiumInitializePrinciplesQuality,\r\n      axiumSetBlockingModeQuality,\r\n      axiumSetDefaultModeQuality,\r\n      axiumSetDefaultModeIndexQuality,\r\n      axiumAddConceptsFromQueQuality,\r\n      axiumAppendConceptsToAddQueQuality,\r\n      axiumAppendConceptsToRemoveQueQuality,\r\n      axiumRemoveConceptsViaQueQuality,\r\n      axiumSetModeQuality,\r\n      axiumClearBadActionTypeFromBadActionListQuality,\r\n      axiumClearBadStrategyTopicFromBadActionListQuality,\r\n      axiumClearBadPlanFromBadPlanListQuality,\r\n      axiumStitchQuality\r\n    ],\r\n    [axiumPrinciple, axiumClosePrinciple],\r\n    [blockingMode, permissiveMode]\r\n  );\r\n};"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate the two default modes required for the Axium to function.":{"type":"project","content":"import { Subject } from 'rxjs';\r\nimport { Concepts, Mode } from '../../model/concept';\r\nimport { Action, primeAction } from '../../model/action';\r\nimport { AxiumState } from './axium.concept';\r\nimport { UnifiedSubject } from '../../model/stagePlanner';\r\nimport { AxiumBadActionPayload } from './qualities/badAction.quality';\r\n\r\nexport const isActionable = (axiumState: AxiumState, action: Action): boolean => {\r\n  let actionable = true;\r\n  // We are logically determining these semaphore values by hand for now.\r\n  if (\r\n    // Logical Determination: axiumBadActionType\r\n    action.semaphore[3] === 1 ||\r\n    // Logical Determination: axiumConcludeType\r\n    action.semaphore[3] === 3) {\r\n    actionable = false;\r\n    if (axiumState.logging && action.semaphore[3] === 1) {\r\n      console.warn('Bad Action', action);\r\n    }\r\n  }\r\n  return actionable;\r\n};\r\n\r\nexport const permissiveMode: Mode = (\r\n  [action, concepts, action$, concepts$] : [Action, Concepts, Subject<Action>, UnifiedSubject]\r\n) => {\r\n  const axiumState = concepts[0].state as AxiumState;\r\n  if (isActionable(axiumState, action)) {\r\n    // Logical Determination: axiumSetBlockingModeType\r\n    if (action.semaphore[3] !== 4) {\r\n      if (action.semaphore[2] === axiumState.generation && action.expiration > Date.now()) {\r\n        let subject: Subject<Action>;\r\n        if (concepts[action.semaphore[0]].qualities[action.semaphore[1]].method) {\r\n          subject = concepts[action.semaphore[0]].qualities[action.semaphore[1]].subject as Subject<Action>;\r\n          subject.next(action);\r\n        }\r\n        const reduce = concepts[action.semaphore[0]].qualities[action.semaphore[1]].reducer;\r\n        const state = {...concepts[action.semaphore[0]].state};\r\n        const newState = reduce(state, action);\r\n        if (newState !== null) {\r\n          const newConcepts = {...concepts};\r\n          const newConcept = {...newConcepts[action.semaphore[0]]};\r\n          newConcepts[action.semaphore[0]] = newConcept;\r\n          newConcepts[action.semaphore[0]].state = newState;\r\n          axiumState.actionConcepts$.next(newConcepts);\r\n          concepts$.next(newConcepts);\r\n        }\r\n      } else {\r\n        const nextAction = primeAction(concepts, action);\r\n        // Logical Determination: axiumBadActionType\r\n        if (nextAction.semaphore[3] === 1) {\r\n          const payload: AxiumBadActionPayload = {badActions: [action]};\r\n          nextAction.payload = payload;\r\n        }\r\n        if (nextAction.semaphore[2] === axiumState.generation) {\r\n          action$.next(nextAction);\r\n        }\r\n      }\r\n    } else {\r\n      blockingMode([action, concepts, action$, concepts$]);\r\n    }\r\n  }\r\n};\r\n\r\n// Note that Methods are altered during this Mode if the Axium is created in a Synchronous Context\r\n//  Thus the Reducer needs to Run before the Method\r\nexport const blockingMode: Mode = (\r\n  [action, concepts, action$, concepts$] : [Action, Concepts, Subject<Action>, UnifiedSubject]\r\n) => {\r\n  const axiumState = concepts[0].state as AxiumState;\r\n  if (isActionable(axiumState, action)) {\r\n    if (action.semaphore[2] === axiumState.generation && action.expiration > Date.now()) {\r\n      const reduce = concepts[action.semaphore[0]].qualities[action.semaphore[1]].reducer;\r\n      const state = {...concepts[action.semaphore[0]].state};\r\n      const newState = reduce(state, action);\r\n      if (newState !== null) {\r\n        const newConcepts = {...concepts};\r\n        const newConcept = {...newConcepts[action.semaphore[0]]};\r\n        newConcepts[action.semaphore[0]] = newConcept;\r\n        newConcepts[action.semaphore[0]].state = newState;\r\n        axiumState.actionConcepts$.next(newConcepts);\r\n        axiumState.concepts$.nextBlocking(newConcepts);\r\n      }\r\n      let subject: Subject<Action>;\r\n      if (concepts[action.semaphore[0]].qualities[action.semaphore[1]].method) {\r\n        subject = concepts[action.semaphore[0]].qualities[action.semaphore[1]].subject as Subject<Action>;\r\n        subject.next(action);\r\n      }\r\n    } else {\r\n      const nextAction = primeAction(concepts, action);\r\n      // Logical Determination: axiumBadActionType\r\n      if (nextAction.semaphore[3] === 1) {\r\n        const payload = {...action};\r\n        nextAction.payload = payload;\r\n      }\r\n      if (nextAction.semaphore[2] === axiumState.generation) {\r\n        blockingMode([\r\n          nextAction,\r\n          concepts,\r\n          action$,\r\n          concepts$\r\n        ]);\r\n      }\r\n    }\r\n  }\r\n};"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a principle that will allow for the modification of the Axium's loaded concepts.":{"type":"project","content":"import { Observable, Subject, Subscriber, catchError } from 'rxjs';\r\nimport { Concepts, Mode, forEachConcept, qualityToString } from '../../model/concept';\r\nimport { PrincipleFunction, createPrinciple$ } from '../../model/principle';\r\nimport { Action, createCacheSemaphores } from '../../model/action';\r\nimport { AxiumState, axiumName } from './axium.concept';\r\nimport { createActionNode, strategy, strategyBegin } from '../../model/actionStrategy';\r\nimport { addConceptsFromQueThenUnblockStrategy } from './strategies/addConcept.strategy';\r\nimport { removeConceptsViaQueThenUnblockStrategy } from './strategies/removeConcept.strategy';\r\nimport { blockingMode, permissiveMode } from './axium.mode';\r\nimport { UnifiedSubject, createStage } from '../../model/stagePlanner';\r\nimport { blockingMethodSubscription, getAxiumState } from '../../model/axium';\r\nimport { axiumSelectAddConceptQue, axiumSelectRemoveConceptQue } from './axium.selector';\r\nimport { axiumRegisterStagePlanner } from './qualities/registerStagePlanner.quality';\r\n\r\nexport const axiumPrinciple: PrincipleFunction = (\r\n  observer: Subscriber<Action>,\r\n  concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  let allowAdd = true;\r\n  let allowRemove = true;\r\n  const addConceptsPlan = concepts$.innerPlan('Add Concepts Plan', [\r\n    createStage((_concepts, dispatch) => {\r\n      const axiumState = _concepts[0].state as AxiumState;\r\n      if (axiumState.addConceptQue.length === 0) {\r\n        allowAdd = true;\r\n      }\r\n      if (axiumState.addConceptQue.length !== 0 && allowAdd) {\r\n        allowAdd = false;\r\n        axiumState.generation += 1;\r\n        const newConcepts: Concepts = {};\r\n        forEachConcept(concepts, (concept, s) => {\r\n          newConcepts[Number(s)] = concept;\r\n        });\r\n\r\n        axiumState.addConceptQue.forEach((concept, _index) => {\r\n          concept.semaphore = axiumState.conceptCounter;\r\n          if (concept.mode !== undefined) {\r\n            const names = axiumState.modeNames;\r\n            const modes = concepts[0].mode as Mode[];\r\n            concept.mode.forEach((mode: Mode) => {\r\n              modes.push(mode);\r\n              names.push(concept.name);\r\n            });\r\n          }\r\n          if (concept.principles !== undefined) {\r\n            concept.principles.forEach(principle => {\r\n              const observable = createPrinciple$(principle, concepts, axiumState.concepts$, concept.semaphore);\r\n              axiumState.principleSubscribers.push({\r\n                name: concept.name,\r\n                subscription: observable.subscribe((action: Action) => axiumState.action$.next(action)) as Subscriber<Action>\r\n              });\r\n            });\r\n          }\r\n          concept.qualities.forEach(quality => {\r\n            if (quality.methodCreator) {\r\n              [quality.method, quality.subject] = quality.methodCreator(getAxiumState(concepts).concepts$, concept.semaphore);\r\n              quality.method.pipe(\r\n                catchError((err: unknown, caught: Observable<Action>) => {\r\n                  if (getAxiumState(concepts).logging) {\r\n                    console.error('METHOD ERROR', err);\r\n                  }\r\n                  return caught;\r\n                }));\r\n              quality.toString = qualityToString(quality);\r\n              const methodSub = quality.method.subscribe((act: Action) => {\r\n                const action$ = getAxiumState(concepts).action$ as Subject<Action>;\r\n                blockingMethodSubscription(action$, act);\r\n              }) as Subscriber<Action>;\r\n              getAxiumState(concepts).methodSubscribers.push({name: concept.name, subscription: methodSub});\r\n            }\r\n          });\r\n          newConcepts[concept.semaphore] = concept;\r\n          axiumState.conceptCounter += 1;\r\n        });\r\n\r\n        const newAxiumState = newConcepts[0].state as AxiumState;\r\n        newAxiumState.cachedSemaphores = createCacheSemaphores(newConcepts);\r\n\r\n        axiumState.actionConcepts$.next(newConcepts);\r\n        axiumState.concepts$.next(newConcepts);\r\n\r\n        dispatch(strategyBegin(addConceptsFromQueThenUnblockStrategy(newConcepts)), {\r\n          throttle: 50\r\n        });\r\n      }\r\n    }, { selectors: [axiumSelectAddConceptQue], priority: Infinity - 1}),\r\n  ]);\r\n\r\n  const removeConceptsPlan = concepts$.innerPlan('Remove Concepts Plan', [\r\n    createStage((_concepts, dispatch) => {\r\n      const axiumState = _concepts[0].state as AxiumState;\r\n      if (axiumState.removeConceptQue.length === 0) {\r\n        allowRemove = true;\r\n      }\r\n      if (axiumState.removeConceptQue.length > 0 && allowRemove) {\r\n        allowRemove = false;\r\n        const newConcepts: Concepts = {};\r\n        axiumState.generation += 1;\r\n        const newModes: Mode[] = [blockingMode, permissiveMode];\r\n        const newModeNames: string[] = [axiumName, axiumName];\r\n        forEachConcept(concepts, ((concept, s) => {\r\n          axiumState.removeConceptQue.forEach(target => {\r\n            if (concept.name !== target.name) {\r\n              newConcepts[s as number] = (concept);\r\n            }\r\n          });\r\n        }));\r\n        const newAxiumState = newConcepts[0].state as AxiumState;\r\n        newAxiumState.modeNames.forEach((modeName, modeIndex) => {\r\n          let shouldAdd = false;\r\n          axiumState.removeConceptQue.forEach(removeTarget => {\r\n            if (modeName !== axiumName) {\r\n              if (modeName !== removeTarget.name) {\r\n                shouldAdd = true;\r\n              } else if (modeName === removeTarget.name && modeIndex === newAxiumState.defaultModeIndex) {\r\n                newAxiumState.defaultModeIndex = 1;\r\n              }\r\n            }\r\n          });\r\n          if (shouldAdd) {\r\n            newModeNames.push(modeName);\r\n            newModes.push((concepts[0].mode as Mode[])[modeIndex]);\r\n          }\r\n          shouldAdd = false;\r\n        });\r\n        newConcepts[0].mode = newModes;\r\n        newAxiumState.modeNames = newModeNames;\r\n\r\n        newAxiumState.cachedSemaphores = createCacheSemaphores(newConcepts);\r\n        newAxiumState.methodSubscribers.forEach(named => {\r\n          named.subscription.unsubscribe();\r\n        });\r\n        newAxiumState.methodSubscribers = [];\r\n\r\n        forEachConcept(newConcepts, (concept, s) => {\r\n          concept.qualities.forEach(quality => {\r\n            if (quality.methodCreator) {\r\n              const [method, subject] = quality.methodCreator(axiumState.concepts$, s);\r\n              quality.method = method;\r\n              quality.subject = subject;\r\n              quality.method.pipe(\r\n                catchError((err: unknown, caught: Observable<Action>) => {\r\n                  if (axiumState.logging) {\r\n                    console.error('METHOD ERROR', err);\r\n                  }\r\n                  return caught;\r\n                }));\r\n              const methodSub = quality.method.subscribe((action: Action) => {\r\n                blockingMethodSubscription(axiumState.action$, action);\r\n              }) as Subscriber<Action>;\r\n              const _axiumState = newConcepts[0].state as AxiumState;\r\n              _axiumState.methodSubscribers.push({\r\n                name: concept.name,\r\n                subscription: methodSub,\r\n              });\r\n            }\r\n          });\r\n        });\r\n        axiumState.actionConcepts$.next(newConcepts);\r\n        axiumState.concepts$.next(newConcepts);\r\n        dispatch(strategyBegin(\r\n          removeConceptsViaQueThenUnblockStrategy(newConcepts)), {\r\n          throttle: 50\r\n        });\r\n      }\r\n    }, { selectors: [axiumSelectRemoveConceptQue], priority: Infinity - 2})\r\n  ]);\r\n  observer.next(strategy.begin(strategy.create({\r\n    topic: 'Register Axium Add/Remove Plans',\r\n    initialNode: createActionNode(axiumRegisterStagePlanner({conceptName: axiumName, stagePlanner: addConceptsPlan}, semaphore), {\r\n      successNode: createActionNode(axiumRegisterStagePlanner({conceptName: axiumName, stagePlanner: removeConceptsPlan}, semaphore), {\r\n        successNode: null,\r\n        failureNode: null\r\n      }),\r\n      failureNode: null\r\n    })\r\n  })));\r\n};"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a series of KeyedSelectors for the AxiumState.":{"type":"project","content":"import { KeyedSelector, createConceptKeyedSelector } from '../../model/selector';\r\nimport { AxiumState } from './axium.concept';\r\n\r\nexport const axiumSelectOpen: KeyedSelector = createConceptKeyedSelector<AxiumState>('axium', 'open');\r\n\r\nexport const axiumSelectPrepareClose: KeyedSelector = createConceptKeyedSelector<AxiumState>('axium', 'prepareClose');\r\n\r\nexport const axiumSelectAddConceptQue: KeyedSelector = createConceptKeyedSelector<AxiumState>('axium', 'addConceptQue');\r\n\r\nexport const axiumSelectRemoveConceptQue: KeyedSelector = createConceptKeyedSelector<AxiumState>('axium', 'removeConceptQue');\r\n\r\nexport const axiumSelectLastStrategy: KeyedSelector = createConceptKeyedSelector<AxiumState>('axium', 'lastStrategy');\r\n\r\nexport const axiumSelectLastStrategyData: KeyedSelector = createConceptKeyedSelector<AxiumState>('axium', 'lastStrategyData');\r\n\r\nexport const axiumSelectLastStrategyDialog: KeyedSelector = createConceptKeyedSelector<AxiumState>('axium', 'lastStrategyDialog');\r\n\r\nexport const axiumSelectBadPlans: KeyedSelector = createConceptKeyedSelector<AxiumState>('axium', 'badPlans');\r\n\r\nexport const axiumSelectBadActions: KeyedSelector = createConceptKeyedSelector<AxiumState>('axium', 'badActions');"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a model file that specifies the gather action node concept.\r\nThis concept allows for action nodes to be linked into a sequence based on a provided actions parameter.\r\nNote this should be limited to actions that provably do not require error correction.\r\nOtherwise you would want to use a Strategy Stitch instead.":{"type":"project","content":"import { Action } from '../../../model/action';\r\nimport { ActionNode, ActionNodeOptions, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { axiumLog } from '../qualities/log.quality';\r\n\r\nexport type AxiumGatherNode = {\r\n  actions: Action[],\r\n  last?: ActionNode,\r\n}\r\n/**\r\n * Must used to create a uniform sequence of actions, note that these actions can be primed with a payload.\r\n * @param actions Sequence of actions to be gathered.\r\n * @param options `optional` Must be a union of paired options correlated in order to the provided actions.\r\n * Noting that success nodes will be overridden if passed.\r\n * @param last `optional` This will be set as the gathered actions final step.\r\n * You may use this to continue a strategy after the gathered actions have concluded.\r\n * @returns ActionNode of axiumStitch\r\n */\r\nexport const axium_createGatherNode = (props: AxiumGatherNode, options?: ActionNodeOptions[]) => {\r\n  const {\r\n    actions,\r\n    last,\r\n  } = props;\r\n  let first;\r\n  let previous;\r\n  const defaultOptions = {\r\n    successNode: null,\r\n    failureNode: null\r\n  };\r\n  for (const [i, act] of actions.entries()) {\r\n    const opt = options ? options[i] : undefined;\r\n    if (first === undefined) {\r\n      first = createActionNode(act, opt ? opt : {...defaultOptions});\r\n      previous = first;\r\n    } else if (previous !== undefined) {\r\n      const next = createActionNode(act, opt ? opt : {...defaultOptions});\r\n      previous.successNode = next;\r\n      previous = next;\r\n    }\r\n  }\r\n  if (previous !== undefined && last !== undefined) {\r\n    previous.successNode = last;\r\n  }\r\n  if (first) {\r\n    return first;\r\n  } else {\r\n    const log = axiumLog();\r\n    log.payload = {message: 'NO ACTIONS WERE GATHERED VIA AXIUM_CREATE_GATHER_NODE'};\r\n    return createActionNode(log, {\r\n      successNode: null,\r\n      failureNode: null\r\n    });\r\n  }\r\n};\r\n\r\nexport type AxiumGatherStrategy = {\r\n  actions: Action[],\r\n  last?: ActionNode,\r\n  topic?: string\r\n}\r\n/**\r\n * Creates a strategy that will execute a sequence of actions that can be primed with a payload.\r\n * @param actions Sequence of actions to be gathered.\r\n * @param last `optional` This will be set as the gathered actions final step.\r\n * @param topic `optional` Will set the topic of the returned strategy.\r\n * You may use this to continue a strategy after the gathered actions have concluded.\r\n * @param options `optional` Must be a union of paired options correlated in order to the provided actions.\r\n * Noting that success nodes will be overridden if passed.\r\n\r\n * @returns ActionStrategy of the provided actions to be executed in a sequence.\r\n */\r\nexport const axium_createGatherStrategy = (props: AxiumGatherStrategy, options?: ActionNodeOptions[]) => {\r\n  const stepFirst = axium_createGatherNode(props, options);\r\n  return createStrategy({\r\n    topic: props.topic ? props.topic : 'Axium Gather Strategy for: ' + props.actions.map(act => act.type).join(', '),\r\n    initialNode: stepFirst\r\n  });\r\n};"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a model file that includes a create stitch node helper function.\r\nThis function allows for Strategy Stitches to be composed of only one action node.\r\nWhile calling the axium's stitch quality to silently move to the next node assigned to the end of that stitch.":{"type":"project","content":"import { ActionNodeOptions, createActionNode } from '../../../model/actionStrategy';\r\nimport { axiumStitch } from '../qualities/stitch.quality';\r\n\r\n/**\r\n * Must be used within an ActionStrategyStitch with only one ActionNode provided.\r\n * @param options `optional` will set return ActionNode's options if provided.\r\n * @returns ActionNode of axiumStitch\r\n */\r\nexport const axium_createStitchNode = (options?: ActionNodeOptions) =>\r\n  (createActionNode(axiumStitch(), options ? options : {\r\n    successNode: null,\r\n    failureNode: null,\r\n  }));"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will add concepts within the addConceptQue into the Axium's Concepts.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [axiumAddConceptFromQue, axiumAddConceptFromQueType, axiumAddConceptsFromQueQuality] = createQualitySet({\r\n  type: 'Add Concepts from Axium Concept Que',\r\n  reducer: (state: AxiumState, action) => {\r\n    return {\r\n      ...state,\r\n      addConceptQue: []\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a quality that appends a complete strategies action list\r\ninto the dialog state property.":{"type":"project","content":"import { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AppendActionListToDialogPayload = {\r\n  actionList: Array<string>;\r\n  strategyTopic: string;\r\n  strategyData: unknown;\r\n}\r\n\r\nexport const [\r\n  axiumAppendActionListToDialog,\r\n  axiumAppendActionListToDialogType,\r\n  axiumAppendActionListToDialogQuality\r\n] = createQualitySetWithPayload<AppendActionListToDialogPayload>({\r\n  type: 'append Action List to Axium\\'s Dialog',\r\n  reducer: (state: AxiumState, action) => {\r\n    const payload = selectPayload<AppendActionListToDialogPayload>(action);\r\n    let newDialog = '';\r\n    if (state.storeDialog) {\r\n      payload.actionList.forEach(str => {newDialog += str + ' ';});\r\n      if (state.logging) {\r\n        console.log(newDialog);\r\n      }\r\n      return {\r\n        ...state,\r\n        dialog: state.dialog + newDialog,\r\n        lastStrategy: payload.strategyTopic,\r\n        lastStrategyData: payload.strategyData,\r\n        lastStrategyDialog: newDialog\r\n      };\r\n    }\r\n    return {\r\n      ...state,\r\n      lastStrategy: payload.strategyTopic,\r\n      lastStrategyData: payload.strategyData,\r\n    };\r\n  }\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a quality that will append a series of concepts to the Axium's\r\naddConceptQue. This will then be observed via the Axium's principle.":{"type":"project","content":"import { Concept, defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AxiumAppendConceptsToAddQuePayload = {\r\n  concepts: Concept[]\r\n}\r\n\r\nexport const [\r\n  axiumAppendConceptsToAddQue,\r\n  axiumAppendConceptsToAddQueType,\r\n  axiumAppendConceptsToAddQueQuality\r\n] = createQualitySetWithPayload<AxiumAppendConceptsToAddQuePayload>({\r\n  type: 'append Concepts to Axium\\'s Add Concept Que',\r\n  reducer: (state: AxiumState, action) => {\r\n    const payload = selectPayload<AxiumAppendConceptsToAddQuePayload>(action);\r\n    const addConceptQue = [\r\n      ...payload.concepts\r\n    ];\r\n    return {\r\n      ...state,\r\n      addConceptQue,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a quality that will append a sequence of concepts to the Axium's\r\nremoveConceptQue. The main axium principle will then initialize a removal strategy based on this que.":{"type":"project","content":"import { Concept, defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AxiumAppendConceptsToRemoveQuePayload = {\r\n  concepts: Concept[]\r\n}\r\n\r\nexport const [\r\n  axiumAppendConceptsToRemoveQue,\r\n  axiumAppendConceptsToRemoveQueType,\r\n  axiumAppendConceptsToRemoveQueQuality\r\n] = createQualitySetWithPayload<AxiumAppendConceptsToRemoveQuePayload>({\r\n  type: 'append Concepts to Axium\\'s Remove Concept Que',\r\n  reducer: (state: AxiumState, action) => {\r\n    const payload = selectPayload<AxiumAppendConceptsToRemoveQuePayload>(action);\r\n    let removeQue = state.removeConceptQue;\r\n    removeQue = [\r\n      ...removeQue,\r\n      ...payload.concepts\r\n    ];\r\n    return {\r\n      ...state,\r\n      removeConceptQue: removeQue\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that signifies if the Axium has received a bad action that\r\nis currently not loaded, part of the wrong generation, expired, etc... If state logging is true, the developer will be notified\r\nof the bad action that was received.":{"type":"project","content":"import { Action } from '../../../model/action';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { AxiumState } from '../axium.concept';\r\n\r\nexport type AxiumBadActionPayload = {\r\n  badActions: Action[],\r\n}\r\nexport const [\r\n  axiumBadAction,\r\n  axiumBadActionType,\r\n  axiumBadActionQuality\r\n] = createQualitySetWithPayload<AxiumBadActionPayload>({\r\n  type: 'Axium received a Bad Action',\r\n  reducer: (state: AxiumState, action) => {\r\n    const payload = selectPayload<AxiumBadActionPayload>(action).badActions;\r\n    if (state.logging) {\r\n      console.log('Axium Received a Bad Action: ', action);\r\n    }\r\n    return {\r\n      ...state,\r\n      badActions: [\r\n        ...state.badActions, ...payload\r\n      ]\r\n    };\r\n  }\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will clear a specified action type from the state's badAction list.\r\nThis list is utilized by future on the fly error correction for handling generated qualities for an embodied artificial intelligence.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { ActionType } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AxiumClearBadActionTypeFromBadActionListPayload = {\r\n  actionType: ActionType\r\n};\r\nexport const [\r\n  axiumClearBadActionTypeFromBadActionList,\r\n  axiumClearBadActionTypeFromBadActionListType,\r\n  axiumClearBadActionTypeFromBadActionListQuality\r\n] = createQualitySetWithPayload<AxiumClearBadActionTypeFromBadActionListPayload>({\r\n  type: 'clear ActionType from Axium\\'s badAction list',\r\n  reducer: (state: AxiumState, action) => {\r\n    const {actionType} = selectPayload<AxiumClearBadActionTypeFromBadActionListPayload>(action);\r\n    return {\r\n      ...state,\r\n      badActions: state.badActions.filter(act => act.type !== actionType),\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will clear a specified plan from the badPlan list on state.\r\nThis allows for generated plans via an embodied artificial intelligence to error correct on the fly for any poorly generated plans.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport type AxiumClearBadPlanFromBadPlanListPayload = {\r\n  title: string\r\n};\r\n\r\nexport const [\r\n  axiumClearBadPlanFromBadPlanList,\r\n  axiumClearBadPlanFromBadPlanListQualityType,\r\n  axiumClearBadPlanFromBadPlanListQuality\r\n] = createQualitySet({\r\n  type: 'clear Plan Topic from Axium\\'s badPlan list',\r\n  reducer: (state: AxiumState, action) => {\r\n    const {title} = selectPayload<AxiumClearBadPlanFromBadPlanListPayload>(action);\r\n    return {\r\n      ...state,\r\n      badPlans: state.badPlans.filter(act => act.title !== title),\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will remove a strategies topic from state's badAction list.\r\nThis allows for an Artificial Intelligence that is embodying Stratimux to correct generated strategies on the fly.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AxiumClearBadStrategyTopicFromBadActionListPayload = {\r\n  topic: string\r\n};\r\nexport const [\r\n  axiumClearBadStrategyTopicFromBadActionList,\r\n  axiumClearBadStrategyTopicFromBadActionListType,\r\n  axiumClearBadStrategyTopicFromBadActionListQuality\r\n] = createQualitySetWithPayload<AxiumClearBadStrategyTopicFromBadActionListPayload>({\r\n  type: 'clear Strategy Topic from Axium\\'s badAction list',\r\n  reducer: (state: AxiumState, action) => {\r\n    const {topic} = selectPayload<AxiumClearBadStrategyTopicFromBadActionListPayload>(action);\r\n    const badActions = state.badActions.filter(act => {\r\n      if (act.strategy && act.strategy.topic !== topic) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    });\r\n    return {\r\n      ...state,\r\n      badActions,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will clear the state's dialog.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  axiumClearDialog,\r\n  axiumClearDialogType,\r\n  axiumClearDialogQuality\r\n] = createQualitySet({\r\n  type: 'clear Axium Dialog',\r\n  reducer: (state: AxiumState) => {\r\n    return {\r\n      ...state,\r\n      dialog: '',\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will close the axium, if exit is set to true.\r\nThis will also exit the current process.":{"type":"project","content":"import { createQuality } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySet, createQualitySetWithPayload } from '../../../model/quality';\r\n\r\n/**\r\n * @parm exit - If set to true, will exit the current process.\r\n */\r\nexport type AxiumClosePayload = {\r\n  exit: boolean\r\n};\r\nexport const [\r\n  axiumClose,\r\n  axiumCloseType,\r\n  axiumCloseQuality\r\n] = createQualitySetWithPayload<AxiumClosePayload>({\r\n  type: 'Close Axium',\r\n  reducer: (state: AxiumState, action) => {\r\n    const {exit} = selectPayload<AxiumClosePayload>(action);\r\n    state.generalSubscribers.forEach(named => named.subscription.unsubscribe());\r\n    state.methodSubscribers.forEach(named => named.subscription.unsubscribe());\r\n    state.stagePlanners.forEach(named => named.conclude());\r\n    state.action$.complete();\r\n    state.concepts$.complete();\r\n    state.actionConcepts$.complete();\r\n    if (exit) {\r\n      process.exit();\r\n    }\r\n    return {\r\n      ...state,\r\n      methodSubscribers: [],\r\n      generalSubscribers: [],\r\n      stagePlanners: [],\r\n    };\r\n  }\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a quality that will conclude a strategy.\r\nThis is the primary quality that allows for Stratimux to be provably terminating and/or halting complete.\r\nFunctionally. This is a pure action with no method or reducer. That will instead activate its functionality\r\nwithin each qualities method if specified. As well as ownership if loaded in the Axium's concept set.":{"type":"project","content":"import { ActionType, prepareActionCreator } from '../../../model/action';\r\n\r\n/**\r\n * axiumConcludeType\r\n * This is a special Quality that does not have a Reducer or Method\r\n * Instead what this allows for is special functionality within the Axium and Ownership Concepts\r\n * Is used for appending ActionList to Dialog\r\n * And used to clear Ownership of its Previous ActionNode and is handled by ActionStrategy\r\n * This should not be used Directly\r\n */\r\nexport const axiumConcludeType: ActionType = 'Conclude';\r\nexport const axiumConclude = prepareActionCreator(axiumConcludeType);"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will initialize principles loaded into the Axium's conceptual set.":{"type":"project","content":"import { Subject, Subscriber } from 'rxjs';\r\nimport { Concept, Concepts, defaultMethodCreator, forEachConcept  } from '../../../model/concept';\r\nimport { createPrinciple$ } from '../../../model/principle';\r\nimport { Action, } from '../../../model/action';\r\nimport { AxiumState, axiumName } from '../axium.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AxiumInitializePrinciplesPayload = {\r\n    concepts: Concepts;\r\n}\r\n\r\nexport const [\r\n  axiumInitializePrinciples,\r\n  axiumInitializePrinciplesType,\r\n  axiumInitializePrinciplesQuality\r\n] = createQualitySetWithPayload<AxiumInitializePrinciplesPayload>({\r\n  type: 'initialize Principles and set new Subscribers to General Subscribers list',\r\n  reducer: (state: AxiumState, act) => {\r\n    const payload = selectPayload<AxiumInitializePrinciplesPayload>(act);\r\n    const concepts = payload.concepts;\r\n    let conceptCounter = state.conceptCounter;\r\n    const action$ = state.action$ as Subject<Action>;\r\n    const concepts$ = state.concepts$ as UnifiedSubject;\r\n    const principleSubscribers = state.generalSubscribers;\r\n    forEachConcept(concepts ,((concept: Concept, semaphore) => {\r\n      if (concept.name === axiumName && concept.principles) {\r\n        concept.principles.forEach(principle => {\r\n          const observable = createPrinciple$(principle, concepts, state.concepts$, semaphore as number);\r\n          principleSubscribers.push({\r\n            name: concept.name,\r\n            subscription: observable.subscribe((action: Action) => action$.next(action)) as Subscriber<Action>,\r\n          });\r\n        });\r\n        conceptCounter += 1;\r\n      } else if (concept.principles) {\r\n        concept.principles.forEach(principle => {\r\n          const observable = createPrinciple$(principle, concepts, concepts$, semaphore as number);\r\n          principleSubscribers.push({\r\n            name: concept.name,\r\n            subscription: observable.subscribe((action: Action) => action$.next(action)) as Subscriber<Action>,\r\n          });\r\n        });\r\n        conceptCounter += 1;\r\n      }\r\n    }));\r\n    return {\r\n      ...state,\r\n      principleSubscribers,\r\n      conceptCounter,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a quality with the default method and reducer.\r\nThis quality is used to signify the next step within a plan if no state change is required.\r\nLikewise this quality is used to kick the axium into gear if currently resting due to its own halting behavior.":{"type":"project","content":"import { defaultMethodCreator, defaultReducer } from '../../../model/concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [axiumKick, axiumKickType, axiumKickQuality] = createQualitySet({\r\n  type: 'Kick Axium',\r\n  reducer: defaultReducer,\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a quality that will console log the action itself.\r\nThis is used to trouble shoot strategies or simply notify the log of different states.":{"type":"project","content":"import { nullReducer } from '../../../model/concept';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { createMethod } from '../../../model/method';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  axiumLog,\r\n  axiumLogType,\r\n  axiumLogQuality\r\n] = createQualitySet({\r\n  type: 'logged a message passed to Axium',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createMethod((action) => {\r\n    console.log('Logging: ', action);\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy);\r\n    } else {\r\n      return action;\r\n    }\r\n  })\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality similar to axium kick, except this is used when the Axium is\r\ncurrently in blocking mode. This allows for subscribers to be notified of any new configurations if set.\r\nOr simply that the axium is ready to receive actions.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type OpenPayload = {\r\n  open: boolean\r\n};\r\n\r\nexport const [\r\n  axiumOpen,\r\n  axiumOpenType,\r\n  axiumOpenQuality\r\n] = createQualitySetWithPayload<OpenPayload>({\r\n  type: 'Open Axium',\r\n  reducer: (state: AxiumState, action) => {\r\n    const {open} = selectPayload<OpenPayload>(action);\r\n    return {\r\n      ...state,\r\n      open\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a quality that will trigger the axium's closing process via\r\nits close principle that is observing the prepareClose state property.":{"type":"project","content":"import { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\n/**\r\n * @parm exit - If set to true, will exit the current process.\r\n */\r\nexport type AxiumPreClosePayload = {\r\n  exit: boolean\r\n};\r\nexport const [\r\n  axiumPreClose,\r\n  axiumPreCloseType,\r\n  axiumPreCloseQuality\r\n] = createQualitySetWithPayload<AxiumPreClosePayload>({\r\n  type: 'Prepare Close Axium',\r\n  reducer: (state: AxiumState, action) => {\r\n    return {\r\n      ...state,\r\n      prepareClose: true,\r\n      exit: selectPayload<AxiumPreClosePayload>(action).exit\r\n    };\r\n  }\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will append a stage planner to the stagePlanners state property.\r\nThis allows for the closing of hot observables if the concept they are associated with is removed, or the axium itself is closed.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { StagePlanner } from '../../../model/stagePlanner';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AxiumRegisterStagePlannerPayload = {\r\n    stagePlanner: StagePlanner;\r\n    conceptName: string;\r\n}\r\n\r\nexport const [\r\n  axiumRegisterStagePlanner,\r\n  axiumRegisterStagePlannerType,\r\n  axiumRegisterStagePlannerQuality\r\n] = createQualitySetWithPayload<AxiumRegisterStagePlannerPayload>({\r\n  type: 'register Stage Planner to Axium\\'s Named Stage Planner list',\r\n  reducer: (state: AxiumState, action) => {\r\n    const payload = selectPayload<AxiumRegisterStagePlannerPayload>(action);\r\n    const stagePlanners = state.stagePlanners;\r\n    const stagePlanner = payload.stagePlanner;\r\n    const name = payload.conceptName;\r\n    stagePlanners.push({name, ...stagePlanner});\r\n    return {\r\n      ...state,\r\n      stagePlanners,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will register a subscription to the concepts$ stream.\r\nThis allows for the clean closure of concepts that are removed or when the axium itself exits.":{"type":"project","content":"import { Subscription } from 'rxjs';\r\nimport { defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AxiumRegisterSubscriberPayload = {\r\n    subscription: Subscription;\r\n    name: string;\r\n}\r\n\r\nexport const [\r\n  axiumRegisterSubscriber,\r\n  axiumRegisterSubscriberType,\r\n  axiumRegisterSubscriberQuality\r\n] = createQualitySetWithPayload<AxiumRegisterSubscriberPayload>({\r\n  type: 'register Subscriber to Axium\\'s General Subscriber list',\r\n  reducer: (state: AxiumState, action) => {\r\n    const payload = selectPayload<AxiumRegisterSubscriberPayload>(action);\r\n    const generalSubscribers = state.generalSubscribers;\r\n    const subscription = payload.subscription;\r\n    const name = payload.name;\r\n    generalSubscribers.push({name, subscription});\r\n    return {\r\n      ...state,\r\n      generalSubscribers,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will remove concepts that are currently loaded in the Axium.\r\nWill concluding plans and closing active subscriptions associated with the removed concepts.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { NamedSubscription } from '../axium.concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { NamedStagePlanner } from '../../../model/stagePlanner';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  axiumRemoveConceptsViaQue,\r\n  axiumRemoveConceptsViaQueType,\r\n  axiumRemoveConceptsViaQueQuality\r\n] = createQualitySet({\r\n  type: 'remove Concepts via Axium\\'s Removal Concept Que',\r\n  reducer: (state: AxiumState, action) => {\r\n    const principleSubscribers = state.methodSubscribers;\r\n    const newPrincipleSubscribers = [] as NamedSubscription[];\r\n    const generalSubscribers = state.methodSubscribers;\r\n    const newGeneralSubscribers = [] as NamedSubscription[];\r\n    const stagePlanners = state.stagePlanners;\r\n    const newStagePlanners = [] as NamedStagePlanner[];\r\n    const removeConceptQue = state.removeConceptQue;\r\n\r\n    principleSubscribers.forEach(named => {\r\n      let exists = false;\r\n      removeConceptQue.forEach(concept => {\r\n        if (concept.name === named.name) {\r\n          exists = true;\r\n        }\r\n      });\r\n      if (!exists) {\r\n        newPrincipleSubscribers.push(named);\r\n      } else {\r\n        named.subscription.unsubscribe();\r\n      }\r\n    });\r\n\r\n    generalSubscribers.forEach(named => {\r\n      let exists = false;\r\n      removeConceptQue.forEach(concept => {\r\n        if (concept.name === named.name) {\r\n          exists = true;\r\n        }\r\n      });\r\n      if (!exists) {\r\n        newGeneralSubscribers.push(named);\r\n      } else {\r\n        named.subscription.unsubscribe();\r\n      }\r\n    });\r\n\r\n    stagePlanners.forEach(named => {\r\n      let exists = false;\r\n      removeConceptQue.forEach(concept => {\r\n        if (concept.name === named.name) {\r\n          exists = true;\r\n        }\r\n      });\r\n      if (!exists) {\r\n        newStagePlanners.push(named);\r\n      } else {\r\n        named.conclude();\r\n      }\r\n    });\r\n\r\n    return {\r\n      ...state,\r\n      generalSubscribers: newGeneralSubscribers,\r\n      stagePlanners: newStagePlanners,\r\n      removeConceptQue: []\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will set the Axium's mode to blocking. While in this mode\r\nthe Axium operates in a synchronous behavior to quickly modify the Axium's conceptual set.":{"type":"project","content":"import { Subject, Subscriber } from 'rxjs';\r\nimport { Concepts, defaultMethodCreator, forEachConcept } from '../../../model/concept';\r\nimport { Action } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { blockingMethodSubscription } from '../../../model/axium';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AxiumSetBlockingModePayload = {\r\n    concepts: Concepts\r\n}\r\n\r\nexport const [\r\n  axiumSetBlockingMode,\r\n  axiumSetBlockingModeType,\r\n  axiumSetBlockingModeQuality\r\n] = createQualitySetWithPayload<AxiumSetBlockingModePayload>({\r\n  type: 'set Axium to Blocking Mode',\r\n  reducer: (state: AxiumState, _action) => {\r\n    let methodSubscribers = state.methodSubscribers;\r\n    methodSubscribers.forEach(named => named.subscription.unsubscribe());\r\n    methodSubscribers = [];\r\n\r\n    const payload = selectPayload<AxiumSetBlockingModePayload>(_action);\r\n    const concepts = payload.concepts;\r\n    forEachConcept(concepts, (concept => {\r\n      concept.qualities.forEach(quality => {\r\n        if (quality.method) {\r\n          const sub = quality.method.subscribe(action => {\r\n            const action$ = state.action$ as Subject<Action>;\r\n            blockingMethodSubscription(action$, action);\r\n          });\r\n          methodSubscribers.push({\r\n            name: concept.name,\r\n            subscription: sub as Subscriber<Action>\r\n          });\r\n        }\r\n      });\r\n    }));\r\n\r\n    return {\r\n      ...state,\r\n      modeIndex: 0,\r\n      methodSubscribers,\r\n      open: false,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a quality that will set the Axium to its default mode.\r\nThis mode likewise can be specified by changing the defaultModeIndex state property.":{"type":"project","content":"import { Subject, Subscriber } from 'rxjs';\r\nimport { Concepts, defaultMethodCreator, forEachConcept } from '../../../model/concept';\r\nimport { Action } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { defaultMethodSubscription } from '../../../model/axium';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AxiumSetDefaultModePayload = {\r\n    concepts: Concepts\r\n}\r\n\r\nexport const [\r\n  axiumSetDefaultMode,\r\n  axiumSetDefaultModeType,\r\n  axiumSetDefaultModeQuality\r\n] = createQualitySetWithPayload<AxiumSetDefaultModePayload>({\r\n  type: 'set Axium to its current Default Mode Index',\r\n  reducer: (state: AxiumState, _action) => {\r\n    let methodSubscribers = state.methodSubscribers;\r\n    methodSubscribers.forEach(named => named.subscription.unsubscribe());\r\n    methodSubscribers = [];\r\n    const payload = selectPayload<AxiumSetDefaultModePayload>(_action);\r\n    const concepts = payload.concepts;\r\n    forEachConcept(concepts, (concept => {\r\n      concept.qualities.forEach(quality => {\r\n        if (quality.method) {\r\n          const sub = quality.method.subscribe(action => {\r\n            const action$ = state.action$ as Subject<Action>;\r\n            defaultMethodSubscription(action$, action);\r\n          });\r\n          methodSubscribers.push({\r\n            name: concept.name,\r\n            subscription: sub as Subscriber<Action>\r\n          });\r\n        }\r\n      });\r\n    }));\r\n\r\n    return {\r\n      ...state,\r\n      modeIndex: state.defaultModeIndex,\r\n      methodSubscribers,\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will set the default mode index to what is specified by\r\nthe action's payload.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AxiumSetDefaultModeIndexPayload = {\r\n  index: number;\r\n};\r\n\r\nexport const [\r\n  axiumSetDefaultModeIndex,\r\n  axiumSetDefaultModeIndexType,\r\n  axiumSetDefaultModeIndexQuality\r\n] = createQualitySetWithPayload<AxiumSetDefaultModeIndexPayload>({\r\n  type: 'set Axium\\'s Default Mode Index',\r\n  reducer: (state: AxiumState, action) => {\r\n    const payload = selectPayload<AxiumSetDefaultModeIndexPayload>(action);\r\n    return {\r\n      ...state,\r\n      defaultModeIndex: payload.index,\r\n    } as AxiumState;\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a quality that will set the mode explicitly via the payload.":{"type":"project","content":"import { AxiumState } from '../axium.concept';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createMethod } from '../../../model/method';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type AxiumSetModePayload = {\r\n  modeIndex: number;\r\n  modeName: string;\r\n}\r\n\r\nexport const [\r\n  axiumSetMode,\r\n  axiumSetModeType,\r\n  axiumSetModeQuality\r\n] = createQualitySetWithPayload<AxiumSetModePayload>({\r\n  type: 'set Axium Mode',\r\n  reducer: (state: AxiumState, action) => {\r\n    const payload = selectPayload<AxiumSetModePayload>(action);\r\n    return {\r\n      ...state,\r\n      modeIndex: [payload.modeIndex],\r\n    };\r\n  },\r\n  methodCreator: () => createMethod((action) => {\r\n    const payload = action.payload as AxiumSetModePayload;\r\n    if (action.strategy) {\r\n      action.strategy.currentNode.successNotes = {\r\n        denoter: `to ${payload.modeName}.`\r\n      };\r\n      return strategySuccess(action.strategy);\r\n    }\r\n    return action;\r\n  })\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will silently start the next step in the strategy graph.":{"type":"project","content":"import { strategySuccess } from '../../../model/actionStrategy';\r\nimport { defaultReducer } from '../../../model/concept';\r\nimport { createMethod } from '../../../model/method';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  axiumStitch,\r\n  axiumStitchType,\r\n  axiumStitchQuality\r\n] = createQualitySet({\r\n  type: 'Axium Stitch',\r\n  reducer: defaultReducer,\r\n  methodCreator: () => createMethod((action) => {\r\n    if (action.strategy) {\r\n      const nextStrategy = strategySuccess(action.strategy);\r\n      if (nextStrategy.strategy) {\r\n        const actionList = nextStrategy.strategy.actionList;\r\n        const newList = [];\r\n        for (let i = 0; i < actionList.length - 1; i++) {\r\n          newList.push(actionList[i]);\r\n        }\r\n        nextStrategy.strategy.actionList = newList;\r\n      }\r\n      return nextStrategy;\r\n    } else {\r\n      return action;\r\n    }\r\n  })\r\n});"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate an ActionStrategy that will add new concepts into the Axium's conceptual set.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concept, Concepts } from '../../../model/concept';\r\nimport { getSemaphore} from '../../../model/action';\r\nimport { axiumAddConceptFromQue, axiumAddConceptFromQueType } from '../qualities/addConceptsFromQue.quality';\r\nimport { axiumAppendConceptsToAddQue, axiumAppendConceptsToAddQueType } from '../qualities/appendConceptsToAddQue.quality';\r\nimport { axiumOpen, axiumOpenType } from '../qualities/open.quality';\r\nimport { axiumSetBlockingMode, axiumSetBlockingModeType } from '../qualities/setBlockingMode.quality';\r\nimport { axiumSetDefaultMode, axiumSetDefaultModeType } from '../qualities/setDefaultMode.quality';\r\nimport { axiumName } from '../axium.concept';\r\n\r\n// Step One to Add Concepts to Axium\r\nexport const addConceptsToAddQueThenBlockTopic = 'Add Concepts to add que then set Axium Mode to Blocking';\r\nexport function addConceptsToAddQueThenBlockStrategy(concepts: Concepts, newConcepts: Concept[]) {\r\n  const stepTwo = createActionNode(axiumAppendConceptsToAddQue({concepts: newConcepts}),{\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'Then Safely'\r\n    },\r\n    semaphore: getSemaphore(concepts, axiumName, axiumAppendConceptsToAddQueType),\r\n  });\r\n  const stepOne = createActionNode(axiumSetBlockingMode({concepts}), {\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: 'Immediately'\r\n    },\r\n    semaphore: getSemaphore(concepts, axiumName, axiumSetBlockingModeType),\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: addConceptsToAddQueThenBlockTopic,\r\n    initialNode: stepOne\r\n  };\r\n  return createStrategy(params);\r\n}\r\n// Step Two\r\nexport const addConceptsFromQueThenUnblockTopic = 'Add Concepts from Que then set Axium Mode to Default';\r\nexport function addConceptsFromQueThenUnblockStrategy(conceptualSet: Concepts): ActionStrategy {\r\n  const addConceptsFromQueSemaphore = getSemaphore(conceptualSet, axiumName, axiumAddConceptFromQueType);\r\n  const setDefaultModeSemaphore = getSemaphore(conceptualSet, axiumName, axiumSetDefaultModeType);\r\n  const openSemaphore = getSemaphore(conceptualSet, axiumName, axiumOpenType);\r\n\r\n  const stepThree = createActionNode(axiumOpen({open: true}), {\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'Reinstate',\r\n      denoter: 'State.'\r\n    },\r\n    semaphore: openSemaphore,\r\n  });\r\n  const stepTwo = createActionNode(axiumSetDefaultMode({concepts: conceptualSet}), {\r\n    semaphore: setDefaultModeSemaphore,\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: 'Then'\r\n    },\r\n  });\r\n  const stepOne = createActionNode(axiumAddConceptFromQue(),{\r\n    semaphore: addConceptsFromQueSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: 'First'\r\n    },\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: addConceptsFromQueThenUnblockTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the asynchronous graph programming framework Stratimux and Axium Concept,\r\ngenerate a strategy that will initialize the axium of its base functionality.\r\nWithin the Stratimux paradigm. Principles act as the start up script, or main function.":{"type":"project","content":"import { createStrategy, ActionNode, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concepts } from '../../../model/concept';\r\nimport { getSemaphore } from '../../../model/action';\r\nimport { axiumOpen, axiumOpenType } from '../qualities/open.quality';\r\nimport { axiumInitializePrinciples, axiumInitializePrinciplesType } from '../qualities/initializePrinciples.quality';\r\nimport { axiumSetDefaultMode, axiumSetDefaultModeType } from '../qualities/setDefaultMode.quality';\r\nimport { axiumName } from '../axium.concept';\r\n\r\nexport const initializeTopic = 'Axium Initialization Strategy';\r\nexport function initializationStrategy(concepts: Concepts): ActionStrategy {\r\n  const initSemaphore = getSemaphore(concepts, axiumName, axiumInitializePrinciplesType);\r\n  const setDefaultModeSemaphore = getSemaphore(concepts, axiumName, axiumSetDefaultModeType);\r\n  const openSemaphore = getSemaphore(concepts, axiumName, axiumOpenType);\r\n\r\n  const stepThree: ActionNode = createActionNode(axiumOpen({open: true}), {\r\n    semaphore: openSemaphore,\r\n    successNotes: {\r\n      preposition: 'Finally',\r\n      denoter: 'to Notify Subscribers of State changes.'\r\n    },\r\n  });\r\n  const stepTwo: ActionNode = createActionNode(axiumSetDefaultMode({concepts}), {\r\n    semaphore: setDefaultModeSemaphore,\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: 'Then'\r\n    },\r\n  });\r\n  const stepOne: ActionNode = createActionNode(axiumInitializePrinciples({concepts}),{\r\n    semaphore: initSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: 'Begin with'\r\n    },\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: initializeTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the asynchronous graph programming framework Stratimux and Axium Concept, generate a strategy that will safely remove concepts\r\nfrom the Axium's concepts state property.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concept, Concepts } from '../../../model/concept';\r\nimport { getSemaphore } from '../../../model/action';\r\nimport { axiumRemoveConceptsViaQue, axiumRemoveConceptsViaQueType } from '../qualities/removeConceptsViaQue.quality';\r\nimport { axiumAppendConceptsToRemoveQue, axiumAppendConceptsToRemoveQueType } from '../qualities/appendConceptsToRemoveQue.quality';\r\nimport { axiumSetBlockingMode, axiumSetBlockingModeType } from '../qualities/setBlockingMode.quality';\r\nimport { axiumOpen, axiumOpenType } from '../qualities/open.quality';\r\nimport { axiumSetDefaultMode, axiumSetDefaultModeType } from '../qualities/setDefaultMode.quality';\r\nimport { axiumName } from '../axium.concept';\r\n\r\nexport const addConceptsToRemovalQueThenBlockTopic = 'Add Concepts to removal Que then set Axium Mode to Blocking';\r\nexport function addConceptsToRemovalQueThenBlockStrategy(concepts: Concepts, targetConcepts: Concept[]) {\r\n  const setBlockingModeSemaphore = getSemaphore(concepts, axiumName, axiumSetBlockingModeType);\r\n  const appendConceptsToRemoveQueSemaphore = getSemaphore(concepts, axiumName, axiumAppendConceptsToRemoveQueType);\r\n\r\n  const stepTwo = createActionNode(axiumAppendConceptsToRemoveQue({concepts: targetConcepts}), {\r\n    semaphore: appendConceptsToRemoveQueSemaphore,\r\n  });\r\n  const stepOne = createActionNode(axiumSetBlockingMode({concepts}), {\r\n    semaphore: setBlockingModeSemaphore,\r\n    successNode: stepTwo,\r\n  });\r\n  const params: ActionStrategyParameters = {\r\n    topic: addConceptsToRemovalQueThenBlockTopic,\r\n    initialNode: stepOne\r\n  };\r\n  return createStrategy(params);\r\n}\r\n// Step Two\r\nexport const removeConceptsViaQueThenUnblockTopic = 'Remove Concepts via Que then set Axium Mode to Default';\r\nexport function removeConceptsViaQueThenUnblockStrategy(concepts: Concepts): ActionStrategy {\r\n  const removeConceptsViaQueSemaphore = getSemaphore(concepts, axiumName, axiumRemoveConceptsViaQueType);\r\n  const setDefaultModeSemaphore = getSemaphore(concepts, axiumName, axiumSetDefaultModeType);\r\n  const openSemaphore = getSemaphore(concepts, axiumName, axiumOpenType);\r\n\r\n  const stepThree = createActionNode(axiumOpen({open: true}), {\r\n    semaphore: openSemaphore,\r\n    successNotes: {\r\n      preposition: 'Reinstate',\r\n      denoter: 'State.'\r\n    },\r\n  });\r\n  const stepTwo = createActionNode(axiumSetDefaultMode({concepts}), {\r\n    semaphore: setDefaultModeSemaphore,\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: 'Then'\r\n    },\r\n  });\r\n  const stepOne = createActionNode(axiumRemoveConceptsViaQue(), {\r\n    semaphore: removeConceptsViaQueSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: 'To Begin'\r\n    },\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: removeConceptsViaQueThenUnblockTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the asynchronous graph programming framework Stratimux,\r\ngenerate the Chain Concept that will dispatch any actions in sequence assigned to its actionQue.\r\nThis concept merely exists by example. As the issue with this concept is that it does not afford for error correction.\r\nAnd would be considered a precursor to ActionStrategy.":{"type":"project","content":"import { Action } from '../../index';\r\nimport { createConcept } from '../../model/concept';\r\nimport { chainPrinciple } from './chain.principle';\r\nimport { chainEndQuality } from './qualities/chainEnd.quality';\r\nimport { chainPrepareChainQuality } from './qualities/prepareChain.quality';\r\n\r\nexport type ChainState = {\r\n  actionQue: Action[];\r\n  end: boolean;\r\n};\r\n\r\nexport const chainName = 'chain';\r\n\r\nconst initialChainState: ChainState = {\r\n  actionQue: [],\r\n  end: false\r\n};\r\n\r\nexport const createChainConcept = () => {\r\n  return createConcept(\r\n    chainName,\r\n    initialChainState,\r\n    [chainPrepareChainQuality, chainEndQuality],\r\n    [chainPrinciple],\r\n  );\r\n};"},"For the asynchronous graph programming framework Stratimux and Chain Concept,\r\ngenerate a principle that observes the chain's actionQue and dispatches\r\nthose actions in order upon each state notification.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport { Concepts } from '../../model/concept';\r\nimport { Action } from '../../model/action';\r\nimport { PrincipleFunction, registerPrincipleSubscription } from '../../model/principle';\r\nimport { ChainState, chainName } from './chain.concept';\r\nimport { selectUnifiedState } from '../../model/selector';\r\nimport { AxiumState } from '../axium/axium.concept';\r\nimport { UnifiedSubject } from '../../model/stagePlanner';\r\n\r\nexport const chainPrinciple: PrincipleFunction = (\r\n  observer: Subscriber<Action>,\r\n  _concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  const subscription = concepts$.subscribe((concepts: Concepts) => {\r\n    const chainState = selectUnifiedState<ChainState>(concepts, semaphore);\r\n    if (chainState && chainState.actionQue.length > 0) {\r\n      const newActionQue = [...chainState.actionQue];\r\n      const nextAction = newActionQue.pop() as Action;\r\n      chainState.actionQue = newActionQue;\r\n      concepts$.next(concepts);\r\n      const axiumState = concepts[0].state as AxiumState;\r\n      axiumState.action$?.next(nextAction);\r\n    }\r\n  });\r\n  registerPrincipleSubscription(observer, _concepts, chainName, subscription);\r\n};"},"For the asynchronous graph programming framework Stratimux and Chain Concept, generate a quality will set the chain end property to false":{"type":"project","content":"import { createQualitySet } from '../../../model/quality';\r\nimport { ChainState } from '../chain.concept';\r\n\r\nexport const [\r\n  chainEnd,\r\n  chainEndType,\r\n  chainEndQuality\r\n] = createQualitySet({\r\n  type: 'set chain end property to true',\r\n  reducer: (state: ChainState, action) => {\r\n    return {\r\n      ...state,\r\n      end: true\r\n    };\r\n  }\r\n});"},"For the asynchronous graph programming framework Stratimux and Chain Concept,\r\ngenerate a quality will add actions into the Chain's actionQue state property.":{"type":"project","content":"import { Action } from '../../../model/action';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { ChainState } from '../chain.concept';\r\n\r\nexport type ChainPrepareChainPayload = {\r\n    actions: Action[]\r\n}\r\n\r\nexport const [\r\n  chainPrepareChain,\r\n  chainPrepareChainType,\r\n  chainPrepareChainQuality\r\n] = createQualitySetWithPayload<ChainPrepareChainPayload>({\r\n  type: 'dispatch Actions from Action Que via Payload to be Chained',\r\n  reducer: (state: ChainState, action) => {\r\n    const payload = selectPayload<ChainPrepareChainPayload>(action);\r\n    return {\r\n      ...state,\r\n      actionQue: [\r\n        ...state.actionQue,\r\n        ...payload.actions\r\n      ]\r\n    };\r\n  }\r\n});"},"For the asynchronous graph programming framework Stratimux generate a Counter Concept that will keep track of a count in its state.":{"type":"project","content":"import { counterAddQuality } from './qualities/add.quality';\r\nimport { counterSubtractQuality } from './qualities/subtract.quality';\r\nimport { counterSetCountQuality } from './qualities/setCount.quality';\r\nimport { createConcept } from '../../model/concept';\r\nexport { countingStrategy, primedCountingStrategy } from './strategies/counting.strategy';\r\n\r\nexport type CounterState = {\r\n    count: number\r\n}\r\n\r\nexport const counterName = 'counter';\r\n\r\nconst initialCounterState: CounterState = {\r\n  count: 0\r\n};\r\n\r\nexport const createCounterConcept = () => {\r\n  return createConcept(\r\n    counterName,\r\n    initialCounterState,\r\n    [\r\n      counterAddQuality,\r\n      counterSubtractQuality,\r\n      counterSetCountQuality\r\n    ]\r\n  );\r\n};"},"For the asynchronous graph programming framework Stratimux and Counter Concept, generate a KeyedSelector for the Counter's count state property.":{"type":"project","content":"import { KeyedSelector, createConceptKeyedSelector } from '../../model/selector';\r\nimport { CounterState } from './counter.concept';\r\n\r\nexport const counterSelectCount: KeyedSelector = createConceptKeyedSelector<CounterState>('counter', 'count');"},"For the asynchronous graph programming framework Stratimux and Counter Concept, generate a quality that will increment the state's count by one.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { CounterState } from '../counter.concept';\r\nimport { counterSelectCount } from '../counter.selector';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  counterAdd,\r\n  counterAddType,\r\n  counterAddQuality\r\n] = createQualitySet({\r\n  type: 'Counter Add',\r\n  reducer: (state: CounterState) => {\r\n    return {\r\n      ...state,\r\n      count: state.count + 1\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator,\r\n  keyedSelectors: [counterSelectCount]\r\n});"},"For the asynchronous graph programming framework Stratimux and Counter Concept,\r\ngenerate a quality that set the state property count to the new count provided\r\nby the action's payload.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { CounterState } from '../counter.concept';\r\nimport { counterSelectCount } from '../counter.selector';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type CounterSetCountPayload = {\r\n  newCount: number\r\n}\r\nexport const [\r\n  counterSetCount,\r\n  counterSetCountType,\r\n  counterSetCountQuality\r\n] = createQualitySetWithPayload<CounterSetCountPayload>({\r\n  type: 'Counter set Count',\r\n  reducer: (state: CounterState, action) => {\r\n    const {newCount} = selectPayload<CounterSetCountPayload>(action);\r\n    return {\r\n      ...state,\r\n      count: newCount\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator,\r\n  keyedSelectors: [counterSelectCount]\r\n});"},"For the asynchronous graph programming framework Stratimux and Counter Concept, generate a quality that will decrement the state count by one.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { CounterState } from '../counter.concept';\r\nimport { counterSelectCount } from '../counter.selector';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  counterSubtract,\r\n  counterSubtractType,\r\n  counterSubtractQuality\r\n] = createQualitySet({\r\n  type: 'Counter Subtract',\r\n  reducer: (state: CounterState, action) => {\r\n    return {\r\n      ...state,\r\n      count: state.count - 1\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator,\r\n  keyedSelectors: [counterSelectCount]\r\n});"},"For the asynchronous graph programming framework Stratimux and Counter Concept,\r\ngenerate an ActionStrategy that will perform a series of counter actions that will\r\nultimately just increment the count by one.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concepts} from '../../../model/concept';\r\nimport { getSemaphore } from '../../../model/action';\r\nimport { counterAdd, counterAddType } from '../qualities/add.quality';\r\nimport { counterSubtract, counterSubtractType } from '../qualities/subtract.quality';\r\nimport { counterName } from '../counter.concept';\r\n\r\nexport const countingTopic = 'Counting Strategy';\r\nexport function countingStrategy(): ActionStrategy {\r\n  const stepFive = createActionNode(counterSubtract(), {\r\n    successNotes: {\r\n      preposition: 'and finally',\r\n      denoter: 'One.',\r\n    },\r\n  });\r\n  const stepFour = createActionNode(counterAdd(), {\r\n    successNode: stepFive,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n  });\r\n  const stepThree = createActionNode(counterAdd(), {\r\n    successNode: stepFour,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n  });\r\n  const stepTwo = createActionNode(counterSubtract(), {\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n  });\r\n  const stepOne = createActionNode(counterAdd(), {\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: countingTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the asynchronous graph programming framework Stratimux and Counter Concept,\r\ngenerate a strategy that will ultimately increment the Counter's count by one.\r\nThis strategy should likewise accept concepts to allow for a base Counter Concept to prime its action's semaphore.":{"type":"project","content":"export const primedCountingTopic = 'Counting Strategy with Primed Actions';\r\nexport function primedCountingStrategy(concepts: Concepts): ActionStrategy {\r\n  const addSemaphore = getSemaphore(concepts, counterName, counterAddType);\r\n  const subtractSemaphore = getSemaphore(concepts, counterName, counterSubtractType);\r\n  const stepFour = createActionNode(counterAdd(), {\r\n    semaphore: addSemaphore,\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'and finally',\r\n      denoter: 'One.',\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepThree = createActionNode(counterAdd(), {\r\n    semaphore: addSemaphore,\r\n    successNode: stepFour,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepTwo = createActionNode(counterSubtract(), {\r\n    semaphore: subtractSemaphore,\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepOne = createActionNode(counterAdd(), {\r\n    semaphore: subtractSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: primedCountingTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the asynchronous graph programming framework Stratimux generate the Experiment Concept that will be used in testing to confirm\r\ndifferent configurations of Stratimux to be provably terminating.":{"type":"project","content":"import { Mode, Quality, createConcept } from '../../model/concept';\r\nimport { Action } from '../../model/action';\r\nimport { PrincipleFunction } from '../../model/principle';\r\n\r\nexport type ExperimentState = {\r\n  actionQue: Action[],\r\n  mock: boolean,\r\n  id: number\r\n}\r\n\r\nexport const experimentName = 'experiment';\r\n\r\nexport const createExperimentState = (): ExperimentState => {\r\n  return {\r\n    actionQue: [],\r\n    mock: false,\r\n    id: 0,\r\n  };\r\n};\r\n\r\nexport const createExperimentConcept = (\r\n  state: Record<string, unknown>,\r\n  qualities?: Quality[],\r\n  principles?: PrincipleFunction[],\r\n  mode?: Mode[]) => {\r\n  return createConcept(\r\n    experimentName,\r\n    state,\r\n    qualities,\r\n    principles,\r\n    mode\r\n  );\r\n};"},"For the asynchronous graph programming framework Stratimux and Experiment Concept,\r\ngenerate a principle that observes the experiment's actionQue and dispatches\r\nin sequence upon each observation of state.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport { Action, primeAction } from '../../model/action';\r\nimport { PrincipleFunction } from '../../model/principle';\r\nimport { Concepts } from '../../model/concept';\r\nimport { UnifiedSubject, createStage, stageWaitForOpenThenIterate } from '../../model/stagePlanner';\r\nimport { selectUnifiedState } from '../../model/selector';\r\nimport { ExperimentState, experimentName } from './experiment.concept';\r\nimport { axiumRegisterStagePlanner } from '../axium/qualities/registerStagePlanner.quality';\r\nimport { axiumSelectOpen } from '../axium/axium.selector';\r\n\r\nexport const experimentActionQuePrinciple: PrincipleFunction = (\r\n  observer: Subscriber<Action>,\r\n  _concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  let readyToGo = false;\r\n  const plan = concepts$.plan('Experiment Principle Plan', [\r\n    stageWaitForOpenThenIterate(() => (axiumRegisterStagePlanner({conceptName: experimentName, stagePlanner: plan}))),\r\n    createStage((cpts, _) => {\r\n      const concepts = cpts;\r\n      const experimentState = selectUnifiedState<ExperimentState>(concepts, semaphore);\r\n      if (experimentState && experimentState.actionQue.length > 0) {\r\n        if (!readyToGo) {\r\n          readyToGo = true;\r\n          setTimeout(() => {\r\n            readyToGo = false;\r\n            const nextAction = experimentState.actionQue.shift();\r\n            if (nextAction) {\r\n              experimentState.actionQue = [... experimentState.actionQue];\r\n              concepts$.next(concepts);\r\n              observer.next(nextAction);\r\n            } else {\r\n              experimentState.actionQue = [];\r\n              concepts$.next(concepts);\r\n            }\r\n          }, 400);\r\n        }\r\n      }\r\n    })\r\n  ]);\r\n};"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will increment state by one.\r\nThen its method will asynchronously unify the state's id value onto the strategy.":{"type":"project","content":"import { Concepts } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createAsyncMethodWithState } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\nimport { Subject } from 'rxjs';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  experimentAsyncIterateIdThenReceiveInMethod,\r\n  experimentAsyncIterateIdThenReceiveInMethodType,\r\n  experimentAsyncIterateIdThenReceiveInMethodQuality\r\n] = createQualitySet({\r\n  type: 'Experiment asynchronously iterate ID then receive in Method via State',\r\n  reducer: (state: ExperimentState) => {\r\n    return {\r\n      ...state,\r\n      id: state.id + 1\r\n    };\r\n  },\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createAsyncMethodWithState<ExperimentState>((controller, action, state) => {\r\n      setTimeout(() => {\r\n        if (action.strategy) {\r\n          const data = strategyData_unifyData<ExperimentState>(action.strategy, {id: state.id});\r\n          const strategy = strategySuccess(action.strategy, data);\r\n          controller.fire(strategy);\r\n        }\r\n        controller.fire(action);\r\n      }, 50);\r\n    }, concepts$ as UnifiedSubject, semaphore as number),\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will check in the next action\r\nin the current strategy to the state's actionQue.":{"type":"project","content":"import { strategySuccess } from '../../../model/actionStrategy';\r\nimport { axiumConcludeType } from '../../axium/qualities/conclude.quality';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  experimentCheckInStrategy,\r\n  experimentCheckInStrategyType,\r\n  experimentCheckInStrategyQuality\r\n] = createQualitySet({\r\n  type: 'Experiment check in Action',\r\n  reducer: (state: ExperimentState, action) => {\r\n    if (action.strategy) {\r\n      const nextAction = strategySuccess(action.strategy);\r\n      if (nextAction.type !== axiumConcludeType) {\r\n        return {\r\n          ...state,\r\n          actionQue: [... state.actionQue, nextAction]\r\n        };\r\n      }\r\n    }\r\n    return {\r\n      ...state\r\n    };\r\n  }\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will increment the state's ID.\r\nThen debounce the action via the qualities method that will then unify the state's id into the strategy's data.":{"type":"project","content":"import { Concepts } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createAsyncMethodDebounceWithState } from '../../../model/method';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\nimport { Subject } from 'rxjs';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type ExperimentDebounceAsyncIterateIdThenReceiveInMethodPayload = {\r\n  setId: number;\r\n}\r\n\r\nexport const [\r\n  experimentDebounceAsyncIterateIdThenReceiveInMethod,\r\n  experimentDebounceAsyncIterateIdThenReceiveInMethodType,\r\n  experimentDebounceAsyncIterateIdThenReceiveInMethodQuality\r\n] = createQualitySetWithPayload<ExperimentDebounceAsyncIterateIdThenReceiveInMethodPayload>({\r\n  type: 'Debounce Experiment asynchronously iterate ID then receive in Method via State',\r\n  reducer: (state: ExperimentState) => {\r\n    return {\r\n      ...state,\r\n      id: state.id + 1\r\n    };\r\n  },\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createAsyncMethodDebounceWithState<ExperimentState>((controller, action, state) => {\r\n      setTimeout(() => {\r\n        const payload = selectPayload<ExperimentDebounceAsyncIterateIdThenReceiveInMethodPayload>(action);\r\n        if (action.strategy) {\r\n          const data = strategyData_unifyData<ExperimentState & ExperimentDebounceAsyncIterateIdThenReceiveInMethodPayload>(\r\n            action.strategy,\r\n            {\r\n              id: state.id,\r\n              setId: payload.setId\r\n            }\r\n          );\r\n          const strategy = strategySuccess(action.strategy, data);\r\n          controller.fire(strategy);\r\n        }\r\n        controller.fire(action);\r\n      }, 50);\r\n    }, concepts$ as UnifiedSubject, semaphore as number, 500)\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will asynchronously debounce the next action\r\nin the ongoing strategy.":{"type":"project","content":"import { defaultReducer } from '../../../model/concept';\r\nimport { createAsyncMethodDebounce } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  experimentAsyncDebounceNextActionNode,\r\n  experimentAsyncDebounceNextActionNodeType,\r\n  experimentAsyncDebounceNextActionNodeQuality\r\n] = createQualitySet({\r\n  type: 'Experiment will debounce incoming actions within set duration asynchronously',\r\n  reducer: defaultReducer,\r\n  methodCreator: () => createAsyncMethodDebounce((controller, action) => {\r\n    setTimeout(() => {\r\n      if (action.strategy) {\r\n        controller.fire(strategySuccess(action.strategy));\r\n      } else {\r\n        controller.fire(action);\r\n      }\r\n    }, 50);\r\n  }, 500)\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will iterate the state ID.\r\nThen debounce the quality of actions within a range. To dispatch the most recent action after the specified time elapses.\r\nThat will finally unify the state id and setId from the payload into the most recent strategies data field.":{"type":"project","content":"import { Concepts } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createMethodDebounceWithState } from '../../../model/method';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\nimport { Subject } from 'rxjs';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type ExperimentDebounceIterateIdThenReceiveInMethodPayload = {\r\n  setId: number;\r\n}\r\n\r\nexport const [\r\n  experimentDebounceIterateIdThenReceiveInMethod,\r\n  experimentDebounceIterateIdThenReceiveInMethodType,\r\n  experimentDebounceIterateIdThenReceiveInMethodQuality\r\n] = createQualitySetWithPayload<ExperimentDebounceIterateIdThenReceiveInMethodPayload>({\r\n  type: 'Experiment debounce iterate ID then receive in Method via State',\r\n  reducer: (state: ExperimentState) => {\r\n    return {\r\n      ...state,\r\n      id: state.id + 1\r\n    };\r\n  },\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createMethodDebounceWithState<ExperimentState>((action, state) => {\r\n      const payload = selectPayload<ExperimentDebounceIterateIdThenReceiveInMethodPayload>(action);\r\n      if (action.strategy) {\r\n        const data = strategyData_unifyData<ExperimentState & ExperimentDebounceIterateIdThenReceiveInMethodPayload>(action.strategy, {\r\n          id: state.id,\r\n          setId: payload.setId\r\n        });\r\n        const strategy = strategySuccess(action.strategy, data);\r\n        return strategy;\r\n      }\r\n      return action;\r\n    }, concepts$ as UnifiedSubject, semaphore as number, 500)\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will simply debounce actions till the most\r\nrecent. Then dispatch the most recent's next action via the supplied action strategy.":{"type":"project","content":"import { nullReducer } from '../../../model/concept';\r\nimport { createMethodDebounce } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  experimentDebounceNextActionNode,\r\n  experimentDebounceNextActionNodeType,\r\n  experimentDebounceNextActionNodeQuality\r\n] = createQualitySet({\r\n  type: 'Experiment will debounce incoming actions within set duration',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createMethodDebounce((action) => {\r\n    if (action.strategy) {\r\n      return strategySuccess(action.strategy);\r\n    } else {\r\n      return action;\r\n    }\r\n  }, 500)\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will iterate the ID and then\r\nset the id supplied to the method into the strategy's data field.":{"type":"project","content":"import { Concepts } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createMethodWithState } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\nimport { Subject } from 'rxjs';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  experimentIterateIdThenReceiveInMethod,\r\n  experimentIterateIdThenReceiveInMethodType,\r\n  experimentIterateIdThenReceiveInMethodQuality\r\n] = createQualitySet({\r\n  type: 'Experiment iterate ID then receive in Method via State',\r\n  reducer: (state: ExperimentState) => {\r\n    return {\r\n      ...state,\r\n      id: state.id + 1\r\n    };\r\n  },\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createMethodWithState<ExperimentState>((action, state) => {\r\n      if (action.strategy) {\r\n        const data = strategyData_unifyData<ExperimentState>(action.strategy, {id: state.id});\r\n        const strategy = strategySuccess(action.strategy, data);\r\n        return strategy;\r\n      }\r\n      return action;\r\n    }, concepts$ as UnifiedSubject, semaphore as number)\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will set mock to true.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  experimentMockToTrue,\r\n  experimentMockToTrueType,\r\n  experimentMockToTrueQuality,\r\n] = createQualitySet({\r\n  type: 'Experiment mock set to True',\r\n  reducer: (state: ExperimentState) => {\r\n    return {\r\n      ...state,\r\n      mock: true\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will recursively dispatch the incoming action,\r\nlimited via a control variable that is an arbitrary string array that is shifted until depleted.":{"type":"project","content":"import { Concepts } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createAsyncMethodWithState } from '../../../model/method';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { strategyRecurse, strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\nimport { Subject } from 'rxjs';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type ExperimentRecurseIterateId = {\r\n  controlling: string[]\r\n};\r\n\r\nexport const [\r\n  experimentRecurseIterateId,\r\n  experimentRecurseIterateIdType,\r\n  experimentRecurseIterateIdQuality\r\n] = createQualitySetWithPayload<ExperimentRecurseIterateId>({\r\n  type: 'Asynchronous experiment, recursively iterate ID and receive in Method via State',\r\n  reducer: (state: ExperimentState) => {\r\n    return {\r\n      ...state,\r\n      id: state.id + 1\r\n    };\r\n  },\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createAsyncMethodWithState<ExperimentState>((controller, action, state) => {\r\n      setTimeout(() => {\r\n        const payload = selectPayload<ExperimentRecurseIterateId>(action);\r\n        payload.controlling.shift();\r\n        if (action.strategy) {\r\n          const data = strategyData_unifyData<ExperimentState>(action.strategy, {id: state.id});\r\n          if (payload.controlling.length > 0) {\r\n            const strategy = strategyRecurse(action.strategy, {payload});\r\n            controller.fire(strategy);\r\n          } else {\r\n            const strategy = strategySuccess(action.strategy, data);\r\n            controller.fire(strategy);\r\n          }\r\n        }\r\n        controller.fire(action);\r\n      }, 50);\r\n    }, concepts$ as UnifiedSubject, semaphore as number)\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will iterate the id then\r\nasynchronously dispatch the next action in the incoming strategy, then throttle the quality for a period of time.":{"type":"project","content":"import { Concepts } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createAsyncMethodThrottleWithState } from '../../../model/method';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\nimport { Subject } from 'rxjs';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type ExperimentThrottleAsyncIterateIdThenReceiveInMethodPayload = {\r\n  setId: number;\r\n}\r\n\r\nexport const [\r\n  experimentThrottleAsyncIterateIdThenReceiveInMethod,\r\n  experimentThrottleAsyncIterateIdThenReceiveInMethodType,\r\n  experimentThrottleAsyncIterateIdThenReceiveInMethodQuality\r\n] = createQualitySetWithPayload<ExperimentThrottleAsyncIterateIdThenReceiveInMethodPayload>({\r\n  type: 'Action Debounce Experiment asynchronously iterate ID then receive in Method via State',\r\n  reducer: (state: ExperimentState) => {\r\n    return {\r\n      ...state,\r\n      id: state.id + 1\r\n    };\r\n  },\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createAsyncMethodThrottleWithState<ExperimentState>((controller, action, state) => {\r\n      setTimeout(() => {\r\n        const payload = selectPayload<ExperimentThrottleAsyncIterateIdThenReceiveInMethodPayload>(action);\r\n        if (action.strategy) {\r\n          const data = strategyData_unifyData<ExperimentState & ExperimentThrottleAsyncIterateIdThenReceiveInMethodPayload>(\r\n            action.strategy,\r\n            {\r\n              id: state.id,\r\n              setId: payload.setId\r\n            }\r\n          );\r\n          const strategy = strategySuccess(action.strategy, data);\r\n          controller.fire(strategy);\r\n        }\r\n        controller.fire(action);\r\n      }, 50);\r\n    }, concepts$ as UnifiedSubject, semaphore as number, 500)\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will iterate the id, then\r\ndispatch the next action in the incoming strategy, then throttle the quality for a period of time.":{"type":"project","content":"import { Concepts } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createMethodThrottleWithState } from '../../../model/method';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\nimport { Subject } from 'rxjs';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type ExperimentThrottleIterateIdThenReceiveInMethodPayload = {\r\n  setId: number;\r\n}\r\n\r\nexport const [\r\n  experimentThrottleIterateIdThenReceiveInMethod,\r\n  experimentThrottleIterateIdThenReceiveInMethodType,\r\n  experimentThrottleIterateIdThenReceiveInMethodQuality\r\n] = createQualitySetWithPayload<ExperimentThrottleIterateIdThenReceiveInMethodPayload>({\r\n  type: 'Experiment throttle iterate ID then receive in Method via State',\r\n  reducer: (state: ExperimentState) => {\r\n    return {\r\n      ...state,\r\n      id: state.id + 1\r\n    };\r\n  },\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createMethodThrottleWithState<ExperimentState>((action, state) => {\r\n      const payload = selectPayload<ExperimentThrottleIterateIdThenReceiveInMethodPayload>(action);\r\n      if (action.strategy) {\r\n        const data = strategyData_unifyData<ExperimentState & ExperimentThrottleIterateIdThenReceiveInMethodPayload>(action.strategy, {\r\n          id: state.id,\r\n          setId: payload.setId\r\n        });\r\n        const strategy = strategySuccess(action.strategy, data);\r\n        return strategy;\r\n      }\r\n      return action;\r\n    }, concepts$ as UnifiedSubject, semaphore as number, 500)\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will asynchronously dispatch the next\r\naction in the incoming strategy via an inner timer.":{"type":"project","content":"import { nullReducer } from '../../../model/concept';\r\nimport { createAsyncMethod } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { axiumConclude } from '../../axium/qualities/conclude.quality';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  experimentTimerEmitAction,\r\n  experimentTimerEmitActionType,\r\n  experimentTimerEmitActionQuality\r\n] = createQualitySet({\r\n  type: 'Experiment create async method with timer, to return action',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createAsyncMethod((controller, action) => {\r\n    setTimeout(() => {\r\n      if (action.strategy) {\r\n        controller.fire(strategySuccess(action.strategy));\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    }, 50);\r\n  })\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a quality that will asynchronously dispatch the\r\nnext action in the ActionStrategy via a timeout. While appending to the strategy's data field the current mock value from state.":{"type":"project","content":"import { Concepts, nullReducer } from '../../../model/concept';\r\nimport { createAsyncMethodWithState } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { axiumConclude } from '../../axium/qualities/conclude.quality';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { Subject } from 'rxjs';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  experimentTimerEmitActionWithState,\r\n  experimentTimerEmitActionWithStateType,\r\n  experimentTimerEmitActionWithStateQuality\r\n] = createQualitySet({\r\n  type: 'Experiment create async method with timer and state, to return action',\r\n  reducer: nullReducer,\r\n  methodCreator: (concepts$?: Subject<Concepts>, semaphore?: number) =>\r\n    createAsyncMethodWithState<ExperimentState>((controller, action, state) => {\r\n      setTimeout(() => {\r\n        if (action.strategy) {\r\n          const data = strategyData_unifyData(action.strategy, { mock: state.mock });\r\n          controller.fire(strategySuccess(action.strategy, data));\r\n        } else {\r\n          controller.fire(axiumConclude());\r\n        }\r\n      }, 50);\r\n    }, concepts$ as UnifiedSubject, semaphore as number)\r\n});"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a strategy that will debounce next action to be dispatched.\r\nThen when the debounce time expires enacts the counter add one quality.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { counterAdd } from '../../counter/qualities/add.quality';\r\nimport { experimentAsyncDebounceNextActionNode } from '../qualities/debounceAsyncNextActionNode.quality';\r\n\r\nexport const experimentAsyncDebounceAddOneTopic = 'Async debounce add one';\r\nexport function experimentAsyncDebounceAddOneStrategy(): ActionStrategy {\r\n  const stepTwo = createActionNode(counterAdd(), {\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    agreement: 1000,\r\n  });\r\n  const stepOne = createActionNode(experimentAsyncDebounceNextActionNode(), {\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    agreement: 1000,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentAsyncDebounceAddOneTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate an ActionStrategy that will dispatch the\r\nasync iterate id that will later notify the Axium of its conclusion.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentAsyncIterateIdThenReceiveInMethod } from '../qualities/asyncIterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentAsyncIterateIdThenAddToDataTopic = 'Async iterate experiment ID then add to strategy data';\r\nexport function experimentAsyncIterateIdThenAddToData(): ActionStrategy {\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentAsyncIterateIdThenAddToDataTopic,\r\n    initialNode: createActionNode(experimentAsyncIterateIdThenReceiveInMethod())\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate a strategy that will debounce the step in the strategy.\r\nThe final step of the strategy will increment the Counter's count by one.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { counterAdd } from '../../counter/qualities/add.quality';\r\nimport { experimentDebounceNextActionNode } from '../qualities/debounceNextActionNode.quality';\r\n\r\nexport const experimentDebounceAddOneTopic = 'Debounce add one';\r\nexport function experimentDebounceAddOneStrategy(): ActionStrategy {\r\n  const stepTwo = createActionNode(counterAdd(), {\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    agreement: 1000,\r\n  });\r\n  const stepOne = createActionNode(experimentDebounceNextActionNode(), {\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    agreement: 1000,\r\n  });\r\n\r\n  return createStrategy({\r\n    topic: experimentDebounceAddOneTopic,\r\n    initialNode: stepOne,\r\n  });\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept,\r\ngenerate a single step strategy that will iterate the Experiment state ID,\r\nthen debounce and asynchronously notify the Axium of the strategy's conclusion.":{"type":"project","content":"import { ActionStrategy, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentDebounceAsyncIterateIdThenReceiveInMethod } from '../qualities/debounceAsyncIterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentDebounceAsyncIterateIdThenAddToDataTopic = 'Debounce async iterate experiment ID then add to strategy data';\r\nexport function experimentDebounceAsyncIterateIdThenAddToData(setId: number): ActionStrategy {\r\n  return createStrategy({\r\n    topic: experimentDebounceAsyncIterateIdThenAddToDataTopic,\r\n    initialNode: createActionNode(experimentDebounceAsyncIterateIdThenReceiveInMethod({setId}))\r\n  });\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept, generate an ActionStrategy that will iterate the Experiment ID,\r\nthen debounce notify the Axium of its conclusion while appending the ID to its data field.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentDebounceIterateIdThenReceiveInMethod } from '../qualities/debounceIterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentDebounceIterateIdThenAddToDataTopic = 'Debounce iterate experiment ID then add to strategy data';\r\nexport function experimentDebounceIterateIdThenAddToData(setId: number): ActionStrategy {\r\n  return createStrategy({\r\n    topic: experimentDebounceIterateIdThenAddToDataTopic,\r\n    initialNode: createActionNode(experimentDebounceIterateIdThenReceiveInMethod({setId}))\r\n  });\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will take ownership of the Counter's count state property.\r\nThen proceed to increment and decrement the count over a sequence that in total only increments to count by one.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concepts} from '../../../model/concept';\r\nimport { getSemaphore } from '../../../model/action';\r\nimport { counterAdd, counterAddType } from '../../counter/qualities/add.quality';\r\nimport { counterSubtract, counterSubtractType } from '../../counter/qualities/subtract.quality';\r\nimport { counterName } from '../../counter/counter.concept';\r\nimport { counterSelectCount } from '../../counter/counter.selector';\r\nimport { ownershipBackTrack, ownershipBackTrackType } from '../../ownership/qualities/backTrack.quality';\r\nimport { ownershipName } from '../../ownership/ownership.concept';\r\n\r\nexport const experimentCountingTopic = 'Counting Strategy';\r\nexport function experimentCountingStrategy(): ActionStrategy {\r\n  const backTrack = createActionNode(ownershipBackTrack());\r\n  const stepFive = createActionNode(counterSubtract(),{\r\n    successNotes: {\r\n      preposition: 'and finally',\r\n      denoter: 'One.',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepFour = createActionNode(counterAdd(), {\r\n    successNode: stepFive,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepThree = createActionNode(counterAdd(), {\r\n    successNode: stepFour,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepTwo = createActionNode(counterSubtract(), {\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepOne = createActionNode(counterAdd(), {\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n\r\n  return createStrategy({\r\n    topic: experimentCountingTopic,\r\n    initialNode: stepOne,\r\n  });\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will take ownership of the Counter's count state property.\r\nThen prime each step to avoid a semaphore look up at run time. That will then increment and decrement the count over a sequence that\r\nin total only increments to count by one. But only if it has ownership of the Counter's count state property.\r\nIf the count is owned by another strategy. The strategy will enact a back tracking action.\r\nSo that the original action may be dispatched into the Axium once ownership has been relieved from the other strategies.":{"type":"project","content":"export const experimentPrimedCountingTopic = 'Counting Strategy with Primed Actions';\r\nexport function experimentPrimedCountingStrategy(concepts: Concepts): ActionStrategy {\r\n  const addSemaphore = getSemaphore(concepts, counterName, counterAddType);\r\n  const subtractSemaphore = getSemaphore(concepts, counterName, counterSubtractType);\r\n  const backTrackSemaphore = getSemaphore(concepts, ownershipName, ownershipBackTrackType);\r\n  const backTrack = createActionNode(ownershipBackTrack(), {\r\n    semaphore: backTrackSemaphore,\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n  const stepFour = createActionNode(counterAdd(), {\r\n    semaphore: addSemaphore,\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'and finally',\r\n      denoter: 'One.',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepThree = createActionNode(counterAdd(), {\r\n    semaphore: addSemaphore,\r\n    successNode: stepFour,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepTwo = createActionNode(counterSubtract(), {\r\n    semaphore: subtractSemaphore,\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepOne = createActionNode(counterAdd(), {\r\n    semaphore: subtractSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentPrimedCountingTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept,\r\ngenerate an ActionStrategy that will iterate the Experiment's state ID.\r\nThen notify the Axium of its conclusion while appending the ID to the strategy's data field.":{"type":"project","content":"import { ActionStrategy, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentIterateIdThenReceiveInMethod } from '../qualities/iterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentIterateIdThenAddToDataTopic = 'Iterate experiment ID then add to strategy data';\r\nexport function iterateIdThenAddToData(): ActionStrategy {\r\n  return createStrategy({\r\n    topic: experimentIterateIdThenAddToDataTopic,\r\n    initialNode: createActionNode(experimentIterateIdThenReceiveInMethod())\r\n  });\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will punt a counting strategy in favor of a new\r\nstrategy that will check in the punted strategy into an actionQue. That will later be dispatched via a principle.":{"type":"project","content":"import { ActionStrategy, createActionNode, createStrategy, strategyPunt } from '../../../model/actionStrategy';\r\nimport { counterSelectCount } from '../../counter/counter.selector';\r\nimport { experimentCheckInStrategy } from '../qualities/checkInStrategy.quality';\r\nimport { experimentCountingStrategy } from './experimentCounting.strategy';\r\n\r\nexport const experimentPuntCountingStrategyTopic = 'This will Punt the Counting Strategy into the Experiment\\'s Action Que';\r\nexport function experimentPuntCountingStrategy(): ActionStrategy {\r\n  const stepOne = createActionNode(experimentCheckInStrategy(), {\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n\r\n  return strategyPunt(experimentCountingStrategy(), createStrategy({\r\n    topic: experimentPuntCountingStrategyTopic,\r\n    initialNode: stepOne,\r\n  }));\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will cursively iterate the Experiment's state ID,\r\nthat is limited by an incoming array of strings.":{"type":"project","content":"import { ActionStrategy, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentRecurseIterateId } from '../qualities/recurseIncrementId.quality';\r\n\r\nexport const experimentRecursivelyIterateIdTopic = 'Recursively iterate experiment ID then add to strategy data';\r\nexport function experimentRecursivelyIterateId(controlling: string[]): ActionStrategy {\r\n  return createStrategy({\r\n    topic: experimentRecursivelyIterateIdTopic,\r\n    initialNode: createActionNode(experimentRecurseIterateId({controlling}))\r\n  });\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept,\r\ngenerate an ActionStrategy that will iterate the Experiment's ID property,\r\nthen throttle the next action to be asynchronously dispatched from the quality's method. That will then set the current ID it has received\r\nto the strategy's data field.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport {\r\n  experimentThrottleAsyncIterateIdThenReceiveInMethod\r\n} from '../qualities/throttleAsyncIterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentThrottleAsyncIterateIdThenAddToDataTopic = 'Throttle Async iterate experiment ID then add to strategy data';\r\nexport function experimentThrottleAsyncIterateIdThenAddToData(setId: number): ActionStrategy {\r\n  return createStrategy({\r\n    topic: experimentThrottleAsyncIterateIdThenAddToDataTopic,\r\n    initialNode: createActionNode(experimentThrottleAsyncIterateIdThenReceiveInMethod({setId}))\r\n  });\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will iterate an ID state property for the Concept\r\nExperiment. Then dispatch the first action for a period that is received in the action's method. That will then\r\nunify the the ID the method has received onto the strategy's state field. Then finally notify the Axium of the\r\nstrategy's conclusion.":{"type":"project","content":"import { ActionStrategy, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentThrottleIterateIdThenReceiveInMethod } from '../qualities/throttleIterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentThrottleIterateIdThenAddToDataTopic = 'Throttle iterate experiment ID then add to strategy data';\r\nexport function experimentThrottleIterateIdThenAddToData(setId: number): ActionStrategy {\r\n  return createStrategy({\r\n    topic: experimentThrottleIterateIdThenAddToDataTopic,\r\n    initialNode: createActionNode(experimentThrottleIterateIdThenReceiveInMethod({setId}))\r\n  });\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will eventually set the Experiment's mock property\r\nto true. This is accomplished via a timer emit action quality. That will then finally dispatch the setting action.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentMockToTrue } from '../qualities/mockToTrue.quality';\r\nimport { experimentTimerEmitAction } from '../qualities/timerEmitAction.quality';\r\n\r\nexport const experimentTimedMockToTrueTopic = 'This will use a async method to eventually set mock to True';\r\nexport function experimentTimedMockToTrue(): ActionStrategy {\r\n  const stepTwo = createActionNode(experimentMockToTrue());\r\n  const stepOne = createActionNode(experimentTimerEmitAction(), {\r\n    successNode: stepTwo,\r\n  });\r\n\r\n  return createStrategy({\r\n    topic: experimentTimedMockToTrueTopic,\r\n    initialNode: stepOne,\r\n  });\r\n}"},"For the asynchronous graph programming framework Stratimux and Experiment Concept,\r\ngenerate an ActionStrategy that will in the final step the Experiment's mock value to\r\ntrue. While attaching the original mock value to the strategy's data field. Then once its timer expires, dispatch the next\r\nstep that will finally set the value to true. Then notify the axium of the strategy's successful conclusion.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentMockToTrue } from '../qualities/mockToTrue.quality';\r\nimport { experimentTimerEmitActionWithState } from '../qualities/timerEmitActionWithState.quality';\r\n\r\nexport const experimentTimedMockToTrueWithStateTopic =\r\n  'This will use a async method to eventually set mock to True via State and append mock to strategy data.';\r\nexport function timedMockToTrueWithState(): ActionStrategy {\r\n  const stepTwo = createActionNode(experimentMockToTrue());\r\n  const stepOne = createActionNode(experimentTimerEmitActionWithState(), {\r\n    successNode: stepTwo,\r\n  });\r\n\r\n  return createStrategy({\r\n    topic: experimentTimedMockToTrueWithStateTopic,\r\n    initialNode: stepOne,\r\n  });\r\n}"},"For the asynchronous graph programming framework Stratimux generate the Ownership Concept,\r\nthat will manage Stratimux's locking functionality if loaded into the Axium.\r\nThis is accomplished via a ticketing system that will set actions to pending if their associated property is currently owned via strategy\r\nthat is currently performing operations within the Axium.":{"type":"project","content":"import { createConcept } from '../../model/concept';\r\nimport { Action } from '../../model/action';\r\nimport { ownershipMode } from './ownership.mode';\r\nimport { ownershipInitializeOwnershipQuality } from './qualities/initializeOwnership.quality';\r\nimport { ownershipExpirationPrinciple, ownershipPrinciple } from './ownership.principle';\r\nimport { OwnershipLedger, createOwnershipLedger } from '../../model/ownership';\r\nimport { ownershipBackTrackQuality } from './qualities/backTrack.quality';\r\nimport { ownershipClearPayloadStubsQuality } from './qualities/clearPayloadStubs.quality';\r\nimport { ownershipClearStrategyStubsFromLedgerAndSelfQuality } from './qualities/clearStrategyStubsFromLedgerAndSelf.quality';\r\nimport { ownershipClearPendingActionsQuality } from './qualities/clearPendingActions.quality';\r\nimport { ownershipClearPendingActionsOfStrategyQuality } from './qualities/clearPendingActionsOfStrategy.quality';\r\nimport { ownershipResetOwnershipLedgerQuality } from './qualities/resetOwnershipLedger.quality';\r\n\r\nexport type OwnershipState = {\r\n  initialized: boolean;\r\n  ownershipLedger: OwnershipLedger;\r\n  pendingActions: Action[],\r\n  isResponsibleForMode: boolean;\r\n}\r\n\r\nexport const ownershipName = 'ownership';\r\n/**\r\n * @param isResponsibleForMode If not set, ownership assumes responsibility.\r\n */\r\nconst createOwnershipState = (isResponsibleForMode?: boolean): OwnershipState => {\r\n  return {\r\n    initialized: false,\r\n    ownershipLedger: createOwnershipLedger(),\r\n    pendingActions: [],\r\n    isResponsibleForMode: isResponsibleForMode ? isResponsibleForMode : true\r\n  };\r\n};\r\n\r\nexport const createOwnershipConcept = (isResponsibleForMode?: boolean) => {\r\n  return createConcept(\r\n    ownershipName,\r\n    createOwnershipState(isResponsibleForMode ? isResponsibleForMode : true),\r\n    [\r\n      ownershipInitializeOwnershipQuality,\r\n      ownershipBackTrackQuality,\r\n      ownershipClearPayloadStubsQuality,\r\n      ownershipClearStrategyStubsFromLedgerAndSelfQuality,\r\n      ownershipClearPendingActionsQuality,\r\n      ownershipClearPendingActionsOfStrategyQuality,\r\n      ownershipResetOwnershipLedgerQuality\r\n    ],\r\n    [\r\n      ownershipPrinciple,\r\n      ownershipExpirationPrinciple\r\n    ],\r\n    [ownershipMode]\r\n  );\r\n};"},"For the asynchronous graph programming framework Stratimux and Ownership Concept,\r\ngenerate mode that will govern the ownership system.\r\nThis mode will pay attention to an ActionStrategy's assigned KeyedSelector and if it currently does not have\r\nownership of the value that the selector would return via the selectSlice helper function.\r\nOwnership will add that action to its actionList. That will then be monitored via an ownership principle.\r\nThis mode will also relieve ownership upon receiving concluding parts of a strategy, such as conclusion, or even\r\na bad action that signifies that the associated action was invalidated.":{"type":"project","content":"import { Subject } from 'rxjs';\r\nimport { Action } from '../../model/action';\r\nimport { Concepts } from '../../model/concept';\r\nimport { Mode } from '../../model/concept';\r\nimport { permissiveMode, blockingMode } from '../axium/axium.mode';\r\nimport { checkIn, clearStubs, ownershipShouldBlock, updateAddToPendingActions } from '../../model/ownership';\r\nimport { ActionStrategy, strategyFailed } from '../../model/actionStrategy';\r\nimport { UnifiedSubject } from '../../model/stagePlanner';\r\nimport { axiumAppendActionListToDialog } from '../axium/qualities/appendActionListToDialog.quality';\r\nimport { AxiumState } from '../axium/axium.concept';\r\nimport { failureConditions, strategyData_appendFailure } from '../../model/actionStrategyData';\r\n\r\nexport const ownershipMode: Mode = (\r\n  [_action, _concepts, action$, concepts$] : [Action, Concepts, Subject<Action>, UnifiedSubject]\r\n) => {\r\n  let action = _action;\r\n  let concepts = _concepts;\r\n  const conceptsSize = Object.keys(concepts).length;\r\n  let finalMode: Mode = permissiveMode;\r\n  const axiumState = concepts[0].state as AxiumState;\r\n  // Logical Determination: setBlockingModeType\r\n  if (action.semaphore[3] === 4) {\r\n    finalMode = blockingMode;\r\n  } else {\r\n    // This assumes that ownership will be treated as the new default mode.\r\n    finalMode = (concepts[0].mode as Mode[])[1];\r\n  }\r\n  // Logical Determination: axiumConcludeType\r\n  // If generation is set to -1, then the action is not primed.\r\n  //  Therefore we pass straight to finalMode which will recall this Mode after priming the action.\r\n  //  This guarantees that action beyond this function will have a semaphore not set to [0, 0, -1, 0]\r\n  if (conceptsSize > 1) {\r\n    if (action.semaphore[3] !== 3 && action.semaphore[3] !== 1 && action.semaphore[2] !== axiumState.generation) {\r\n    // Check In Logic\r\n      const shouldBlock = ownershipShouldBlock(concepts, action);\r\n      if (shouldBlock) {\r\n        if (action.strategy) {\r\n          const strategy = action.strategy;\r\n          if (action.strategy.currentNode.failureNode === null) {\r\n          // This assumes that the Strategy does not account for the Block\r\n            let nextAction = strategyFailed(\r\n              strategy,\r\n              strategyData_appendFailure(strategy, failureConditions.ownershipBlocked)\r\n            );\r\n            // Logical Determination: axiumConcludeType\r\n            // eslint-disable-next-line max-depth\r\n            if (nextAction.semaphore[3] === 3) {\r\n              concepts = clearStubs(concepts, nextAction.strategy as ActionStrategy);\r\n              nextAction = axiumAppendActionListToDialog({\r\n                actionList: action.strategy.actionList,\r\n                strategyTopic: action.strategy.topic,\r\n                strategyData: action.strategy.data\r\n              });\r\n            }\r\n            finalMode([nextAction, concepts, action$, concepts$]);\r\n          } else {\r\n          // This assumes that the Strategy is accounting for the Block\r\n            // console.log('Check Action Failed1', action);\r\n            [concepts, action] = checkIn(concepts, action);\r\n            const nextAction = strategyFailed(\r\n              strategy,\r\n              strategyData_appendFailure(strategy, failureConditions.ownershipBlocked)\r\n            );\r\n            concepts = updateAddToPendingActions(concepts, nextAction);\r\n            concepts$.next(concepts);\r\n          }\r\n        }  else {\r\n        // Principle is then responsible to dispatch these actions;\r\n          concepts = updateAddToPendingActions(concepts, action);\r\n          concepts$.next(concepts);\r\n        }\r\n      // } else if (action.keyedSelectors) {\r\n      } else if (action.strategy) {\r\n        [concepts, action] = checkIn(concepts, action);\r\n        finalMode([action, concepts, action$, concepts$]);\r\n      } else {\r\n      // Free to Run\r\n        finalMode([action, concepts, action$, concepts$]);\r\n      }\r\n    // Logical Determination: axiumConcludeType\r\n    } else if (action.semaphore[3] !== 3 && action.semaphore[1] !== 1) {\r\n      finalMode([action, concepts, action$, concepts$]);\r\n\r\n    // Logical Determination: axiumConcludeType, axiumBadActionType\r\n    } else if (action.strategy?.stubs && (action.semaphore[3] === 3 || action.semaphore[3] === 1)) {\r\n      concepts = clearStubs(concepts, action.strategy);\r\n      concepts$.next(concepts);\r\n      if (action.semaphore[3] === 1) {\r\n        finalMode([action, concepts, action$, concepts$]);\r\n      }\r\n    } else if (action.semaphore[3] === 1) {\r\n      finalMode([action, concepts, action$, concepts$]);\r\n    }\r\n  } else {\r\n    finalMode([action, concepts, action$, concepts$]);\r\n  }\r\n};"},"For the asynchronous graph programming framework Stratimux and Ownership Concept,\r\ngenerate a principle will manage the ownership's pendingActions based upon the current\r\nownershipLedger's contents. Only actions that are first in all lines of their tickets set the the strategy's KeyedSelectors,\r\nmay be dispatched into the Axium. This principle will also clear duplicate strategies, and handle actions if their agreement has expired.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport { Concepts } from '../../model/concept';\r\nimport { PrincipleFunction } from '../../model/principle';\r\nimport { OwnershipState, ownershipName} from '../ownership/ownership.concept';\r\nimport { ownershipSetOwnershipModeStrategy } from './strategies/setOwnerShipMode.strategy';\r\nimport { Action, areSemaphoresEqual, createAction, primeAction } from '../../model/action';\r\nimport { selectUnifiedState } from '../../model/selector';\r\nimport { strategyBegin } from '../../model/actionStrategy';\r\nimport { OwnershipTicket, createOwnershipLedger, isActionReady } from '../../model/ownership';\r\nimport { UnifiedSubject, createStage, stageWaitForOpenThenIterate, stageWaitForOwnershipThenIterate  } from '../../model/stagePlanner';\r\nimport { AxiumBadActionPayload, axiumBadActionType } from '../axium/qualities/badAction.quality';\r\nimport { axiumRegisterStagePlanner } from '../axium/qualities/registerStagePlanner.quality';\r\nimport { failureConditions, strategyData_appendFailure } from '../../model/actionStrategyData';\r\n\r\nfunction denoteExpiredPending(action: Action): Action {\r\n  if (action.strategy) {\r\n    const strategy = action.strategy;\r\n    action.strategy.data = strategyData_appendFailure(strategy, failureConditions.ownershipExpired);\r\n  }\r\n  return action;\r\n}\r\n\r\nexport const ownershipPrinciple: PrincipleFunction = (\r\n  observer: Subscriber<Action>,\r\n  _concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  let initDispatch = false;\r\n  let finalCheck = true;\r\n  const plan = concepts$.plan('ownership Principle Plan', [\r\n    stageWaitForOpenThenIterate(() => (axiumRegisterStagePlanner({conceptName: ownershipName, stagePlanner: plan}))),\r\n    createStage((cpts, _) => {\r\n      let concepts = cpts;\r\n      let ownershipState = selectUnifiedState<OwnershipState>(concepts, semaphore);\r\n      if (ownershipState?.initialized) {\r\n        // This will be the point of dispatch of Qued Actions\r\n        let newAction;\r\n        if (ownershipState.pendingActions.length > 0) {\r\n          // One Action at a Time\r\n          for (const action of ownershipState.pendingActions) {\r\n            let readyToGo = false;\r\n            [concepts, readyToGo] = isActionReady(concepts, action);\r\n            if (readyToGo) {\r\n              newAction = action;\r\n              break;\r\n            }\r\n          }\r\n          if (newAction) {\r\n            ownershipState = selectUnifiedState(concepts, semaphore) as OwnershipState;\r\n            const newPendingActions = [];\r\n            for (const pending of ownershipState.pendingActions) {\r\n              if (!areSemaphoresEqual(pending, newAction) && pending.expiration !== newAction.expiration) {\r\n                newPendingActions.push(pending);\r\n              } else if (areSemaphoresEqual(pending, newAction) && pending.expiration !== newAction.expiration) {\r\n                newPendingActions.push(pending);\r\n              }\r\n            }\r\n            ownershipState.pendingActions = [...newPendingActions];\r\n            concepts$.next(concepts);\r\n            observer.next(newAction);\r\n          } else if (!newAction && ownershipState.pendingActions.length !== 0) {\r\n            const payload: AxiumBadActionPayload = {\r\n              badActions: []\r\n            };\r\n            const newPending: Action[] = [];\r\n            for (const pending of ownershipState.pendingActions) {\r\n              if (pending.expiration < Date.now()) {\r\n                payload.badActions.push(denoteExpiredPending(pending));\r\n              } else {\r\n                newPending.push(pending);\r\n              }\r\n            }\r\n            if (payload.badActions.length > 0) {\r\n              newAction = createAction(axiumBadActionType, payload);\r\n              ownershipState.pendingActions = newPending;\r\n              concepts$.next(concepts);\r\n              observer.next(newAction);\r\n            } else if (finalCheck) {\r\n              finalCheck = false;\r\n              setTimeout(() => {\r\n                finalCheck = true;\r\n                concepts$.next(concepts);\r\n              }, 200);\r\n            }\r\n          }\r\n        }\r\n      } else if (!initDispatch && !ownershipState?.initialized && ownershipState?.isResponsibleForMode) {\r\n        initDispatch = true;\r\n        observer.next(\r\n          strategyBegin(\r\n            ownershipSetOwnershipModeStrategy(concepts, 'Ownership')\r\n          )\r\n        );\r\n      }\r\n    })\r\n  ]);\r\n};"},"For the asynchronous graph programming framework Stratimux and Ownership Concept, generate a principle that manage clear lines of expired tickets.\r\nThis functionality is chiefly important for Actions that have moved off the current process, but will return after completing\r\ntheir strategies in outside Axiums.":{"type":"project","content":"export const ownershipExpirationPrinciple: PrincipleFunction = (\r\n  _: Subscriber<Action>,\r\n  _concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  const plan = concepts$.plan('ownership Principle Plan', [\r\n    stageWaitForOwnershipThenIterate(() => (axiumRegisterStagePlanner({conceptName: ownershipName, stagePlanner: plan}))),\r\n    createStage((cpts, __) => {\r\n      const concepts = cpts;\r\n      const ownershipState = selectUnifiedState<OwnershipState>(concepts, semaphore);\r\n      if (ownershipState?.initialized) {\r\n        let modified = false;\r\n        const newLedger = createOwnershipLedger();\r\n        for (const [key, line] of ownershipState.ownershipLedger.entries()) {\r\n          const expiredTickets: OwnershipTicket[] = [];\r\n          const newLine: OwnershipTicket[] = [];\r\n          for (const ticket of line) {\r\n            if (ticket.expiration > Date.now()) {\r\n              expiredTickets.push(ticket);\r\n            } else {\r\n              newLine.push(ticket);\r\n            }\r\n          }\r\n          if (expiredTickets.length > 0 && newLine.length > 0) {\r\n            modified = true;\r\n            newLedger.set(key, newLine);\r\n          }\r\n        }\r\n        if (modified) {\r\n          ownershipState.ownershipLedger = newLedger;\r\n          concepts$.next(concepts);\r\n        }\r\n      }\r\n    })\r\n  ]);\r\n};"},"For the asynchronous graph programming framework Stratimux and Ownership Concept, generate a series of KeyedSelectors for the ownership state.":{"type":"project","content":"import { KeyedSelector, createConceptKeyedSelector } from '../../model/selector';\r\nimport { OwnershipState } from './ownership.concept';\r\n\r\nexport const ownershipSelectLedger: KeyedSelector = createConceptKeyedSelector<OwnershipState>('ownership', 'ownershipLedger');\r\n\r\nexport const ownershipSelectInitialized: KeyedSelector = createConceptKeyedSelector<OwnershipState>('ownership', 'initialized');"},"For the asynchronous graph programming framework Stratimux and Ownership Concept, generate a quality that will back track the provided strategy.":{"type":"project","content":"import { nullReducer } from '../../../model/concept';\r\nimport { strategyBackTrack } from '../../../model/actionStrategy';\r\nimport { createMethod } from '../../../model/method';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  ownershipBackTrack,\r\n  ownershipBackTrackType,\r\n  ownershipBackTrackQuality\r\n] = createQualitySet({\r\n  type: 'backtracking to previous ActionNode',\r\n  reducer: nullReducer,\r\n  methodCreator: () => createMethod((action) => {\r\n    if (action.strategy) {\r\n      const newAction = strategyBackTrack(action.strategy);\r\n      return newAction;\r\n    } else {\r\n      return action;\r\n    }\r\n  })\r\n});"},"For the asynchronous graph programming framework Stratimux and Ownership Concept,\r\ngenerate a quality that will clear the provided stubs from the current Ownership Ledger.\r\nIf no tickets exist within a line, delete that line from the ledger.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { OwnershipState } from '../ownership.concept';\r\nimport { OwnershipTicket, OwnershipTicketStub } from '../../../model/ownership';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type OwnershipClearPayloadStubsPayload = {\r\n  stubs: OwnershipTicketStub[]\r\n};\r\n\r\nexport const [\r\n  ownershipClearPayloadStubs,\r\n  ownershipClearPayloadStubsType,\r\n  ownershipClearPayloadStubsQuality\r\n] = createQualitySetWithPayload<OwnershipClearPayloadStubsPayload>({\r\n  type: 'clear payload Stubs from Ownership Ledger',\r\n  reducer: (state: OwnershipState, action) => {\r\n    const stubs = selectPayload<OwnershipClearPayloadStubsPayload>(action).stubs;\r\n    const ownershipLedger = state.ownershipLedger;\r\n    stubs.forEach(ticketStub => {\r\n      const line = ownershipLedger.get(ticketStub.key);\r\n      if (line) {\r\n        const newLine = [] as OwnershipTicket[];\r\n        for (const stub of line) {\r\n          if (stub.ticket !== ticketStub.ticket) {\r\n            newLine.push(stub);\r\n          }\r\n        }\r\n        if (newLine.length === 0) {\r\n          ownershipLedger.delete(ticketStub.key);\r\n        } else {\r\n          ownershipLedger.set(ticketStub.key, newLine);\r\n        }\r\n      }\r\n    });\r\n    return {\r\n      ...state,\r\n      ownershipLedger: ownershipLedger\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Ownership Concept,\r\ngenerate a quality that will clear the current pending actions list on state.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { OwnershipState } from '../ownership.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  ownershipClearPendingActions,\r\n  ownershipClearPendingActionsType,\r\n  ownershipClearPendingActionsQuality\r\n] = createQualitySet({\r\n  type: 'clear Ownership\\'s Pending Actions',\r\n  reducer: (state: OwnershipState): OwnershipState => ({...state, pendingActions: []}),\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Ownership Concept,\r\ngenerate a quality clear pending actions of the provided ActionStrategy topic.":{"type":"project","content":"import { Action } from '../../../model/action';\r\nimport { OwnershipState } from '../ownership.concept';\r\nimport { ActionStrategyTopic } from '../../../model/actionStrategy';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createQualitySetWithPayload } from '../../../model/quality';\r\n\r\nexport type OwnershipClearPendingActionsOfStrategyPayload = {\r\n  topic: ActionStrategyTopic\r\n};\r\n\r\nexport const [\r\n  ownershipClearPendingActionsOfStrategy,\r\n  ownershipClearPendingActionsOfStrategyType,\r\n  ownershipClearPendingActionsOfStrategyQuality\r\n] = createQualitySetWithPayload<OwnershipClearPendingActionsOfStrategyPayload>({\r\n  type: 'clear Ownership\\'s Pending Actions of Strategy Topic',\r\n  reducer: (state: OwnershipState, action) => {\r\n    const {topic} = selectPayload<OwnershipClearPendingActionsOfStrategyPayload>(action);\r\n    const newPendingActions: Action[] = [];\r\n    for (const act of state.pendingActions) {\r\n      if (act.strategy?.topic) {\r\n        if (act.strategy.topic !== topic) {\r\n          newPendingActions.push(act);\r\n        }\r\n      }\r\n    }\r\n    return {\r\n      ...state,\r\n      pendingActions: newPendingActions\r\n    };\r\n  }\r\n});"},"For the asynchronous graph programming framework Stratimux and Ownership Concept,\r\ngenerate a quality that will clear the current strategies stubs from the\r\nownership ledger. This is to afford for strategies to relieve their ownership prior to their conclusion.":{"type":"project","content":"import { OwnershipState } from '../ownership.concept';\r\nimport { OwnershipTicket } from '../../../model/ownership';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { createMethodDebounce } from '../../../model/method';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  ownershipClearStrategyStubsFromLedgerAndSelf,\r\n  ownershipClearStrategyStubsFromLedgerAndSelfType,\r\n  ownershipClearStrategyStubsFromLedgerAndSelfQuality\r\n] = createQualitySet({\r\n  type: 'clear current Strategy Stubs from Ownership Ledger and Itself',\r\n  reducer: (state: OwnershipState, action) => {\r\n    const stubs = action?.strategy?.stubs;\r\n    const ownershipLedger = state.ownershipLedger;\r\n    if (action.strategy && stubs) {\r\n      stubs.forEach(ticketStub => {\r\n        const line = ownershipLedger.get(ticketStub.key);\r\n        if (line) {\r\n          const newLine = [] as OwnershipTicket[];\r\n          for (const stub of line) {\r\n            if (stub.ticket !== ticketStub.ticket) {\r\n              newLine.push(stub);\r\n            }\r\n          }\r\n          if (newLine.length === 0) {\r\n            ownershipLedger.delete(ticketStub.key);\r\n          } else {\r\n            ownershipLedger.set(ticketStub.key, newLine);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return {\r\n      ...state,\r\n      ownershipLedger: ownershipLedger\r\n    };\r\n  },\r\n  methodCreator: () => createMethodDebounce((action) => {\r\n    if (action.strategy) {\r\n      action.strategy.stubs = undefined;\r\n      return strategySuccess(action.strategy);\r\n    }\r\n    return action;\r\n  }, 10)\r\n});"},"For the asynchronous graph programming framework Stratimux and Ownership Concept,\r\ngenerate a quality that will simply set ownership's initialized property to true.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { OwnershipState } from '../ownership.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  ownershipInitializeOwnership,\r\n  ownershipInitializeOwnershipType,\r\n  ownershipInitializeOwnershipQuality\r\n] = createQualitySet({\r\n  type: 'Ownership Initialize to True to enable Ownership Principle',\r\n  reducer: (state: OwnershipState): OwnershipState => ({...state, initialized: true}),\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Ownership Concept, generate a quality that hard resets the current ownership ledger.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { OwnershipState } from '../ownership.concept';\r\nimport { createOwnershipLedger } from '../../../model/ownership';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  ownershipResetOwnershipLedger,\r\n  ownershipResetOwnershipLedgerType,\r\n  ownershipResetOwnershipLedgerQuality\r\n] = createQualitySet({\r\n  type: 'reset Ownership Ledger',\r\n  reducer: (state: OwnershipState): OwnershipState => ({...state, ownershipLedger: createOwnershipLedger()}),\r\n  methodCreator: defaultMethodCreator\r\n});"},"For the asynchronous graph programming framework Stratimux and Ownership Concept, generate a strategy that will set the Axium's mode to Ownership.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concepts } from '../../../model/concept';\r\nimport { getSemaphore } from '../../../model/action';\r\nimport { ownershipInitializeOwnership, ownershipInitializeOwnershipType } from '../qualities/initializeOwnership.quality';\r\nimport { axiumSetMode, axiumSetModeType } from '../../axium/qualities/setMode.quality';\r\nimport { ownershipName } from '../ownership.concept';\r\nimport { AxiumState } from '../../axium/axium.concept';\r\nimport { axiumSetDefaultModeIndex } from '../../axium/qualities/setDefaultModeIndex.quality';\r\n\r\nexport const ownershipSetOwnerShipModeTopic = 'Axium set Mode to Ownership then Initialize Ownership Principle';\r\nexport function ownershipSetOwnershipModeStrategy(concepts: Concepts, modeName: string): ActionStrategy {\r\n  const initializeOwnershipSemaphore = getSemaphore(concepts, ownershipName, ownershipInitializeOwnershipType);\r\n  const setModeSemaphore = getSemaphore(concepts, ownershipName, axiumSetModeType);\r\n  let ownershipModeIndex = 2;\r\n  (concepts[0].state as AxiumState).modeNames.forEach((key, i) => {\r\n    if (key === ownershipName) {\r\n      ownershipModeIndex = i;\r\n    }\r\n  });\r\n\r\n  const stepThree = createActionNode(ownershipInitializeOwnership(), {\r\n    semaphore: initializeOwnershipSemaphore,\r\n    successNotes: {\r\n      preposition: 'Set',\r\n    },\r\n  });\r\n  const stepTwo = createActionNode(axiumSetDefaultModeIndex({\r\n    index: ownershipModeIndex\r\n  }), {\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: 'Then'\r\n    },\r\n  });\r\n  const stepOne = createActionNode(axiumSetMode({ modeIndex: ownershipModeIndex, modeName }), {\r\n    semaphore: setModeSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: 'Successfully'\r\n    },\r\n  });\r\n\r\n  return createStrategy({\r\n    topic: ownershipSetOwnerShipModeTopic,\r\n    initialNode: stepOne,\r\n  });\r\n}"},"For the asynchronous graph programming framework Stratimux,\r\ndefine the current index file that exports all public functionality for the framework as a module.":{"type":"project","content":"export { createAxium, getAxiumState, Axium } from './model/axium';\r\nexport type {\r\n  ActionNode,\r\n  ActionNotes,\r\n  ActionNodeOptions,\r\n  ActionStrategy,\r\n  ActionStrategyParameters,\r\n  ActionStrategyStitch,\r\n  ActionStrategyCreator,\r\n} from './model/actionStrategy';\r\nexport {\r\n  createStrategy,\r\n  createActionNode,\r\n  createActionNodeFromStrategy,\r\n  strategyBegin,\r\n  strategySuccess,\r\n  strategyFailed,\r\n  strategyDecide,\r\n  strategyPunt,\r\n  strategySequence,\r\n  strategyBackTrack,\r\n  strategyRecurse,\r\n  strategy\r\n} from './model/actionStrategy';\r\nexport {\r\n  failureConditions,\r\n  strategyData_appendFailure,\r\n  strategyData_selectFailureCondition,\r\n  strategyData_clearFailureCondition,\r\n  strategyData_select,\r\n  strategyData_unifyData,\r\n  strategyData\r\n} from './model/actionStrategyData';\r\nexport {\r\n  createMethod,\r\n  createAsyncMethod,\r\n  createMethodWithState,\r\n  createAsyncMethodWithState,\r\n  createMethodDebounce,\r\n  createAsyncMethodDebounce,\r\n  createMethodDebounceWithState,\r\n  createAsyncMethodDebounceWithState,\r\n  createMethodThrottle,\r\n  createMethodThrottleWithState,\r\n  createAsyncMethodThrottle,\r\n  createAsyncMethodThrottleWithState,\r\n  createMethodWithConcepts,\r\n  createAsyncMethodWithConcepts,\r\n  createMethodThrottleWithConcepts,\r\n  createMethodDebounceWithConcepts,\r\n  createAsyncMethodThrottleWithConcepts,\r\n  createAsyncMethodDebounceWithConcepts,\r\n  method\r\n} from './model/method';\r\nexport {\r\n  debounceAction,\r\n  throttleAction\r\n} from './model/actionOperators';\r\nexport type { Action, ActionType, ActionCreator, ActionCreatorWithPayload } from './model/action';\r\nexport {\r\n  primeAction,\r\n  createAction,\r\n  getSemaphore,\r\n  prepareActionCreator,\r\n  prepareActionWithPayloadCreator,\r\n  refreshAction,\r\n  act\r\n} from './model/action';\r\nexport {\r\n  createConcept,\r\n  createQuality,\r\n  nullReducer,\r\n  defaultReducer,\r\n  defaultMethodCreator,\r\n  isConceptLoaded,\r\n  areConceptsLoaded,\r\n  unifyConcepts,\r\n  forEachConcept,\r\n  conceptToString,\r\n  conceptsToString,\r\n  getConceptSemaphore,\r\n  getUnifiedName,\r\n  concept\r\n} from './model/concept';\r\nexport type {\r\n  Concept,\r\n  Concepts,\r\n  Quality,\r\n  Reducer,\r\n  Method,\r\n  Principle,\r\n  Mode,\r\n  MethodCreator,\r\n} from './model/concept';\r\nexport {\r\n  createQualitySet,\r\n  createQualitySetWithPayload\r\n} from './model/quality';\r\nexport type { KeyedSelector } from './model/selector';\r\nexport {\r\n  selectState,\r\n  selectConcept,\r\n  selectSlice,\r\n  selectPayload,\r\n  selectUnifiedState,\r\n  updateUnifiedKeyedSelector,\r\n  createConceptKeyedSelector,\r\n  createUnifiedKeyedSelector,\r\n  createAdvancedKeys,\r\n  select,\r\n  DotPath\r\n} from './model/selector';\r\nexport { PrincipleFunction, principle } from './model/principle';\r\nexport { createActionController$, actionController } from './model/actionController';\r\nexport type { dispatchOptions, Staging, UnifiedSubject, StagePlanner, NamedStagePlanner } from './model/stagePlanner';\r\nexport { stageWaitForOpenThenIterate, stageWaitForOwnershipThenIterate, createStage } from './model/stagePlanner';\r\nexport type { OwnershipTicket, OwnershipTicketStub, OwnershipLedger } from './model/ownership';\r\nexport { ownership } from './model/ownership';\r\n\r\n//** Concept Exports */\r\n// Axium\r\nexport { AxiumState, axiumName, createAxiumConcept } from './concepts/axium/axium.concept';\r\nexport { blockingMode, permissiveMode } from './concepts/axium/axium.mode';\r\nexport { axiumSelectOpen, axiumSelectLastStrategy, axiumSelectBadActions, axiumSelectBadPlans } from './concepts/axium/axium.selector';\r\n// Models\r\nexport {\r\n  AxiumGatherNode,\r\n  AxiumGatherStrategy,\r\n  axium_createGatherNode,\r\n  axium_createGatherStrategy\r\n} from './concepts/axium/model/gather.model';\r\nexport {\r\n  axium_createStitchNode\r\n} from './concepts/axium/model/stitch.model';\r\n// Qualities\r\nexport { axiumKick, axiumKickType } from './concepts/axium/qualities/kick.quality';\r\nexport { axiumConclude, axiumConcludeType } from './concepts/axium/qualities/conclude.quality';\r\nexport { axiumOpen, axiumOpenType } from './concepts/axium/qualities/open.quality';\r\nexport { axiumLog, axiumLogType } from './concepts/axium/qualities/log.quality';\r\nexport { axiumStitch, axiumStitchType } from './concepts/axium/qualities/stitch.quality';\r\nexport { axiumPreClose, axiumPreCloseType, AxiumPreClosePayload } from './concepts/axium/qualities/preClose.quality';\r\nexport { axiumBadAction, axiumBadActionType } from './concepts/axium/qualities/badAction.quality';\r\nexport { axiumSetMode, axiumSetModeType, AxiumSetModePayload } from './concepts/axium/qualities/setMode.quality';\r\nexport {\r\n  axiumSetDefaultModeIndex,\r\n  axiumSetDefaultModeIndexType,\r\n  AxiumSetDefaultModeIndexPayload\r\n} from './concepts/axium/qualities/setDefaultModeIndex.quality';\r\nexport {\r\n  axiumRegisterSubscriber,\r\n  AxiumRegisterSubscriberPayload,\r\n  axiumRegisterSubscriberType\r\n} from './concepts/axium/qualities/registerSubscription.quality';\r\nexport {\r\n  axiumRegisterStagePlanner,\r\n  AxiumRegisterStagePlannerPayload,\r\n  axiumRegisterStagePlannerType\r\n} from './concepts/axium/qualities/registerStagePlanner.quality';\r\nexport { axiumClearDialog, axiumClearDialogType } from './concepts/axium/qualities/clearDialog.quality';\r\nexport { axiumSetDefaultMode,\r\n  axiumSetDefaultModeType,\r\n  AxiumSetDefaultModePayload\r\n} from './concepts/axium/qualities/setDefaultMode.quality';\r\nexport { axiumSetBlockingMode,\r\n  axiumSetBlockingModeType,\r\n  AxiumSetBlockingModePayload\r\n} from './concepts/axium/qualities/setBlockingMode.quality';\r\n// Strategies\r\nexport {\r\n  addConceptsToAddQueThenBlockStrategy,\r\n  addConceptsToAddQueThenBlockTopic\r\n} from './concepts/axium/strategies/addConcept.strategy';\r\nexport {\r\n  addConceptsToRemovalQueThenBlockStrategy,\r\n  addConceptsToRemovalQueThenBlockTopic\r\n} from './concepts/axium/strategies/removeConcept.strategy';\r\n\r\n// Counter\r\nexport { CounterState, counterName, createCounterConcept } from './concepts/counter/counter.concept';\r\nexport { counterSelectCount } from './concepts/counter/counter.selector';\r\n// Qualities\r\nexport { counterAdd, counterAddType } from './concepts/counter/qualities/add.quality';\r\nexport { counterSubtract, counterSubtractType } from './concepts/counter/qualities/subtract.quality';\r\nexport { counterSetCount, counterSetCountType, CounterSetCountPayload } from './concepts/counter/qualities/setCount.quality';\r\n// Strategies\r\nexport {\r\n  countingStrategy,\r\n  countingTopic,\r\n  primedCountingStrategy,\r\n  primedCountingTopic\r\n} from './concepts/counter/strategies/counting.strategy';\r\n\r\n// Chain\r\nexport { ChainState, chainName, createChainConcept } from './concepts/chain/chain.concept';\r\n// Qualities\r\nexport {\r\n  chainPrepareChain,\r\n  chainPrepareChainType,\r\n  ChainPrepareChainPayload,\r\n  chainPrepareChainQuality\r\n} from './concepts/chain/qualities/prepareChain.quality';\r\nexport {chainEnd, chainEndType} from './concepts/chain/qualities/chainEnd.quality';\r\n\r\n// Ownership\r\nexport { OwnershipState, ownershipName, createOwnershipConcept } from './concepts/ownership/ownership.concept';\r\nexport { ownershipMode } from './concepts/ownership/ownership.mode';\r\nexport { ownershipSelectInitialized, ownershipSelectLedger } from './concepts/ownership/ownership.selector';\r\n// Qualities\r\nexport { ownershipBackTrack, ownershipBackTrackType } from './concepts/ownership/qualities/backTrack.quality';\r\nexport {\r\n  ownershipClearPayloadStubs,\r\n  OwnershipClearPayloadStubsPayload,\r\n  ownershipClearPayloadStubsType\r\n} from './concepts/ownership/qualities/clearPayloadStubs.quality';\r\nexport { ownershipClearPendingActions, ownershipClearPendingActionsType } from './concepts/ownership/qualities/clearPendingActions.quality';\r\nexport {\r\n  ownershipClearPendingActionsOfStrategy,\r\n  OwnershipClearPendingActionsOfStrategyPayload,\r\n  ownershipClearPendingActionsOfStrategyType\r\n} from './concepts/ownership/qualities/clearPendingActionsOfStrategy.quality';\r\nexport {\r\n  ownershipClearStrategyStubsFromLedgerAndSelf,\r\n  ownershipClearStrategyStubsFromLedgerAndSelfType\r\n} from './concepts/ownership/qualities/clearStrategyStubsFromLedgerAndSelf.quality';\r\nexport {\r\n  ownershipResetOwnershipLedger,\r\n  ownershipResetOwnershipLedgerType\r\n} from './concepts/ownership/qualities/resetOwnershipLedger.quality';\r\n\r\n// Experiment\r\nexport {\r\n  ExperimentState,\r\n  createExperimentState,\r\n  createExperimentConcept,\r\n  experimentName\r\n} from './concepts/experiment/experiment.concept';\r\nexport {\r\n  experimentCheckInStrategyQuality,\r\n  experimentCheckInStrategy,\r\n  experimentCheckInStrategyType\r\n} from './concepts/experiment/qualities/checkInStrategy.quality';\r\nexport {\r\n  experimentCountingStrategy,\r\n  experimentCountingTopic,\r\n  experimentPrimedCountingStrategy,\r\n  experimentPrimedCountingTopic\r\n} from './concepts/experiment/strategies/experimentCounting.strategy';\r\nexport {experimentActionQuePrinciple} from './concepts/experiment/experiment.principle';"},"For the asynchronous graph programming framework Stratimux, define the Action model file.\r\nThis file dictates the functionality of Actions within Stratimux.":{"type":"project","content":"import { Concept, Concepts } from './concept';\r\nimport { ActionStrategy } from './actionStrategy';\r\nimport { KeyedSelector } from './selector';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { AxiumBadActionPayload } from '../concepts/axium/qualities/badAction.quality';\r\nimport { failureConditions, strategyData_appendFailure } from './actionStrategyData';\r\n\r\nexport const nullActionType: ActionType = 'null';\r\n// These need to be logical determined ahead of time.\r\n//   Logical determinations such as these will be determined in the future via generation over hand placement.\r\nconst axiumConcludeType: ActionType = 'Conclude';\r\nconst axiumBadActionType: ActionType = 'Axium received a Bad Action';\r\nconst axiumSetBlockingModeType: ActionType = 'set Axium to Blocking Mode';\r\nconst axiumOpenType: ActionType = 'Open Axium';\r\n\r\nexport type ActionType = string;\r\nexport type Action = {\r\n    type: ActionType;\r\n    semaphore: [number, number, number, number];\r\n    conceptSemaphore?: number;\r\n    payload?: Record<string, unknown>;\r\n    strategy?: ActionStrategy;\r\n    keyedSelectors?: KeyedSelector[];\r\n    agreement?: number;\r\n    expiration: number;\r\n    axium?: string;\r\n};\r\n\r\nconst createPayload = <T extends Record<string, unknown>>(payload: T) => payload;\r\n\r\nexport function primeAction(concepts: Concepts, action: Action): Action {\r\n  const expired = action.expiration < Date.now();\r\n  let semaphore: [number, number, number, number] = [-1, -1, -1, -1];\r\n  if (!expired) {\r\n    if (action.conceptSemaphore) {\r\n      semaphore = getSemaphore(concepts, concepts[action.conceptSemaphore].name, action.type);\r\n    } else {\r\n      const conceptKeys = Object.keys(concepts);\r\n      for (const i of conceptKeys) {\r\n        const index = Number(i);\r\n        semaphore = getSemaphore(concepts, concepts[index].name, action.type);\r\n        if (semaphore[2] !== -1 && action.expiration) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (semaphore[2] !== -1 && action.expiration) {\r\n    let axium;\r\n    if (action.axium) {\r\n      axium = action.axium;\r\n    } else {\r\n      axium = (concepts[0].state as AxiumState).name;\r\n    }\r\n    const newAction = {\r\n      ...action,\r\n      semaphore: semaphore,\r\n      axium,\r\n    };\r\n    if (newAction.strategy) {\r\n      newAction.strategy.currentNode.action = newAction;\r\n    }\r\n    return newAction;\r\n  }\r\n  const badAction: Action = {\r\n    type: axiumBadActionType,\r\n    payload: createPayload<AxiumBadActionPayload>({badActions: [action]}),\r\n    expiration: Date.now() + 5000,\r\n    semaphore: getSemaphore(concepts, concepts[0].name, axiumBadActionType)\r\n  };\r\n  if (action.strategy) {\r\n    badAction.strategy = action.strategy;\r\n    badAction.strategy.currentNode.action = badAction;\r\n    if (expired) {\r\n      badAction.strategy.data = strategyData_appendFailure(badAction.strategy, failureConditions.axiumExpired);\r\n    } else {\r\n      badAction.strategy.data = strategyData_appendFailure(badAction.strategy, failureConditions.axiumBadGeneration);\r\n    }\r\n  }\r\n  return badAction;\r\n}\r\n\r\n/**\r\n * @param action A previously created action.\r\n * @returns Returns a newly recomposed Action with a updated expiration, takes into account agreement if present.\r\n */\r\nexport const refreshAction = (action: Action): Action => {\r\n  const newAction = {\r\n    ...action,\r\n  };\r\n  if (newAction.agreement) {\r\n    newAction.expiration = Date.now() + newAction.agreement;\r\n  } else {\r\n    newAction.expiration = Date.now() + 5000;\r\n  }\r\n  return newAction;\r\n};\r\n\r\nexport function getSemaphore(concepts: Concepts, conceptName: string, actionType: ActionType): [number, number, number, number] {\r\n  const axiumState = concepts[0].state as AxiumState;\r\n  const cachedSemaphores = axiumState.cachedSemaphores;\r\n  const conceptMap = cachedSemaphores.get(conceptName);\r\n  const special = getSpecialSemaphore(actionType);\r\n  if (conceptMap) {\r\n    const qualitySemaphore = conceptMap.get(actionType);\r\n    if (qualitySemaphore) {\r\n      qualitySemaphore[3] = special;\r\n      return qualitySemaphore;\r\n    }\r\n  }\r\n  return [0, 0, -1, special];\r\n}\r\n\r\n// For proper compilation\r\nconst forEachConcept = (concepts: Concepts, each: (concept: Concept, semaphore?: number) => void) => {\r\n  const conceptKeys = Object.keys(concepts);\r\n  for (const i of conceptKeys) {\r\n    const index = Number(i);\r\n    each(concepts[index], concepts[index].semaphore);\r\n  }\r\n};\r\n\r\nexport function createCacheSemaphores(concepts: Concepts): Map<string, Map<string, [number, number, number, number]>> {\r\n  const generation = (concepts[0].state as AxiumState).generation;\r\n  const newCachedSemaphores = new Map<string, Map<string, [number, number, number, number]>>();\r\n\r\n  forEachConcept(concepts, ((concept, ci) => {\r\n    const qualityMap = new Map<string, [number, number, number, number]>();\r\n    concept.qualities.forEach((quality, qi) => {\r\n      qualityMap.set(quality.actionType, [ci as number, qi, generation, 0]);\r\n    });\r\n    newCachedSemaphores.set(concept.name, qualityMap);\r\n  }));\r\n  return newCachedSemaphores;\r\n}\r\n\r\n/**\r\n * This allows us to logically determine these values in code.\r\n * @returns The final value for the semaphore tuple.\r\n */\r\nfunction getSpecialSemaphore(type: ActionType) {\r\n  switch (type) {\r\n  case axiumBadActionType: {\r\n    return 1;\r\n  }\r\n  case nullActionType: {\r\n    return 2;\r\n  }\r\n  case axiumConcludeType: {\r\n    return 3;\r\n  }\r\n  case axiumSetBlockingModeType: {\r\n    return 4;\r\n  }\r\n  // case axiumOpenType: {\r\n  //   return 5;\r\n  // }\r\n  default: {\r\n    return 0;\r\n  }\r\n  }\r\n}\r\n\r\nexport function createAction<T extends Record<string, unknown>>(\r\n  type: ActionType,\r\n  payload?: T,\r\n  keyedSelectors?: KeyedSelector[],\r\n  agreement?: number,\r\n  _semaphore?: [number, number, number, number],\r\n  conceptSemaphore?: number\r\n): Action {\r\n  const special = getSpecialSemaphore(type);\r\n  const semaphore = _semaphore !== undefined ? _semaphore : [0, 0, -1, special] as [number, number, number, number];\r\n  return {\r\n    type,\r\n    semaphore,\r\n    payload,\r\n    keyedSelectors,\r\n    agreement,\r\n    expiration: Date.now() + (agreement !== undefined ? agreement : 5000),\r\n    conceptSemaphore\r\n  };\r\n}\r\n\r\nexport type ActionCreator = (\r\n    conceptSemaphore?: number,\r\n    keyedSelectors?: KeyedSelector[],\r\n    agreement?: number,\r\n    qualitySemaphore?: [number, number, number, number]\r\n  ) => Action;\r\n\r\nexport function prepareActionCreator(actionType: ActionType) {\r\n  return (\r\n    conceptSemaphore?: number,\r\n    keyedSelectors?: KeyedSelector[],\r\n    agreement?: number,\r\n    qualitySemaphore?: [number, number, number, number]\r\n  ) => {\r\n    return createAction(actionType, undefined, keyedSelectors, agreement, qualitySemaphore, conceptSemaphore);\r\n  };\r\n}\r\n\r\nexport function prepareActionWithPayloadCreator<T extends Record<string, unknown>>(actionType: ActionType) {\r\n  return (\r\n    payload: T,\r\n    conceptSemaphore?: number,\r\n    keyedSelectors?: KeyedSelector[],\r\n    agreement?: number,\r\n    semaphore?: [number, number, number, number]\r\n  ): Action => {\r\n    return createAction(actionType, payload, keyedSelectors, agreement, semaphore, conceptSemaphore);\r\n  };\r\n}\r\nexport type ActionCreatorWithPayload<T> = (\r\n    payload: T,\r\n    conceptSemaphore?: number,\r\n    keyedSelectors?: KeyedSelector[],\r\n    agreement?: number,\r\n    semaphore?: [number, number, number, number]\r\n  ) => Action;\r\n\r\n/**\r\n * Should only be used after if you can logically determine that the semaphores have been primed.\r\n * @returns boolean\r\n */\r\nexport function areSemaphoresEqual(first: Action, second: Action) {\r\n  return first.semaphore[0] === second.semaphore[0] && first.semaphore[1] === second.semaphore[1];\r\n}\r\n\r\nexport const act = ({\r\n  prime: primeAction,\r\n  refresh: refreshAction,\r\n  getSemaphore,\r\n  createCacheSemaphores,\r\n  create: createAction,\r\n  prepareActionCreator,\r\n  prepareActionWithPayloadCreator,\r\n  areSemaphoresEqual,\r\n});"},"For the asynchronous graph programming framework Stratimux, define the Action Controller model file.\r\nThis file defines the asynchronous functionality for Methods.\r\nThat will utilize an Action's expiration as a means to invalidate an Action if the asynchronous functionality has\r\nreached its expiration. Emitting a Strategy Failed if the Action was a Strategy, or bad action if the strategy was\r\nnot provided.":{"type":"project","content":"import { Action, axiumBadAction, strategyFailed } from '../index';\r\nimport { Subject } from 'rxjs';\r\nimport { failureConditions, strategyData_appendFailure } from './actionStrategyData';\r\n\r\nexport class ActionController extends Subject<Action> {\r\n  expiration: number;\r\n  expired: boolean;\r\n  timer: NodeJS.Timeout | undefined;\r\n  action: Action;\r\n  constructor(action: Action) {\r\n    super();\r\n    this.expiration = action.expiration;\r\n    this.expired = false;\r\n    this.action = action;\r\n    if (this.expiration < Date.now()) {\r\n      if (this.action.strategy) {\r\n        this.fire(strategyFailed(\r\n          this.action.strategy,\r\n          strategyData_appendFailure(this.action.strategy, failureConditions.controllerExpired)\r\n        ));\r\n      } else {\r\n        this.next(axiumBadAction({badActions: [this.action]}));\r\n      }\r\n    } else {\r\n      this.timer = setTimeout(() => {\r\n        this.expired = true;\r\n        if (this.action.strategy) {\r\n          this.next(strategyFailed(\r\n            this.action.strategy,\r\n            strategyData_appendFailure(this.action.strategy, failureConditions.controllerExpired)\r\n          ));\r\n        } else {\r\n          this.next(axiumBadAction({badActions: [this.action]}));\r\n        }\r\n      }, this.expiration - Date.now());\r\n    }\r\n  }\r\n  /**\r\n   * Next fires once and then completes.\r\n   * In case someone uses next over fire.\r\n   */\r\n  next(action: Action) {\r\n    this.fire(action);\r\n  }\r\n  /**\r\n   * Fires once and then completes.\r\n   */\r\n  fire(action: Action) {\r\n    if (!this.closed) {\r\n      if (!this.expired && this.timer) {\r\n        clearTimeout(this.timer);\r\n        this.timer.unref();\r\n      }\r\n      const { observers } = this;\r\n      const len = observers.length;\r\n      for (let i = 0; i < len; i++) {\r\n        observers[i].next(action);\r\n      }\r\n      this.complete();\r\n    }\r\n  }\r\n}\r\n\r\nexport const createActionController$ = (act: Action, controlling: (controller: ActionController, action: Action) => void) => {\r\n  const ctrl = new ActionController(act);\r\n  // Needs to have timeout so that subscribers have time to attach in case the controller fires synchronously.\r\n  setTimeout(() => {\r\n    // Logically Determined axiumConclude;\r\n    if (act.semaphore[3] === 3) {\r\n      ctrl.fire(act);\r\n    } else {\r\n      controlling(ctrl, act);\r\n    }\r\n  }, 0);\r\n  return ctrl;\r\n};\r\n\r\nexport const actionController = ({\r\n  create$: createActionController$\r\n});"},"For the asynchronous graph programming framework Stratimux, define the Action Operator model file.\r\nThis file dictates the functionality of both Debounce, Throttle Methods and\r\ntheir interaction with ActionStrategy.":{"type":"project","content":"/* eslint-disable @typescript-eslint/no-non-null-assertion */\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport {\r\n  InteropObservable,\r\n  MonoTypeOperatorFunction,\r\n  Observable,\r\n  ObservableInput,\r\n  OperatorFunction,\r\n  SchedulerAction,\r\n  SchedulerLike,\r\n  Subscriber,\r\n  Subscription,\r\n  ThrottleConfig,\r\n  asyncScheduler,\r\n  timer\r\n} from 'rxjs';\r\nimport { Action } from './action';\r\nimport { axiumConclude } from '../concepts/axium/qualities/conclude.quality';\r\n\r\nfunction hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\r\n  return typeof source?.lift === 'function';\r\n}\r\nfunction isFunction(value: any): value is (...args: any[]) => any {\r\n  return typeof value === 'function';\r\n}\r\nconst observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\r\n\r\nfunction isInteropObservable(input: any): input is InteropObservable<any> {\r\n  return isFunction(input[observable]);\r\n}\r\nfunction fromInteropObservable<T>(obj: any) {\r\n  return new Observable((subscriber: Subscriber<T>) => {\r\n    const obs = obj[observable]();\r\n    if (isFunction(obs.subscribe)) {\r\n      return obs.subscribe(subscriber);\r\n    }\r\n    // Should be caught by observable subscribe function error handling.\r\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\r\n  });\r\n}\r\nfunction createInvalidObservableTypeError(input: any) {\r\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\r\n  return new TypeError(\r\n    `You provided ${\r\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\r\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\r\n  );\r\n}\r\nfunction innerFrom<T>(input: ObservableInput<T>): Observable<T> {\r\n  if (input instanceof Observable) {\r\n    return input;\r\n  }\r\n  if (input !== null) {\r\n    if (isInteropObservable(input)) {\r\n      return fromInteropObservable(input);\r\n    }\r\n  }\r\n\r\n  throw createInvalidObservableTypeError(input);\r\n}\r\nfunction operate<T, R>(\r\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\r\n): OperatorFunction<T, R> {\r\n  return (source: Observable<T>) => {\r\n    if (hasLift(source)) {\r\n      // eslint-disable-next-line consistent-return\r\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\r\n        try {\r\n          return init(liftedSource, this);\r\n        } catch (err) {\r\n          this.error(err);\r\n        }\r\n      });\r\n    }\r\n    throw new TypeError('Unable to lift unknown Observable type');\r\n  };\r\n}\r\n\r\nclass OperatorSubscriber<T> extends Subscriber<T> {\r\n  constructor(\r\n    destination: Subscriber<any>,\r\n    onNext?: (value: T) => void,\r\n    onComplete?: () => void,\r\n    onError?: (err: any) => void,\r\n    private onFinalize?: () => void,\r\n    private shouldUnsubscribe?: () => boolean\r\n  ) {\r\n    super(destination);\r\n    this._next = onNext\r\n      ? function (this: OperatorSubscriber<T>, value: T) {\r\n        try {\r\n          onNext(value);\r\n        } catch (err) {\r\n          destination.error(err);\r\n        }\r\n      }\r\n      : super._next;\r\n    this._error = onError\r\n      ? function (this: OperatorSubscriber<T>, err: any) {\r\n        try {\r\n          onError(err);\r\n        } catch (error) {\r\n          // Send any errors that occur down stream.\r\n          destination.error(error);\r\n        } finally {\r\n          // Ensure finalization.\r\n          this.unsubscribe();\r\n        }\r\n      }\r\n      : super._error;\r\n    this._complete = onComplete\r\n      ? function (this: OperatorSubscriber<T>) {\r\n        try {\r\n          onComplete();\r\n        } catch (err) {\r\n          // Send any errors that occur down stream.\r\n          destination.error(err);\r\n        } finally {\r\n          // Ensure finalization.\r\n          this.unsubscribe();\r\n        }\r\n      }\r\n      : super._complete;\r\n  }\r\n\r\n  unsubscribe() {\r\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\r\n      const { closed } = this;\r\n      super.unsubscribe();\r\n      !closed && this.onFinalize?.();\r\n    }\r\n  }\r\n}\r\n\r\nfunction createOperatorSubscriber<T>(\r\n  destination: Subscriber<any>,\r\n  onNext?: (value: T) => void,\r\n  onComplete?: () => void,\r\n  onError?: (err: unknown) => void,\r\n  onFinalize?: () => void\r\n): Subscriber<T> {\r\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\r\n}\r\n\r\n/**\r\n * This will prevent all actions for the specified duration, but will still emit actions as axiumConclude\r\n *  Thus this needs to be taken into account in the Method using debounceAction if implemented directly.\r\n *   But will be handled automatically in actionControllers and associated debounce createMethods.\r\n */\r\nexport function debounceAction(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<Action> {\r\n  return operate((source, subscriber) => {\r\n    let activeTask: Subscription | null = null;\r\n    let lastValue: Action | null = null;\r\n    let lastTime: number | null = null;\r\n\r\n    const emit = () => {\r\n      if (activeTask) {\r\n        activeTask.unsubscribe();\r\n        activeTask = null;\r\n        const value = lastValue!;\r\n        lastValue = null;\r\n        subscriber.next(value);\r\n      }\r\n    };\r\n    function emitWhenIdle(this: SchedulerAction<unknown>) {\r\n      const targetTime = lastTime! + dueTime;\r\n      const now = scheduler.now();\r\n      if (now < targetTime) {\r\n        activeTask = this.schedule(undefined, targetTime - now);\r\n        subscriber.add(activeTask);\r\n        return;\r\n      }\r\n\r\n      emit();\r\n    }\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: Action) => {\r\n          lastValue = value;\r\n          lastTime = scheduler.now();\r\n          if (!activeTask) {\r\n            activeTask = scheduler.schedule(emitWhenIdle, dueTime);\r\n            subscriber.add(activeTask);\r\n          } else {\r\n            // All this code just to place this code block.\r\n            const conclude = {\r\n              ...value,\r\n              ...axiumConclude(),\r\n            };\r\n            subscriber.next(\r\n              conclude\r\n            );\r\n          }\r\n        },\r\n        () => {\r\n          emit();\r\n          subscriber.complete();\r\n        },\r\n        undefined,\r\n        () => {\r\n          lastValue = activeTask = null;\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n\r\nfunction throttle(durationSelector: (value: Action) => ObservableInput<any>, config?: ThrottleConfig): MonoTypeOperatorFunction<Action> {\r\n  return operate((source, subscriber) => {\r\n    const { leading = true, trailing = false } = config ?? {};\r\n    let hasValue = false;\r\n    let sendValue: Action | null = null;\r\n    let throttled: Subscription | null = null;\r\n    let isComplete = false;\r\n\r\n    const endThrottling = (value: Action) => {\r\n      throttled?.unsubscribe();\r\n      throttled = null;\r\n      if (trailing) {\r\n        send();\r\n        isComplete && subscriber.complete();\r\n      } else {\r\n        passConclude(value);\r\n      }\r\n    };\r\n\r\n    const cleanupThrottling = () => {\r\n      throttled = null;\r\n      isComplete && subscriber.complete();\r\n    };\r\n\r\n    const startThrottle = (value: Action) =>\r\n      (throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));\r\n    const passConclude = (value: Action) => {\r\n      subscriber.next({\r\n        ...value,\r\n        ...axiumConclude()\r\n      });\r\n    };\r\n\r\n    const send = () => {\r\n      if (hasValue) {\r\n        hasValue = false;\r\n        const value = sendValue!;\r\n        sendValue = null;\r\n        subscriber.next(value);\r\n        !isComplete && startThrottle(value);\r\n      }\r\n    };\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          hasValue = true;\r\n          sendValue = value;\r\n          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));\r\n        },\r\n        () => {\r\n          isComplete = true;\r\n          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n/**\r\n * This will permit the first action, then filter actions for the specified duration, but will still emit actions as axiumConclude\r\n *  Thus this needs to be taken into account in the Method using throttleAction if implemented directly.\r\n *   But will be handled automatically in actionControllers and associated debounce createMethods.\r\n */\r\nexport function throttleAction(\r\n  duration: number,\r\n  scheduler: SchedulerLike = asyncScheduler,\r\n  config?: ThrottleConfig\r\n): MonoTypeOperatorFunction<Action> {\r\n  const duration$ = timer(duration, scheduler);\r\n  return throttle(() => duration$, config);\r\n}"},"For the asynchronous graph programming framework Stratimux, define the ActionStrategy model file.\r\nThis file is what allows for Stratimux to be provably terminating.\r\nAs each strategy constitutes a finite set of symbols that must reach a conclusion.\r\nUsing this data structure we can constrain the Axium's recursive functionality to the length\r\nof the strategies that currently exist within it.\r\nThis file likewise defines a series of consumer functions that accept an ActionStrategy and data parameter; that\r\nthen returns a new ActionStrategy based on the inputs.":{"type":"project","content":"import { axiumConclude, axiumConcludeType } from '../concepts/axium/qualities/conclude.quality';\r\nimport { Action, ActionType, createAction, nullActionType } from './action';\r\nimport { OwnershipTicketStub } from './ownership';\r\nimport { KeyedSelector } from './selector';\r\n\r\n/**\r\n * ActionNode - Control Structure used by ActionStrategy\r\n * @param action - Action to be dispatched.\r\n * @param successNode - Upon ActionStrategy.success() the Strategy will update itself to this node.\r\n * * If set to null, will default to Axium Conclude Type on ActionStrategy.success().\r\n * @param failureNode - `optional` ActionStrategy.failed() will fire Axium Conclude Type if left blank or set to null.\r\n * @param payload - `optional` Will set the payload of the action.\r\n * @param semaphore - `optional` This will prime the action to avoid look up at run time. Best practice use getSemaphore().\r\n * @param conceptSemaphore - `optional` Used for Unified Qualities. Must be specified via that principle's passed semaphore value.\r\n * @param agreement - `optional` Is time in milliseconds of the actions intended lifetime.\r\n * @param decisionNodes - `optional` The third or more option, may override success or failure in your workflows.\r\n * @param preposition - `optional` String that prefixes the ActionType when added to the Strategy's ActionList.\r\n * @param denoter - `optional` String that denotes the end of the ActionList sentence.\r\n *                               If placed dynamically, allows for the explicit appending of information at the end of the sentence\r\n * @ExampleSentence ${preposition: 'Via'} Axium set Mode to ${denoter: 'Ownership Mode.'}\r\n * @Output Via Axium set Mode to Ownership Mode.\r\n */\r\nexport interface ActionNode {\r\n  action?: Action;\r\n  actionType: ActionType;\r\n  payload?: Record<string, unknown>;\r\n  conceptSemaphore?: number;\r\n  keyedSelectors?: KeyedSelector[];\r\n  semaphore?: [number, number, number, number];\r\n  agreement?: number;\r\n  decisionNodes?: Record<string, ActionNode>;\r\n  decisionNotes?: ActionNotes;\r\n  successNode: ActionNode | null;\r\n  successNotes?: ActionNotes;\r\n  failureNode: ActionNode | null;\r\n  failureNotes?: ActionNotes;\r\n  lastActionNode?: ActionNode;\r\n}\r\n/**\r\n * Options list\r\n * @param successNode - Upon ActionStrategy.success() the Strategy will update itself to this node.\r\n * * If set to null, will default to Axium Conclude Type on ActionStrategy.success().\r\n * @param failureNode - `optional` ActionStrategy.failed() will fire Axium Conclude Type if left blank or set to null.\r\n * @param semaphore - `optional` This will prime the action to avoid look up at run time. Best practice use getSemaphore().\r\n * @param conceptSemaphore - `optional` Used for Unified Qualities. Must be specified via that principle's passed semaphore value.\r\n * @param agreement - `optional` Is time in milliseconds of the actions intended lifetime.\r\n * @param decisionNodes - `optional` The third or more option, may override success or failure in your workflows.\r\n * @param preposition - `optional` String that prefixes the ActionType when added to the Strategy's ActionList.\r\n * @param denoter - `optional` String that denotes the end of the ActionList sentence.\r\n *                               If placed dynamically, allows for the explicit appending of information at the end of the sentence\r\n * @ExampleSentence ${preposition: 'Via'} Axium set Mode to ${denoter: 'Ownership Mode.'}\r\n * @Output Via Axium set Mode to Ownership Mode.\r\n */\r\nexport interface ActionNodeOptions {\r\n  keyedSelectors?: KeyedSelector[];\r\n  conceptSemaphore?: number;\r\n  semaphore?: [number, number, number, number];\r\n  agreement?: number;\r\n  decisionNodes?: Record<string, ActionNode>;\r\n  decisionNotes?: ActionNotes;\r\n  successNode?: ActionNode | null;\r\n  successNotes?: ActionNotes;\r\n  failureNode?: ActionNode | null;\r\n  failureNotes?: ActionNotes;\r\n  lastActionNode?: ActionNode;\r\n}\r\n\r\n/**\r\n * Use this as an argument, this should be a \"Curried Function\" with your arguments carried over.\r\n * */\r\nexport type ActionStrategyStitch = () => [ActionNode, ActionStrategy];\r\n/**\r\n * Use this as an argument, as we lose type checking of your functions arguments,\r\n * due to the current implementation of Typescript argument generics.\r\n */\r\nexport type ActionStrategyCreator = (...arg0: unknown[]) => ActionStrategy;\r\n\r\n/**\r\n * Decomposes an action into an ActionNode to be later Recomposed.\r\n * @param action Action properties of KeyedSelector, Agreement, and Semaphore take priority over options.\r\n * @param options successNode and failureNodes are always required. If using decisionNodes, set both to null.\r\n * @returns ActionNode\r\n */\r\nexport function createActionNode(action: Action, options?: ActionNodeOptions): ActionNode {\r\n  if (options) {\r\n    return {\r\n      actionType: action.type,\r\n      payload: action.payload,\r\n      keyedSelectors: action.keyedSelectors ? action.keyedSelectors : options.keyedSelectors,\r\n      agreement: action.agreement ? action.agreement : options.agreement,\r\n      semaphore: action.semaphore ? action.semaphore : options.semaphore,\r\n      successNode: options.successNode ? options.successNode : null,\r\n      successNotes: options.successNotes,\r\n      failureNode: options.failureNode ? options.failureNode : null,\r\n      failureNotes: options.failureNotes,\r\n      decisionNodes: options.decisionNodes,\r\n      decisionNotes: options.decisionNotes,\r\n      lastActionNode: options.lastActionNode\r\n    };\r\n  }\r\n  return {\r\n    actionType: action.type,\r\n    payload: action.payload,\r\n    successNode: null,\r\n    failureNode: null\r\n  };\r\n}\r\n\r\n/**\r\n * Note that this will be a new ActionNode and not the original created within the provided strategy.\r\n * @param strategy Will return a recomposed ActionNode of the provided strategy.\r\n * @returns ActionNode\r\n */\r\nexport const createActionNodeFromStrategy = (strategy: ActionStrategy): ActionNode => {\r\n  const currentNode = strategy.currentNode;\r\n  let action;\r\n  if (currentNode.action) {\r\n    action = {...currentNode.action};\r\n  } else {\r\n    action = createAction(\r\n      currentNode.actionType,\r\n      currentNode.payload,\r\n      currentNode.keyedSelectors,\r\n      currentNode.agreement,\r\n      currentNode.semaphore,\r\n      currentNode.conceptSemaphore\r\n    );\r\n  }\r\n  return createActionNode(action, {\r\n    successNode: currentNode.successNode,\r\n    successNotes: currentNode.successNotes,\r\n    failureNode: currentNode.failureNode,\r\n    failureNotes: currentNode.failureNotes,\r\n    decisionNodes: currentNode.decisionNodes,\r\n    decisionNotes: currentNode.decisionNotes,\r\n    lastActionNode: currentNode.lastActionNode\r\n  });\r\n};\r\n\r\n/**\r\n * Will decorate the final Stratimux sentence\r\n * @preposition - Would append your string.\r\n * @denoter - Would include some string ending in punctuation.\r\n */\r\nexport interface ActionNotes {\r\n  preposition?: string;\r\n  denoter?: string;\r\n}\r\n\r\n/**\r\n * ActionStrategyParams\r\n * Interface of ActionStrategy Construction\r\n * @param data - Payload to be carried throughout the strategy.\r\n * @param initialNode - Starting point of your ActionStrategy\r\n */\r\nexport interface ActionStrategyParameters {\r\n  topic: string;\r\n  data?: Record<string, unknown>;\r\n  initialNode: ActionNode;\r\n}\r\nexport interface ActionStrategy {\r\n  topic: string;\r\n  data?: Record<string, unknown>;\r\n  currentNode: ActionNode;\r\n  actionList: Array<string>;\r\n  puntedStrategy?: ActionStrategy[];\r\n  stubs?: OwnershipTicketStub[];\r\n}\r\n\r\nexport type ActionStrategyTopic = string;\r\n\r\nfunction isNotPunctuated(str: string): boolean {\r\n  const punctuatedList = ['.', ',', '?', '!', ';'];\r\n  let notPunctuated = true;\r\n  for (const punctuated of punctuatedList) {\r\n    if (str.charAt(0) === punctuated) {\r\n      notPunctuated = false;\r\n      break;\r\n    }\r\n  }\r\n  return notPunctuated;\r\n}\r\n\r\nfunction createSentence(actionNode: ActionNode, actionNotes?: ActionNotes , decisionKey?: string): string {\r\n  const preposition = actionNotes?.preposition ? `${actionNotes.preposition} ` : '';\r\n  const decision = decisionKey ? `${decisionKey} ` : '';\r\n  const body = `${actionNode.actionType}`;\r\n  let denoter = '.';\r\n  if (actionNotes?.denoter) {\r\n    if (isNotPunctuated(actionNotes.denoter)) {\r\n      denoter = ` ${actionNotes.denoter}`;\r\n    } else {\r\n      denoter = actionNotes.denoter;\r\n    }\r\n  }\r\n  return preposition + decision + body + denoter;\r\n}\r\n\r\nexport function createStrategy(\r\n  params: ActionStrategyParameters,\r\n): ActionStrategy {\r\n  const data: Record<string, unknown> | undefined = params.data;\r\n  const currentNode: ActionNode = params.initialNode;\r\n  currentNode.lastActionNode = {\r\n    // This logically determines that all ActionNodes will have a Action associated.\r\n    action: createAction(nullActionType),\r\n    actionType: nullActionType,\r\n    successNode: null,\r\n    failureNode: null\r\n  };\r\n  const actionList: Array<string> = [params.topic + '.'];\r\n  return {\r\n    topic: params.topic,\r\n    data,\r\n    currentNode,\r\n    actionList,\r\n  };\r\n}\r\n\r\nexport const strategyBegin = (strategy: ActionStrategy, data?: Record<string, unknown>): Action => {\r\n  strategy.currentNode.action = createAction(\r\n    strategy.currentNode.actionType,\r\n    strategy.currentNode.payload,\r\n    strategy.currentNode.keyedSelectors,\r\n    strategy.currentNode.agreement\r\n  );\r\n  strategy.currentNode.action.strategy = {\r\n    ...strategy,\r\n    topic: strategy.topic,\r\n    data: data ? data : strategy.data,\r\n    currentNode: strategy.currentNode,\r\n    actionList: strategy.actionList,\r\n  };\r\n  if (strategy.currentNode.action !== null) {\r\n    return strategy.currentNode.action;\r\n  } else {\r\n    return axiumConclude();\r\n  }\r\n};\r\n\r\n/**\r\n * strategySuccess(strategy: ActionStrategy, data?: any)\r\n * Returns the failure stage's Action and reassigns ActionStrategy to that Action's strategy parameter.\r\n * If no failureNode is found, will return EndOfActionStrategy instead.\r\n * @param data - OPTIONAL, if used will override the ActionStrategy's payload\r\n */\r\nexport const strategySuccess = (_strategy: ActionStrategy, data?: Record<string, unknown>) => {\r\n  const strategy = {..._strategy};\r\n  let nextAction: Action;\r\n  const actionListEntry = createSentence(\r\n    strategy.currentNode,\r\n    strategy.currentNode?.successNotes,\r\n    strategy.currentNode.successNotes?.preposition !== undefined ? '' : 'Success with'\r\n  );\r\n  if (strategy.currentNode.successNode !== null) {\r\n    const nextNode = strategy.currentNode.successNode;\r\n    nextAction = createAction(\r\n      nextNode.actionType,\r\n      nextNode.payload,\r\n      nextNode.keyedSelectors,\r\n      nextNode.agreement,\r\n      nextNode.semaphore,\r\n      nextNode.conceptSemaphore\r\n    );\r\n    nextNode.action = nextAction;\r\n    nextNode.lastActionNode = strategy.currentNode;\r\n    nextAction.strategy = {\r\n      ...strategy,\r\n      topic: strategy.topic,\r\n      data: data ? data : strategy.data,\r\n      currentNode: nextNode,\r\n      actionList: [...strategy.actionList, actionListEntry],\r\n    };\r\n    return nextAction;\r\n  } else {\r\n    strategy.actionList = [...strategy.actionList, actionListEntry, '\\n'];\r\n    if (\r\n      strategy.puntedStrategy !== undefined &&\r\n            strategy.puntedStrategy?.length !== 0\r\n    ) {\r\n      const nextStrategy =\r\n                strategy.puntedStrategy.shift() as ActionStrategy;\r\n      nextStrategy.puntedStrategy = strategy.puntedStrategy;\r\n      const nextEntry = `${nextStrategy.topic}.`;\r\n      nextStrategy.actionList = [\r\n        ...strategy.actionList,\r\n        nextEntry,\r\n      ];\r\n\r\n      nextStrategy.stubs = strategy.stubs;\r\n      nextStrategy.currentNode.lastActionNode = strategy.currentNode;\r\n      return strategyBegin(nextStrategy);\r\n    }\r\n    const conclude: ActionNode = {\r\n      actionType: axiumConcludeType,\r\n      successNode: null,\r\n      failureNode: null,\r\n      lastActionNode: strategy.currentNode,\r\n    };\r\n    conclude.action = createAction(conclude.actionType);\r\n    conclude.action.strategy = {\r\n      ...strategy,\r\n      currentNode: conclude,\r\n      data: data ? data : strategy.data\r\n    };\r\n    return conclude.action;\r\n  }\r\n};\r\n/**\r\n * strategyFailed(strategy: ActionStrategy, data?: any)\r\n * Returns the failure stage's Action and reassigns ActionStrategy to that Action's strategy parameter.\r\n * If no failureNode is found, will return EndOfActionStrategy instead.\r\n * @param data - OPTIONAL, if used will override the ActionStrategy's payload\r\n */\r\nexport function strategyFailed(_strategy: ActionStrategy, data?: Record<string, unknown>) {\r\n  const strategy = {..._strategy};\r\n  let nextAction: Action;\r\n  const actionListEntry = createSentence(\r\n    strategy.currentNode,\r\n    strategy.currentNode.failureNotes,\r\n    strategy.currentNode.failureNotes?.preposition !== undefined ? '' : 'Failed with'\r\n  );\r\n  if (\r\n    strategy.currentNode.failureNode !== null\r\n  ) {\r\n    const nextNode = strategy.currentNode.failureNode;\r\n    nextAction = createAction(\r\n      nextNode.actionType,\r\n      nextNode.payload,\r\n      nextNode.keyedSelectors,\r\n      nextNode.agreement,\r\n      nextNode.semaphore,\r\n      nextNode.conceptSemaphore\r\n    );\r\n    nextNode.action = nextAction;\r\n    nextNode.lastActionNode = strategy.currentNode;\r\n    strategy.actionList = [...strategy.actionList, actionListEntry];\r\n    nextAction = { ...nextAction };\r\n    nextAction.strategy = {\r\n      ...strategy,\r\n      topic: strategy.topic,\r\n      data: strategy.data,\r\n      currentNode: nextNode,\r\n      actionList: strategy.actionList,\r\n    };\r\n    return nextAction;\r\n  } else {\r\n    strategy.actionList = [...strategy.actionList, actionListEntry, '\\n'];\r\n    if (\r\n      strategy.puntedStrategy !== undefined &&\r\n            strategy.puntedStrategy?.length !== 0\r\n    ) {\r\n      const nextStrategy =\r\n                strategy.puntedStrategy.shift() as ActionStrategy;\r\n      nextStrategy.puntedStrategy = strategy.puntedStrategy;\r\n      const nextEntry = `${nextStrategy.topic}.`;\r\n      nextStrategy.actionList = [\r\n        ...strategy.actionList,\r\n        nextEntry,\r\n      ];\r\n\r\n      nextStrategy.stubs = strategy.stubs;\r\n      nextStrategy.currentNode.lastActionNode = strategy.currentNode;\r\n      return strategyBegin(nextStrategy);\r\n    }\r\n    const conclude: ActionNode = {\r\n      actionType: axiumConcludeType,\r\n      successNode: null,\r\n      failureNode: null,\r\n      lastActionNode: strategy.currentNode,\r\n    };\r\n    conclude.action = createAction(conclude.actionType);\r\n    conclude.action.strategy = {\r\n      ...strategy,\r\n      currentNode: conclude,\r\n      data: data ? data : strategy.data\r\n    };\r\n    return conclude.action;\r\n  }\r\n}\r\n\r\n/**\r\n * strategyDecide(strategy: ActionStrategy, index:number, data?: any)\r\n * Returns the DecisionNode of Index reassigns ActionStrategy to that Action's strategy parameter.\r\n * If no decisionNode is found, will return EndOfActionStrategy instead.\r\n * @param data - OPTIONAL, if used will override the ActionStrategy's payload\r\n */\r\nexport const strategyDecide = (\r\n  _strategy: ActionStrategy,\r\n  decideKey: string,\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  data?: Record<string, unknown>,\r\n) => {\r\n  const strategy = {..._strategy};\r\n  let nextAction: Action;\r\n  const actionListEntry = createSentence(\r\n    strategy.currentNode,\r\n    strategy.currentNode.decisionNotes,\r\n    decideKey\r\n  );\r\n\r\n  if (strategy.currentNode.decisionNodes) {\r\n    const decisionNodes = strategy.currentNode.decisionNodes as Record<string, ActionNode>;\r\n    if (\r\n      decisionNodes[decideKey] !== null\r\n    ) {\r\n      const nextNode = decisionNodes[decideKey];\r\n      nextAction = createAction(\r\n        nextNode.actionType,\r\n        nextNode.payload,\r\n        nextNode.keyedSelectors,\r\n        nextNode.agreement,\r\n        nextNode.semaphore,\r\n        nextNode.conceptSemaphore\r\n      );\r\n      nextNode.action = nextAction;\r\n      nextNode.lastActionNode = strategy.currentNode;\r\n      strategy.actionList = [...strategy.actionList, actionListEntry];\r\n      nextAction.strategy = {\r\n        ...strategy,\r\n        topic: strategy.topic,\r\n        data: data ? data : strategy.data,\r\n        currentNode: nextNode,\r\n        actionList: strategy.actionList,\r\n      };\r\n      return nextAction;\r\n    }\r\n  }\r\n  strategy.actionList = [...strategy.actionList, actionListEntry, '\\n'];\r\n  if (\r\n    strategy.puntedStrategy !== undefined &&\r\n          strategy.puntedStrategy?.length !== 0\r\n  ) {\r\n    const nextStrategy =\r\n              strategy.puntedStrategy.shift() as ActionStrategy;\r\n    nextStrategy.puntedStrategy = strategy.puntedStrategy;\r\n    const nextEntry = `${nextStrategy.topic}.`;\r\n    nextStrategy.actionList = [\r\n      ...strategy.actionList,\r\n      nextEntry,\r\n    ];\r\n    nextStrategy.stubs = strategy.stubs;\r\n    nextStrategy.currentNode.lastActionNode = strategy.currentNode;\r\n    return strategyBegin(nextStrategy);\r\n  }\r\n  const conclude: ActionNode = {\r\n    actionType: axiumConcludeType,\r\n    successNode: null,\r\n    failureNode: null,\r\n    lastActionNode: strategy.currentNode,\r\n  };\r\n  conclude.action = createAction(conclude.actionType);\r\n  conclude.action.strategy = {\r\n    ...strategy,\r\n    currentNode: conclude,\r\n    data: data ? data : strategy.data\r\n  };\r\n  return conclude.action;\r\n};\r\n// Remember Water Boy\r\nexport const strategyPunt = (\r\n  puntedStrategy: ActionStrategy,\r\n  newStrategy: ActionStrategy,\r\n) => {\r\n  let puntList: ActionStrategy[] = [];\r\n  if (puntedStrategy.puntedStrategy !== undefined) {\r\n    puntList = [...puntedStrategy.puntedStrategy, puntedStrategy];\r\n  } else {\r\n    puntList.push(puntedStrategy);\r\n  }\r\n  newStrategy.puntedStrategy = puntList;\r\n  return newStrategy;\r\n};\r\n\r\nexport const strategySequence = (strategies: ActionStrategy[]): ActionStrategy | undefined => {\r\n  if (strategies.length > 0) {\r\n    const first = strategies[0];\r\n    const list = [];\r\n    for (let i = 1; i < strategies.length; i++) {\r\n      list.push(strategies[i]);\r\n    }\r\n    first.puntedStrategy = list;\r\n    return first;\r\n  } else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nexport const strategyBackTrack = (_strategy: ActionStrategy): Action => {\r\n  const strategy = _strategy;\r\n  if (strategy.currentNode.lastActionNode?.actionType !== nullActionType) {\r\n    const newNode = strategy.currentNode.lastActionNode as ActionNode;\r\n    if (newNode.action?.strategy?.actionList) {\r\n      newNode.action.strategy.actionList = [\r\n        ...newNode.action.strategy.actionList,\r\n        strategy.actionList[strategy.actionList.length - 1],\r\n      ];\r\n    }\r\n    return newNode.action as Action;\r\n  } else {\r\n    return axiumConclude();\r\n  }\r\n};\r\n\r\n/**\r\n * The main functionality of this helper function is to allow for asynchronous recursion within your strategies.\r\n *  As the difficulty of working with async code within a node, is that you must use a then operation\r\n *    This simplifies the process of asynchronously depleting a list until your call the next strategy decision function.\r\n *      Likewise this should be used within the context of a method, not within a strategy creator function.\r\n * @param _strategy Target ActionStrategy.\r\n * @param control A depleting list should be either the payload or data passed into this function to allow this to be halting complete.\r\n * @param payload If set will set the payload for both action and the newly created ActionNode.\r\n * @param data If set will set the data on the ActionStrategy attached to the returned action.\r\n * @returns Action\r\n */\r\nexport const strategyRecurse =\r\n  (_strategy: ActionStrategy, control: {payload?: Record<string, unknown>, data?: Record<string, unknown>}): Action => {\r\n    const strategy = {\r\n      ..._strategy\r\n    };\r\n    const currentNode = {\r\n      ..._strategy.currentNode\r\n    };\r\n    const action = {\r\n      ...currentNode.action\r\n    } as Action;\r\n    action.payload = control.payload ? control.payload : (_strategy.currentNode.action as Action).payload;\r\n    currentNode.payload = control.payload ? control.payload : _strategy.currentNode.payload;\r\n    currentNode.lastActionNode = _strategy.currentNode;\r\n    strategy.data = control.data ? control.data : _strategy.data;\r\n    strategy.actionList = [\r\n      ...strategy.actionList,\r\n      createSentence(\r\n        _strategy.currentNode,\r\n        _strategy.currentNode.successNotes,\r\n      )\r\n    ];\r\n    currentNode.action = action;\r\n    strategy.currentNode = currentNode;\r\n    action.strategy = strategy;\r\n    return action;\r\n  };\r\n\r\nexport const strategy = ({\r\n  createActionNode,\r\n  createActionNodeFromStrategy,\r\n  create: createStrategy,\r\n  begin: strategyBegin,\r\n  success: strategySuccess,\r\n  failed: strategyFailed,\r\n  decide: strategyDecide,\r\n  punt: strategyPunt,\r\n  sequence: strategySequence,\r\n  backTrack: strategyBackTrack,\r\n  recurse: strategyRecurse,\r\n});"},"For the asynchronous graph programming framework Stratimux, define the Action Strategy Data model file.\r\nThis file is what allows for the ActionStrategy data pattern to be a Universal Transformer of Data.\r\nAs each strategy is able to carry with it some set of attributes in its data field that may be\r\na combination of any number of properties. Creating a final data output that is the cumulation of all\r\nor some properties. That may utilized within a method, reducer, principle, and even in the lastStrategyData property\r\nif being observed via a plan or subscription.":{"type":"project","content":"// eslint-disable-next-line no-shadow\r\nimport { ActionStrategy } from './actionStrategy';\r\n\r\n// eslint-disable-next-line no-shadow\r\nexport enum failureConditions {\r\n  ownershipExpired = 'ownershipExpired',\r\n  ownershipBlocked = 'ownershipBlocked',\r\n  controllerExpired = 'controllerExpired',\r\n  axiumExpired = 'axiumExpired',\r\n  axiumBadGeneration = 'axiumBadGeneration'\r\n}\r\n\r\nexport const strategyData_appendFailure = (strategy: ActionStrategy, condition: failureConditions | string): Record<string, unknown> => {\r\n  if (strategy.data) {\r\n    return {\r\n      ...strategy.data,\r\n      failureCondition: condition\r\n    };\r\n  } else {\r\n    return {\r\n      failureCondition: condition\r\n    };\r\n  }\r\n};\r\n\r\nexport const strategyData_selectFailureCondition = (strategy: ActionStrategy): failureConditions | string | undefined => {\r\n  if (strategy.data) {\r\n    if (Object.keys(strategy.data).includes('failureCondition')) {\r\n      const data = strategy.data as Record<string, unknown>;\r\n      return data['failureCondition'] as failureConditions | string;\r\n    }\r\n  }\r\n  return undefined;\r\n};\r\n\r\nexport const strategyData_clearFailureCondition = (strategy: ActionStrategy): Record<string, unknown> | undefined => {\r\n  const condition = strategyData_selectFailureCondition(strategy);\r\n  const data = strategyData_select<Record<string, unknown>>(strategy);\r\n  if (condition && data) {\r\n    const newData: Record<string, unknown> = {};\r\n    for (const entry of Object.keys(data)) {\r\n      if (entry !== 'failureCondition') {\r\n        newData[entry] = data[entry];\r\n      }\r\n    }\r\n    return newData;\r\n  } else if (data && Object.keys(data).length > 0) {\r\n    return data;\r\n  } else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nexport const strategyData_select = <T>(strategy: ActionStrategy): T | undefined => {\r\n  if (strategy.data) {\r\n    return strategy.data as T;\r\n  } else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nexport const strategyData_unifyData =\r\n  <T extends Record<string, unknown>>(strategy: ActionStrategy, data: Record<string,unknown> | T): Record<string,unknown> => {\r\n    if (strategy.data) {\r\n      return {\r\n        ...strategy.data,\r\n        ...data\r\n      };\r\n    } else {\r\n      return {...data};\r\n    }\r\n  };\r\n\r\nexport const strategyData = ({\r\n  appendFailure: strategyData_appendFailure,\r\n  selectFailureCondition: strategyData_selectFailureCondition,\r\n  clearFailureCondition: strategyData_clearFailureCondition,\r\n  select: strategyData_select,\r\n  unifyData: strategyData_unifyData,\r\n});"},"For the asynchronous graph programming framework Stratimux, define the Axium model file.\r\nThis file dictates the creation of the Axium itself and engages all necessary parts to ensure its functionality\r\nas a provably recursive terminating function.":{"type":"project","content":"import {\r\n  Observable,\r\n  Subject,\r\n  withLatestFrom,\r\n  Subscriber,\r\n  catchError,\r\n  Subscription,\r\n  Observer,\r\n} from 'rxjs';\r\nimport { Action, createCacheSemaphores } from './action';\r\nimport { strategyBegin } from './actionStrategy';\r\nimport { Concept, Concepts, Mode, forEachConcept, qualityToString } from './concept';\r\nimport {\r\n  createAxiumConcept,\r\n  AxiumState,\r\n  initializationStrategy,\r\n} from '../concepts/axium/axium.concept';\r\nimport {\r\n  axiumAppendActionListToDialog,\r\n} from '../concepts/axium/qualities/appendActionListToDialog.quality';\r\nimport { axiumPreClose } from '../concepts/axium/qualities/preClose.quality';\r\nimport { StagePlanner, Staging } from './stagePlanner';\r\n\r\nexport const blockingMethodSubscription = (action$: Subject<Action>, action: Action) => {\r\n  if (\r\n    action.strategy &&\r\n    // Logical Determination: axiumConcludeType\r\n    action.semaphore[3] === 3\r\n  ) {\r\n    // Allows for reducer next in sequence\r\n    const appendToDialog = axiumAppendActionListToDialog({\r\n      actionList: action.strategy.actionList,\r\n      strategyTopic: action.strategy.topic,\r\n      strategyData: action.strategy.data,\r\n    });\r\n    action$.next(appendToDialog);\r\n    action$.next(action);\r\n  } else if (\r\n    action.strategy &&\r\n    // Logical Determination: axiumBadType\r\n    action.semaphore[3] !== 1\r\n  ) {\r\n    action$.next(action);\r\n  }\r\n};\r\n\r\nexport const defaultMethodSubscription = (action$: Subject<Action>, action: Action) => {\r\n  if (\r\n    action.strategy &&\r\n    // Logical Determination: axiumConcludeType\r\n    action.semaphore[3] === 3\r\n  ) {\r\n    // Allows for reducer next in sequence\r\n    const appendToDialog = axiumAppendActionListToDialog({\r\n      actionList: action.strategy.actionList,\r\n      strategyTopic: action.strategy.topic,\r\n      strategyData: action.strategy.data\r\n    });\r\n    setTimeout(() => {\r\n      action$.next(appendToDialog);\r\n      action$.next(action);\r\n    }, 0);\r\n  } else if (\r\n    action.strategy &&\r\n    // Logical Determination: axiumBadType\r\n    action.semaphore[3] !== 1\r\n  ) {\r\n    setTimeout(() => {\r\n      action$.next(action);\r\n    }, 0);\r\n  }\r\n};\r\n\r\nexport function createAxium(\r\n  name: string,\r\n  initialConcepts: Concept[],\r\n  logging?: boolean,\r\n  storeDialog?: boolean,\r\n  logActionStream?: boolean\r\n): Axium {\r\n  const concepts: Concepts = {};\r\n  const init = [createAxiumConcept(name, storeDialog, logging, logActionStream), ...initialConcepts];\r\n  init.forEach((concept, i) => {\r\n    concept.semaphore = i;\r\n    concepts[i] = concept;\r\n  });\r\n  let axiumState = concepts[0].state as AxiumState;\r\n  axiumState.cachedSemaphores = createCacheSemaphores(concepts);\r\n  forEachConcept(concepts, ((concept, semaphore) => {\r\n    concept.qualities.forEach(quality => {\r\n      if (quality.methodCreator) {\r\n        [quality.method, quality.subject] = quality.methodCreator(axiumState.concepts$, semaphore);\r\n        quality.method.pipe(\r\n          catchError((err: unknown, caught: Observable<Action>) => {\r\n            if (axiumState.logging) {\r\n              console.error('METHOD ERROR', err);\r\n            }\r\n            return caught;\r\n          }));\r\n        quality.toString = qualityToString(quality);\r\n        const methodSub = quality.method.subscribe((action: Action) => {\r\n          blockingMethodSubscription(axiumState.action$, action);\r\n        }) as Subscriber<Action>;\r\n        axiumState = concepts[0].state as AxiumState;\r\n        axiumState.methodSubscribers.push({\r\n          name: concept.name,\r\n          subscription: methodSub,\r\n        });\r\n      }\r\n    });\r\n    if (semaphore !== 0 && concept.mode !== undefined) {\r\n      axiumState = concepts[0].state as AxiumState;\r\n      const names = axiumState.modeNames;\r\n      const modes = concepts[0].mode as Mode[];\r\n      concept.mode.forEach((mode) => {\r\n        modes.push(mode);\r\n        names.push(concept.name);\r\n      });\r\n    }\r\n  }));\r\n  axiumState.action$\r\n    .pipe(\r\n      withLatestFrom(axiumState.actionConcepts$),\r\n      // This will be where the Ownership Principle will be Loaded\r\n      // As Such is a Unique Principle in the Scope of State Management\r\n      // This will also allow for Actions to be added to the Stream to Update to most Recent Values\r\n      catchError((err: unknown, caught: Observable<[Action, Concepts]>) => {\r\n        if (axiumState.logging) {\r\n          console.error('ACTION STREAM ERROR', err);\r\n        }\r\n        return caught;\r\n      }),\r\n    )\r\n    .subscribe(([action, _concepts]: [Action, Concepts]) => {\r\n      // Would be notifying methods\r\n      const _axiumState = _concepts[0].state as AxiumState;\r\n      const modeIndex = _axiumState.modeIndex;\r\n      if (getAxiumState(_concepts).logActionStream) {\r\n        console.log('CHECK ACTION STREAM', action.type, action.payload, action.semaphore, action.strategy?.topic);\r\n      }\r\n      const modes = _concepts[0].mode as Mode[];\r\n      const mode = modes[modeIndex] as Mode;\r\n      mode([action, _concepts, _axiumState.action$, _axiumState.concepts$]);\r\n    });\r\n\r\n  axiumState = concepts[0].state as AxiumState;\r\n  const action$ = axiumState.action$;\r\n  axiumState.actionConcepts$.next(concepts);\r\n  axiumState.concepts$.init(concepts);\r\n  axiumState.action$.next(\r\n    strategyBegin(initializationStrategy(concepts)),\r\n  );\r\n  const close = (exit?: boolean) => {\r\n    action$.next(axiumPreClose({\r\n      exit: exit ? exit : false\r\n    }));\r\n  };\r\n  return {\r\n    subscribe: axiumState.concepts$.subscribe.bind(axiumState.concepts$),\r\n    unsubscribe: axiumState.concepts$.unsubscribe.bind(axiumState.concepts$),\r\n    close: close,\r\n    dispatch: (action: Action) => {\r\n      action$.next(action);\r\n    },\r\n    plan: axiumState.concepts$.outerPlan.bind(axiumState.concepts$),\r\n  };\r\n}\r\n\r\nexport type Axium = {\r\n  subscribe: (observerOrNext?: Partial<Observer<Concepts>> | ((value: Concepts) => void) | undefined) => Subscription;\r\n  unsubscribe: () => void;\r\n  close: (exit?: boolean) => void;\r\n  dispatch: (action: Action) => void;\r\n  plan: (title: string, stages: Staging[]) => StagePlanner\r\n}\r\n\r\nexport const getAxiumState = (concepts: Concepts) => (concepts[0].state as AxiumState);\r\n\r\nexport const isAxiumOpen = (concepts: Concepts) => ((concepts[0].state as AxiumState).open);\r\n\r\nexport const axium = ({\r\n  create: createAxium,\r\n  getState: getAxiumState,\r\n  isOpen: isAxiumOpen\r\n});"},"For the asynchronous graph programming framework Stratimux, define the Concept model file.\r\nThis file defines the Concept abstraction that the Axium uses to Transform its functionality.\r\nA concept is composed of name, unified, state, qualities, semaphore, principles, and some meta attributes if necessary.":{"type":"project","content":"import { Observable, Subject } from 'rxjs';\r\nimport { Action, ActionType } from './action';\r\nimport { PrincipleFunction } from '../model/principle';\r\nimport { strategySuccess } from './actionStrategy';\r\nimport { map } from 'rxjs';\r\nimport { KeyedSelector } from './selector';\r\nimport { axiumConcludeType } from '../concepts/axium/qualities/conclude.quality';\r\nimport { UnifiedSubject } from './stagePlanner';\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport type Reducer = (state: any, action: Action) => any;\r\n\r\nexport type Method = Observable<Action>;\r\nexport type Principle = Observable<Action>;\r\n\r\nexport type Mode = ([action, concept, action$, concepts$]: [\r\n  Action,\r\n  Concepts,\r\n  Subject<Action>,\r\n  UnifiedSubject,\r\n]) => void;\r\n\r\nexport type MethodCreator = (concept$?: Subject<Concepts>, semaphore?: number) => [Method, Subject<Action>];\r\n// export type MethodCreator = (concept$?: UnifiedSubject, semaphore?: number) => [Method, Subject<Action>];\r\n\r\nexport type Quality = {\r\n  actionType: ActionType;\r\n  reducer: Reducer;\r\n  toString: () => string;\r\n  methodCreator?: MethodCreator;\r\n  method?: Method;\r\n  subject?: Subject<Action>;\r\n  keyedSelectors?: KeyedSelector[];\r\n  meta?: Record<string,unknown>;\r\n  analytics?: Record<string,unknown>;\r\n};\r\n\r\nexport type Concept = {\r\n  name: string;\r\n  unified: string[];\r\n  state: Record<string, unknown>;\r\n  qualities: Quality[];\r\n  semaphore: number;\r\n  principles?: PrincipleFunction[];\r\n  mode?: Mode[];\r\n  meta?: Record<string,unknown>;\r\n};\r\n\r\nexport type Concepts = Record<number, Concept>;\r\n\r\nexport function createConcept(\r\n  name: string,\r\n  state: Record<string, unknown>,\r\n  qualities?: Quality[],\r\n  principles?: PrincipleFunction[],\r\n  mode?: Mode[],\r\n  meta?: Record<string,unknown>\r\n): Concept {\r\n  if (mode) {\r\n    mode.forEach((m, i) => {\r\n      m.toString = () => `MODE: ${name} ${i}`;\r\n    });\r\n  }\r\n  if (principles) {\r\n    principles.forEach((p, i) => {\r\n      p.toString = () => `PRINCIPLE: ${name} ${i}`;\r\n    });\r\n  }\r\n  return {\r\n    name,\r\n    unified: [],\r\n    state,\r\n    qualities: qualities ? qualities : [],\r\n    semaphore: -1,\r\n    principles,\r\n    mode,\r\n    meta\r\n  };\r\n}\r\n\r\n/**\r\n * This will remove any duplicate qualities, principles, and modes.\r\n * Note that for now the check for mode and principle are based on concept name and loaded index;\r\n */\r\nfunction filterSimilarQualities(concept: Concept) {\r\n  const newQualities: Quality[] = [];\r\n  const newUnified: string[] = [];\r\n  const newPrinciples: PrincipleFunction[] = [];\r\n  const newMode: Mode[] = [];\r\n  for (let i = 0; i < concept.qualities.length; i++) {\r\n    let found = false;\r\n    for (let j = i + 1; j < concept.qualities.length; j++) {\r\n      if (concept.qualities[i].actionType === concept.qualities[j].actionType) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!found) {\r\n      newQualities.push(concept.qualities[i]);\r\n    }\r\n  }\r\n  concept.qualities = newQualities;\r\n  for (let i = 0; i < concept.unified.length; i++) {\r\n    let found = false;\r\n    for (let j = i + 1; j < concept.unified.length; j++) {\r\n      if (concept.unified[i] === concept.unified[j]) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!found) {\r\n      newUnified.push(concept.unified[i]);\r\n    }\r\n  }\r\n  concept.unified = newUnified;\r\n  if (concept.principles) {\r\n    for (let i = 0; i < concept.principles.length; i++) {\r\n      let found = false;\r\n      for (let j = i + 1; j < concept.principles.length; j++) {\r\n        if (concept.principles[i].toString() === concept.principles[j].toString()) {\r\n          found = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!found) {\r\n        newPrinciples.push(concept.principles[i]);\r\n      }\r\n    }\r\n    concept.principles = newPrinciples;\r\n  }\r\n  if (concept.mode) {\r\n    for (let i = 0; i < concept.mode.length; i++) {\r\n      let found = false;\r\n      for (let j = i + 1; j < concept.mode.length; j++) {\r\n        if (concept.mode[i].toString() === concept.mode[j].toString()) {\r\n          found = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!found) {\r\n        newMode.push(concept.mode[i]);\r\n      }\r\n    }\r\n    concept.mode = newMode;\r\n  }\r\n  return concept;\r\n}\r\n\r\nfunction unify(base: Concept, target: Concept): Concept {\r\n  if (target.name !== '') {\r\n    base.unified.push(target.name);\r\n  }\r\n  base.unified = [\r\n    ...base.unified,\r\n    ...target.unified\r\n  ];\r\n  base.state = {\r\n    ...base.state,\r\n    ...target.state,\r\n  };\r\n  base.qualities = [\r\n    ...base.qualities,\r\n    ...target.qualities,\r\n  ];\r\n  if (target.principles) {\r\n    if (base.principles) {\r\n      base.principles = [\r\n        ...base.principles,\r\n        ...target.principles\r\n      ];\r\n    } else {\r\n      base.principles = [\r\n        ...target.principles\r\n      ];\r\n    }\r\n  }\r\n  if (target.mode) {\r\n    if (base.mode) {\r\n      base.mode = [\r\n        ...base.mode,\r\n        ...target.mode\r\n      ];\r\n    } else {\r\n      base.mode = [\r\n        ...target.mode\r\n      ];\r\n    }\r\n  }\r\n  if (target.meta) {\r\n    if (base.meta) {\r\n      base.meta = {\r\n        ...base.meta,\r\n        ...target.meta\r\n      };\r\n    } else {\r\n      base.meta = {\r\n        ...target.mode\r\n      };\r\n    }\r\n  }\r\n  return base;\r\n}\r\n/**\r\n * This will unify concepts while prioritizing qualities later in the provided concepts list via recomposition.\r\n *  Then finally unify the emergent concept with final priority.\r\n */\r\nexport function unifyConcepts(\r\n  concepts: Concept[],\r\n  emergentConcept: Concept\r\n): Concept {\r\n  let newConcept = createConcept('', {});\r\n  forEachConcept(concepts, (concept => {\r\n    newConcept = unify(newConcept, concept);\r\n  }));\r\n  newConcept = unify(newConcept, emergentConcept);\r\n  newConcept.unified = newConcept.unified.filter(name => name !== emergentConcept.name);\r\n  newConcept.name = emergentConcept.name;\r\n  if (newConcept.mode) {\r\n    newConcept.mode.forEach((m, i) => {\r\n      m.toString = () => `MODE: ${newConcept.name} ${i}`;\r\n    });\r\n  }\r\n  if (newConcept.principles) {\r\n    newConcept.principles.forEach((p, i) => {\r\n      p.toString = () => `PRINCIPLE: ${newConcept.name} ${i}`;\r\n    });\r\n  }\r\n  return filterSimilarQualities(newConcept);\r\n}\r\n\r\nexport const getUnifiedName = (concepts: Concepts, semaphore: number): string | undefined => (concepts[semaphore]?.name);\r\n\r\n// Will return -1 if not found\r\nexport const getConceptSemaphore = (concepts: Concepts, conceptName: string): number => {\r\n  // eslint-disable-next-line consistent-return\r\n  forEachConcept(concepts, (concept, semaphore) => {\r\n    if (concept.name === conceptName) {\r\n      return semaphore;\r\n    }\r\n  });\r\n  return -1;\r\n};\r\n\r\nexport function createQuality(\r\n  actionType: ActionType,\r\n  reducer: Reducer,\r\n  methodCreator?: MethodCreator,\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  keyedSelectors?: KeyedSelector[],\r\n  meta?: Record<string,unknown>,\r\n  analytics?: Record<string,unknown>,\r\n): Quality {\r\n  return {\r\n    actionType,\r\n    reducer,\r\n    methodCreator,\r\n    keyedSelectors,\r\n    meta,\r\n    analytics\r\n  };\r\n}\r\n\r\nexport function defaultReducer(state: unknown, _: Action) {\r\n  return state;\r\n}\r\ndefaultReducer.toString = () => ('Default Reducer');\r\n\r\nexport function nullReducer(_: unknown, __: Action) {\r\n  return null;\r\n}\r\nnullReducer.toString = () => ('Null Reducer');\r\n\r\nexport const defaultMethodCreator: MethodCreator = () : [Method, Subject<Action>] =>  {\r\n  const defaultSubject = new Subject<Action>();\r\n  const defaultMethod: Method = defaultSubject.pipe(\r\n    map((action: Action) => {\r\n      if (action.strategy) {\r\n        return strategySuccess(action.strategy);\r\n      }\r\n      return {\r\n        ...action,\r\n        type: axiumConcludeType\r\n      };\r\n    }),\r\n  );\r\n\r\n  defaultMethod.toString = () => ('Default Method');\r\n  return [defaultMethod, defaultSubject];\r\n};\r\n\r\nexport const isConceptLoaded = (concepts: Concepts, conceptName: string): boolean => {\r\n  const conceptKeys = Object.keys(concepts);\r\n  for (const i of conceptKeys) {\r\n    const index = Number(i);\r\n    if (concepts[index].name === conceptName) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const areConceptsLoaded = (concepts: Concepts, conceptNames: string[]): boolean => {\r\n  let allExists = true;\r\n  const conceptKeys = Object.keys(concepts);\r\n  for (const name of conceptNames) {\r\n    let found = false;\r\n    for (const i of conceptKeys) {\r\n      const index = Number(i);\r\n      if (name === concepts[index].name) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!found) {\r\n      allExists = false;\r\n      break;\r\n    }\r\n  }\r\n  return allExists;\r\n};\r\n\r\nexport const forEachConcept = (concepts: Concepts, each: (concept: Concept, semaphore?: number) => void) => {\r\n  const conceptKeys = Object.keys(concepts);\r\n  for (const i of conceptKeys) {\r\n    const index = Number(i);\r\n    each(concepts[index], index);\r\n  }\r\n};\r\n\r\nconst stateToString = (state: Record<string, unknown>): string => {\r\n  let final = '{\\n';\r\n  const keys = Object.keys(state);\r\n  for (const key of keys) {\r\n    let input = '';\r\n    try {\r\n      input += `${key}: ${JSON.stringify(state[key])},\\n`;\r\n    } catch (err) {\r\n      input = `${key}: [CIRCULAR],\\n`;\r\n    }\r\n    final += input;\r\n  }\r\n  final += '}';\r\n  return final;\r\n};\r\n\r\nexport const conceptToString = (concept: Concept): string => {\r\n  let output = '';\r\n  output += `{\\nname: ${concept.name},`;\r\n  if (concept.unified.length > 0) {\r\n    output += `\\nunified: ${concept.unified},`;\r\n  }\r\n  output += `\\nqualities: [ ${concept.qualities.toString()}\\n],`;\r\n  output += `\\nstate: ${stateToString(concept.state)}, `;\r\n  if (concept.principles) {\r\n    output += `\\nprinciples: [ ${concept.principles.map(p => p.toString()).join(',')} ]`;\r\n  }\r\n  if (concept.mode) {\r\n    output += `\\nmode: [ ${concept.mode.map(m => m.toString()).join(',')} ]`;\r\n  }\r\n  if (concept.meta) {\r\n    output += `\\nmeta: ${JSON.stringify(concept.meta)}`;\r\n  }\r\n  output += '\\n}';\r\n  return output;\r\n};\r\n\r\nexport const conceptsToString = (concepts: Concepts): string => {\r\n  const conceptStringArray: string[] = [];\r\n  forEachConcept(concepts, (concept) => {\r\n    conceptStringArray.push(conceptToString(concept));\r\n  });\r\n  conceptStringArray.push(']');\r\n  return '[\\n' + conceptStringArray.join(',\\n');\r\n};\r\n\r\nexport const qualityToString = (quality: Quality) => () => {\r\n  const actionType = quality.actionType;\r\n  const r = quality.reducer.toString();\r\n  const reducer = r === 'Default Reducer' ? r : 'Reducer';\r\n  const method = quality.method?.toString();\r\n  return (`\\n{\\nactionType: ${actionType},\\nreducer: ${reducer},\\nmethod: ${method}\\n}`);\r\n};\r\n\r\nexport const concept = {\r\n  create: createConcept,\r\n  unify: unifyConcepts,\r\n  createQuality,\r\n  defaultReducer,\r\n  defaultMethodCreator,\r\n  isLoaded: isConceptLoaded,\r\n  areLoaded: areConceptsLoaded,\r\n  forEach: forEachConcept,\r\n  toString: conceptToString,\r\n  toStringConcepts: conceptsToString,\r\n  toStringQuality: qualityToString,\r\n};"},"For the asynchronous graph programming framework Stratimux, define the Method model file.\r\nThis file hold a series of helper functions that enable users to quickly create specific provably terminating methods\r\nwithin their own defined qualities.":{"type":"project","content":"import { Observable, Subject, map, switchMap, withLatestFrom } from 'rxjs';\r\nimport { Concepts } from './concept';\r\nimport { ActionController, createActionController$ } from './actionController';\r\nimport { ActionStrategy } from './actionStrategy';\r\nimport { KeyedSelector, selectUnifiedState } from './selector';\r\nimport { debounceAction, throttleAction } from './actionOperators';\r\nimport { axiumConclude } from '../concepts/axium/qualities/conclude.quality';\r\n\r\nexport type ActionType = string;\r\ntype Action = {\r\n    type: ActionType;\r\n    semaphore: [number, number, number, number];\r\n    payload?: Record<string, unknown>;\r\n    strategy?: ActionStrategy;\r\n    keyedSelectors?: KeyedSelector[];\r\n    agreement?: number;\r\n    expiration: number;\r\n    axium?: string;\r\n};\r\ntype Method = Observable<Action> & {toString: () => string};\r\n\r\nexport const createMethod =\r\n  (method: (action: Action) => Action): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      map((action: Action) => {\r\n        const methodAction = method(action);\r\n        if (methodAction.strategy) {\r\n          return methodAction;\r\n        }\r\n        const conclude = axiumConclude();\r\n        return {\r\n          ...action,\r\n          ...conclude,\r\n        };\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodWithState =\r\n  <T>(\r\n    methodWithState: (action: Action, state: T) => Action,\r\n    concepts$: Subject<Concepts>,\r\n    semaphore: number\r\n  ): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      withLatestFrom(concepts$),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      map(([act, state] : [Action, T]) => {\r\n        const methodAction = methodWithState(act, state);\r\n        if (methodAction.strategy) {\r\n          return methodAction;\r\n        }\r\n        const conclude = axiumConclude();\r\n        return {\r\n          ...act,\r\n          ...conclude,\r\n        };\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethod =\r\n  (asyncMethod: (controller: ActionController, action: Action) => void): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      switchMap(act => createActionController$(act, (controller: ActionController, action: Action) => {\r\n        asyncMethod(controller, action);\r\n      })),\r\n    );\r\n    defaultMethod.toString = () => ('Async Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodWithState =\r\n  <T>(\r\n    asyncMethodWithState: (controller: ActionController, action: Action, state: T) => void,\r\n    concepts$: Subject<Concepts>,\r\n    semaphore: number\r\n  )\r\n    : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      withLatestFrom(concepts$),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      switchMap(([act, state] : [Action, T]) => createActionController$(act, (controller: ActionController, action: Action) => {\r\n        asyncMethodWithState(controller, action, state);\r\n      })),\r\n    );\r\n    defaultMethod.toString = () => ('Async Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodDebounce =\r\n  (method: (action: Action) => Action, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      map((action: Action) => {\r\n        // Logically Determined axiumConclude\r\n        if (action.semaphore[3] !== 3) {\r\n          const methodAction = method(action);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...action,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return action;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Debounce Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodDebounceWithState =\r\n  <T>(methodWithState: (action: Action, state: T) => Action, concepts$: Subject<Concepts>, semaphore: number, duration: number)\r\n    : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      withLatestFrom(concepts$),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      map(([act, state] : [Action, T]) => {\r\n        // Logically Determined axiumConclude\r\n        if (act.semaphore[3] !== 3) {\r\n          const methodAction = methodWithState(act, state);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...act,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return act;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Debounce Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodDebounce =\r\n  (asyncMethod: (controller: ActionController, action: Action) => void, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      switchMap((act) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethod(controller, action);\r\n        });\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Async Debounce Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodDebounceWithState =\r\n  <T>(asyncMethodWithState: (controller: ActionController, action: Action, state: T) =>\r\n    void, concepts$: Subject<Concepts>, semaphore: number, duration: number, ): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      withLatestFrom(concepts$),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      switchMap(([act, state] : [Action, T]) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethodWithState(controller, action, state);\r\n        });\r\n      })\r\n    );\r\n    defaultMethod.toString = () => ('Async Debounce Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodThrottle =\r\n  (method: (action: Action) => Action, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      map((action: Action) => {\r\n        // Logically Determined axiumConclude\r\n        if (action.semaphore[3] !== 3) {\r\n          const methodAction = method(action);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...action,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return action;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Throttle Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodThrottleWithState =\r\n  <T>(methodWithState: (action: Action, state: T) => Action, concepts$: Subject<Concepts>, semaphore: number, duration: number)\r\n    : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      withLatestFrom(concepts$),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      map(([act, state] : [Action, T]) => {\r\n        // Logically Determined axiumConclude\r\n        if (act.semaphore[3] !== 3) {\r\n          const methodAction = methodWithState(act, state);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...act,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return act;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Throttle Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodThrottle =\r\n  (asyncMethod: (controller: ActionController, action: Action) => void, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      switchMap((act) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethod(controller, action);\r\n        });\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Async Throttle Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodThrottleWithState =\r\n  <T>(asyncMethodWithState: (controller: ActionController, action: Action, state: T) =>\r\n    void, concepts$: Subject<Concepts>, semaphore: number, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      withLatestFrom(concepts$),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      switchMap(([act, state] : [Action, T]) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethodWithState(controller, action, state);\r\n        });\r\n      })\r\n    );\r\n    defaultMethod.toString = () => ('Async Throttle Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodWithConcepts =\r\n  (\r\n    methodWithConcepts: (action: Action, concepts: Concepts, semaphore: number) => Action,\r\n    concepts$: Subject<Concepts>,\r\n    semaphore: number\r\n  ): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      withLatestFrom(concepts$),\r\n      map(([act, concepts] : [Action, Concepts]) => {\r\n        const methodAction = methodWithConcepts(act, concepts, semaphore);\r\n        if (methodAction.strategy) {\r\n          return methodAction;\r\n        }\r\n        const conclude = axiumConclude();\r\n        return {\r\n          ...act,\r\n          ...conclude,\r\n        };\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodWithConcepts =\r\n  (\r\n    asyncMethodWithConcepts: (controller: ActionController, action: Action, concepts: Concepts, semaphore: number) => void,\r\n    concepts$: Subject<Concepts>,\r\n    semaphore: number\r\n  )\r\n    : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      withLatestFrom(concepts$ ),\r\n      switchMap(([act, concepts] : [Action, Concepts]) => createActionController$(act, (controller: ActionController, action: Action) => {\r\n        asyncMethodWithConcepts(controller, action, concepts, semaphore);\r\n      })),\r\n    );\r\n    defaultMethod.toString = () => ('Async Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodDebounceWithConcepts =\r\n  (\r\n    methodWithConcepts: (action: Action, concepts: Concepts, semaphore: number) => Action, concepts$: Subject<Concepts>,\r\n    semaphore: number,\r\n    duration: number\r\n  ) : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      withLatestFrom(concepts$),\r\n      map(([act, concepts] : [Action, Concepts]) => {\r\n        // Logically Determined axiumConclude\r\n        if (act.semaphore[3] !== 3) {\r\n          const methodAction = methodWithConcepts(act, concepts, semaphore);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...act,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return act;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Debounce Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodDebounceWithConcepts =\r\n  (asyncMethodWithConcepts: (controller: ActionController, action: Action, concepts: Concepts, semaphore: number) =>\r\n    void, concepts$: Subject<Concepts>, semaphore: number, duration: number, ): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      withLatestFrom(concepts$),\r\n      switchMap(([act, concepts] : [Action, Concepts]) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethodWithConcepts(controller, action, concepts, semaphore);\r\n        });\r\n      })\r\n    );\r\n    defaultMethod.toString = () => ('Async Debounce Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodThrottleWithConcepts =\r\n  (\r\n    methodWithConcepts: (action: Action, concepts: Concepts, semaphore: number) => Action,\r\n    concepts$: Subject<Concepts>,\r\n    semaphore: number,\r\n    duration: number\r\n  ) : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      withLatestFrom(concepts$),\r\n      map(([act, concepts] : [Action, Concepts]) => {\r\n        // Logically Determined axiumConclude\r\n        if (act.semaphore[3] !== 3) {\r\n          const methodAction = methodWithConcepts(act, concepts, semaphore);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...act,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return act;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Throttle Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodThrottleWithConcepts =\r\n  (asyncMethodWithConcepts: (controller: ActionController, action: Action, concepts: Concepts, semaphore: number) =>\r\n    void, concepts$: Subject<Concepts>, semaphore: number, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      withLatestFrom(concepts$),\r\n      switchMap(([act, concepts] : [Action, Concepts]) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethodWithConcepts(controller, action, concepts, semaphore);\r\n        });\r\n      })\r\n    );\r\n    defaultMethod.toString = () => ('Async Throttle Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\n\r\nexport const method = ({\r\n  create: createMethod,\r\n  createWithState: createMethodWithState,\r\n  createWithConcepts: createMethodWithConcepts,\r\n  createDebounce: createMethodDebounce,\r\n  createDebounceWithState: createMethodDebounceWithState,\r\n  createDebounceWithConcepts: createMethodDebounceWithConcepts,\r\n  createThrottle: createMethodThrottle,\r\n  createThrottleWithState: createMethodThrottleWithState,\r\n  createThrottleWithConcepts: createMethodThrottleWithConcepts,\r\n  createAsync: createAsyncMethod,\r\n  createAsyncDebounce: createAsyncMethodDebounce,\r\n  createAsyncDebounceWithState: createAsyncMethodDebounceWithState,\r\n  createAsyncDebounceWithConcepts: createAsyncMethodDebounceWithConcepts,\r\n  createAsyncThrottle: createAsyncMethodThrottle,\r\n  createAsyncThrottleWithState: createAsyncMethodThrottleWithState,\r\n  createAsyncThrottleWithConcepts: createAsyncMethodThrottleWithConcepts,\r\n});"},"For the asynchronous graph programming framework Stratimux, define the Ownership model file.\r\nThis file will dictate functionality used within the Ownership Concept to engage in its functionality.":{"type":"project","content":"/* eslint-disable max-depth */\r\nimport { Action, areSemaphoresEqual } from '../model/action';\r\nimport { OwnershipState, ownershipName } from '../concepts/ownership/ownership.concept';\r\nimport { Concepts } from './concept';\r\nimport { selectState } from './selector';\r\nimport { ActionNode, ActionStrategy } from './actionStrategy';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { randomUUID } from 'crypto';\r\n\r\nexport type OwnershipLedger = Map<string, OwnershipTicket[]>;\r\n\r\nexport type OwnershipTicket = {\r\n  ticket: string;\r\n  expiration: number;\r\n}\r\n\r\nexport type OwnershipTicketStub = {\r\n  key: string,\r\n  ticket: string,\r\n}\r\n\r\nexport const createOwnershipLedger = (): OwnershipLedger => ( new Map<string, OwnershipTicket[]>());\r\n\r\nexport const ownershipShouldBlock = (concepts: Concepts, action: Action): boolean => {\r\n  const qualityKeys = concepts[action.semaphore[0]].qualities[action.semaphore[1]].keyedSelectors;\r\n  const actionSelectors = action.keyedSelectors;\r\n  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  let shouldBlock = false;\r\n  // Quality Action no Keys, no Strategy\r\n  if (qualityKeys && !actionSelectors && action.strategy === undefined) {\r\n    for (let i = 0; i < qualityKeys.length; i++) {\r\n      if (ownershipLedger.has(qualityKeys[i].keys)) {\r\n        shouldBlock = true;\r\n        break;\r\n      }\r\n    }\r\n  // ActionStrategy, with Keys\r\n  } else if (actionSelectors && action.strategy && action.strategy.stubs === undefined) {\r\n    for (let i = 0; i < actionSelectors.length; i++) {\r\n      if (ownershipLedger.has(actionSelectors[i].keys)) {\r\n        shouldBlock = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  if (!shouldBlock && action?.strategy?.stubs) {\r\n    const stubs = action.strategy.stubs;\r\n    let firstOfAllLines = false;\r\n    for (let i = 0; i < stubs.length; i++) {\r\n      const line = ownershipLedger.get(action.strategy.stubs[i].key);\r\n      if (line) {\r\n        for (const [_, stub] of line.entries()) {\r\n          if (stubs[i].ticket === stub.ticket) {\r\n            firstOfAllLines = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      shouldBlock = !firstOfAllLines;\r\n    }\r\n  }\r\n  return shouldBlock;\r\n};\r\n\r\nexport const clearStubs = (concepts: Concepts, strategy: ActionStrategy): Concepts => {\r\n  const newConcepts = concepts;\r\n  const stubs = strategy.stubs;\r\n  const ownershipState = selectState(newConcepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  if (stubs) {\r\n    stubs.forEach(ticketStub => {\r\n      const line = ownershipLedger.get(ticketStub.key);\r\n      if (line) {\r\n        const newLine = [] as OwnershipTicket[];\r\n        for (const stub of line) {\r\n          if (stub.ticket !== ticketStub.ticket) {\r\n            newLine.push(stub);\r\n          }\r\n        }\r\n        if (newLine.length === 0) {\r\n          ownershipLedger.delete(ticketStub.key);\r\n        } else {\r\n          ownershipLedger.set(ticketStub.key, newLine);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  return newConcepts;\r\n};\r\n\r\nexport const editStubs = (_concepts: Concepts, oldAction: Action, newAction: Action): [Concepts, Action] => {\r\n  const concepts = _concepts;\r\n  const oldStrategy = oldAction.strategy as ActionStrategy;\r\n  const newStrategy = newAction.strategy as ActionStrategy;\r\n  newStrategy.stubs = [];\r\n  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  if (oldStrategy.stubs) {\r\n    oldStrategy.stubs.forEach((ticketStub) => {\r\n      const line = ownershipLedger.get(ticketStub.key);\r\n      if (line) {\r\n        for (const stub of line) {\r\n          if (stub.ticket === ticketStub.ticket) {\r\n            stub.expiration = newAction.expiration;\r\n            newStrategy.stubs?.push({\r\n              key: ticketStub.key,\r\n              ticket: stub.ticket\r\n            });\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n  return [concepts, newAction];\r\n};\r\n\r\nexport const checkIn =\r\n(concepts: Concepts, action: Action): [Concepts, Action] => {\r\n  const newConcepts = concepts;\r\n  const ownershipState = selectState(newConcepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  const strategy = action.strategy;\r\n  if (strategy) {\r\n    strategy.stubs = strategy.stubs ? strategy.stubs : [] as OwnershipTicketStub[];\r\n    action.keyedSelectors?.forEach(keyed => {\r\n      const key = keyed.keys;\r\n      const entry = ownershipLedger.get(key);\r\n      let found = false;\r\n      if (entry && action.strategy?.stubs) {\r\n        for (const ticketStub of entry) {\r\n          for (const stub of action.strategy.stubs) {\r\n            if (ticketStub.ticket === stub.ticket && stub.key === key) {\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n          if (found) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      if (!found) {\r\n        const expiration = action.expiration;\r\n        const axiumState = concepts[0].state as AxiumState;\r\n        const ticket = axiumState.name + randomUUID();\r\n        const newTicketStub = {\r\n          key,\r\n          ticket,\r\n          expiration\r\n        };\r\n        const newTicket = {\r\n          ticket,\r\n          expiration\r\n        };\r\n        strategy.stubs?.push(newTicketStub);\r\n        if (entry) {\r\n          entry.push(newTicket);\r\n        } else {\r\n          ownershipLedger.set(key, [newTicket]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  return  [\r\n    newConcepts,\r\n    action\r\n  ];\r\n};\r\n\r\nexport const isActionReady = (concepts: Concepts, _action: Action): [Concepts, boolean] => {\r\n  const action = _action;\r\n  const stubs = action.strategy?.stubs;\r\n  if (stubs) {\r\n    return stubActionStrategy(concepts, action);\r\n  } else {\r\n    return qualityAction(concepts, action);\r\n  }\r\n};\r\n\r\nconst stubActionStrategy = (concepts: Concepts, _action: Action): [Concepts, boolean] => {\r\n  const action = _action;\r\n  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  const stubs = action.strategy?.stubs as OwnershipTicketStub[];\r\n  let frontOfAllLines = true;\r\n  // let expired = false;\r\n  for (const stub of stubs) {\r\n    const positions = ownershipLedger.get(stub.key);\r\n    if (positions) {\r\n      for (const [i, pos] of positions.entries()) {\r\n        if (i === 0 && pos.ticket === stub.ticket) {\r\n          continue;\r\n        } else {\r\n          frontOfAllLines = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return [concepts, frontOfAllLines];\r\n};\r\n\r\nconst qualityAction = (concepts: Concepts, _action: Action): [Concepts, boolean] => {\r\n  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  const action = _action;\r\n  const qualitySelectors = concepts[action.semaphore[0]].qualities[action.semaphore[1]].keyedSelectors;\r\n  let readyToGo = true;\r\n\r\n  if (qualitySelectors) {\r\n    for (const selector of qualitySelectors) {\r\n      const key = selector.keys;\r\n      if (ownershipLedger.get(key)) {\r\n        readyToGo = false;\r\n        break;\r\n      }\r\n    }\r\n    return [concepts, readyToGo];\r\n  }\r\n  return [concepts, readyToGo];\r\n};\r\n\r\nconst areSameDepth = (first: ActionNode, second: ActionNode, count: [number, number]): boolean => {\r\n  const newCount: [number, number] = [\r\n    // Logical Determination: nullActionType\r\n    //  In addition we logically guarantee that action would be set at this point of execution\r\n    (first.lastActionNode?.action as Action).semaphore[3] !== 2 ? count[0] + 1 : count[0],\r\n    (second.lastActionNode?.action as Action).semaphore[3] !== 2 ? count[0] + 1 : count[0]\r\n  ];\r\n  if (count[0] !== newCount[0] && count[1] !== newCount[1] && newCount[0] === newCount[1]) {\r\n    return areSameDepth(first.lastActionNode as ActionNode, second.lastActionNode as ActionNode, newCount);\r\n  } else if (count[0] === newCount[0] && count[1] === newCount[1]) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const areEqual = (first: Action, second: Action ) => {\r\n  let equal = false;\r\n  const firstStrategy = first.strategy;\r\n  const secondStrategy = second.strategy;\r\n  if (firstStrategy === undefined && secondStrategy === undefined) {\r\n    if (areSemaphoresEqual(first, second)) {\r\n      if (first.payload === undefined && second.payload === undefined) {\r\n        equal = true;\r\n      } else {\r\n        equal = JSON.stringify(first.payload) === JSON.stringify(second.payload);\r\n      }\r\n    }\r\n    equal = false;\r\n  } else if (firstStrategy?.topic === secondStrategy?.topic) {\r\n    if (areSemaphoresEqual(first, second)) {\r\n      if (first.payload === undefined && second.payload === undefined) {\r\n        equal = true;\r\n      } else if (JSON.stringify(first.payload) === JSON.stringify(second.payload)) {\r\n        equal = areSameDepth(\r\n          (firstStrategy as ActionStrategy).currentNode,\r\n          (secondStrategy as ActionStrategy).currentNode,\r\n          [0,0]\r\n        );\r\n      }\r\n    }\r\n    equal = false;\r\n  }\r\n  return equal;\r\n};\r\n\r\nexport const updateAddToPendingActions = (_concepts: Concepts, _action: Action) => {\r\n  let concepts = _concepts;\r\n  const action = _action;\r\n  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;\r\n  const pendingActions = ownershipState.pendingActions;\r\n  const newPendingActions: Action[] = [];\r\n  if (pendingActions.length > 0) {\r\n    for (const pending of pendingActions) {\r\n      const equal = areEqual(action, pending);\r\n      if (equal && pending.keyedSelectors && action.keyedSelectors) {\r\n        let editedAction;\r\n        [concepts, editedAction] = editStubs(concepts, pending, action);\r\n        newPendingActions.push(editedAction);\r\n      } else if (equal) {\r\n        newPendingActions.push(action);\r\n      } else {\r\n        newPendingActions.push(pending);\r\n        newPendingActions.push(action);\r\n      }\r\n    }\r\n    ownershipState.pendingActions = [...newPendingActions];\r\n  } else {\r\n    ownershipState.pendingActions = [action];\r\n  }\r\n  return concepts;\r\n};\r\n\r\nexport const ownership = ({\r\n  createOwnershipLedger,\r\n  ownershipShouldBlock,\r\n  clearStubs,\r\n  editStubs,\r\n  checkIn,\r\n  isActionReady,\r\n  areEqual,\r\n  updateAddToPendingActions,\r\n});"},"For the asynchronous graph programming framework Stratimux, define the Principle model file.\r\nThis file allows for user to define Principle Functions, as well as for the axium to initialize those functions\r\nwithin its recursive run time.":{"type":"project","content":"import { Observable, Subscriber, Subscription } from 'rxjs';\r\nimport { Concepts } from './concept';\r\nimport { Action, primeAction } from './action';\r\nimport { axiumRegisterSubscriber } from '../concepts/axium/qualities/registerSubscription.quality';\r\nimport { UnifiedSubject } from './stagePlanner';\r\n\r\nexport type PrincipleFunction = (\r\n  observer: Subscriber<Action>,\r\n  concepts: Concepts,\r\n  concept$: UnifiedSubject,\r\n  semaphore: number,\r\n) => void;\r\n\r\nexport function createPrinciple$(\r\n  principleFunc: PrincipleFunction,\r\n  concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number,\r\n): Observable<Action> {\r\n  return new Observable(function (obs: Subscriber<Action>) {\r\n    principleFunc(obs, concepts, concepts$, semaphore);\r\n  });\r\n}\r\n\r\nexport function registerPrincipleSubscription(observer: Subscriber<Action>, concepts: Concepts, name: string, subscription: Subscription) {\r\n  const primedRegisterSubscriber = primeAction(concepts, axiumRegisterSubscriber({ subscription, name }));\r\n  observer.next(primedRegisterSubscriber);\r\n}\r\n\r\nexport const principle = ({\r\n  createPrinciple$,\r\n  registerPrincipleSubscription\r\n});"},"For the asynchronous graph programming framework Stratimux, define the Quality model file.\r\nThis model allows for qualities to be made at a single point of entry, reducing the complexity of defining such.":{"type":"project","content":"export function createQualitySet(q: {\r\n  type: string,\r\n  reducer: Reducer,\r\n  methodCreator?: MethodCreator,\r\n  keyedSelectors?: KeyedSelector[],\r\n  meta?: Record<string,unknown>,\r\n  analytics?: Record<string,unknown>\r\n}): [ActionCreator, ActionType, Quality] {\r\n  return [\r\n    prepareActionCreator(q.type),\r\n    q.type,\r\n    createQuality(q.type, q.reducer, q.methodCreator, q.keyedSelectors, q.meta, q.analytics)\r\n  ];\r\n}\r\n\r\nexport function createQualitySetWithPayload<T extends Record<string, unknown>>(q: {\r\n  type: string,\r\n  reducer: Reducer,\r\n  methodCreator?: MethodCreator,\r\n  keyedSelectors?: KeyedSelector[],\r\n  meta?: Record<string,unknown>,\r\n  analytics?: Record<string,unknown>\r\n}): [ActionCreatorWithPayload<T>, ActionType, Quality] {\r\n  return [\r\n    prepareActionWithPayloadCreator<T>(q.type),\r\n    q.type,\r\n    createQuality(q.type, q.reducer, q.methodCreator, q.keyedSelectors, q.meta, q.analytics)\r\n  ];\r\n}"},"For the asynchronous graph programming framework Stratimux, define the Selector model file.\r\nThis file will contain a series of selectors that can be used to engage with different parts of the Axium Conceptual Set.":{"type":"project","content":"import { Action } from './action';\r\nimport { Concept, Concepts, createConcept } from './concept';\r\n\r\n/**\r\n * Will have such be a list of state keys separated by spaces until someone yells at me to change this.\r\n */\r\nexport type SelectorFunction = (obj: Record<string, unknown>) => unknown | undefined;\r\nexport type KeyedSelector = {\r\n  conceptName: string,\r\n  conceptSemaphore: number,\r\n  keys: string,\r\n  selector: SelectorFunction,\r\n  setKeys?: (number | string)[]\r\n  setSelector?: SelectorFunction\r\n};\r\n/**\r\n * For usage outside of the Axium, or when subscribed to other Axiums\r\n */\r\nexport const createConceptKeyedSelector =\r\n  <T extends Record<string, unknown>>(conceptName: string, keys: DotPath<T>, setKeys?: (number|string)[]): KeyedSelector => {\r\n    const selectorBase = [conceptName, ...keys.split('.')];\r\n    if (setKeys) {\r\n      return {\r\n        conceptName,\r\n        conceptSemaphore: -1,\r\n        keys: conceptName + '.' + keys,\r\n        selector: creation(selectorBase, selectorBase.length - 1, selectorBase.length) as SelectorFunction,\r\n        setKeys,\r\n        setSelector: setCreation(setKeys, setKeys.length - 1, setKeys.length)\r\n      };\r\n    }\r\n    return {\r\n      conceptName,\r\n      conceptSemaphore: -1,\r\n      keys: conceptName + '.' + keys,\r\n      selector: creation(selectorBase, selectorBase.length - 1, selectorBase.length) as SelectorFunction,\r\n      setKeys\r\n    };\r\n  };\r\n\r\n/**\r\n * This will update a concepts KeyedSelector to its currently unified concept.\r\n * @Note Use this in place of createUnifiedSelector if you find yourself needing to lock deep values.\r\n */\r\nexport const updateUnifiedKeyedSelector =\r\n  (concepts: Concepts, semaphore: number, keyedSelector: KeyedSelector): KeyedSelector | undefined => {\r\n    if (concepts[semaphore]) {\r\n      const selectorBase = keyedSelector.keys.split('.');\r\n      selectorBase[0] = concepts[semaphore].name;\r\n      const selector = creation(selectorBase, selectorBase.length - 1, selectorBase.length) as SelectorFunction;\r\n      if (keyedSelector.setKeys) {\r\n        return {\r\n          conceptName: concepts[semaphore].name,\r\n          conceptSemaphore: semaphore,\r\n          selector,\r\n          keys: selectorBase.join('.'),\r\n          setKeys: keyedSelector.setKeys,\r\n          setSelector: keyedSelector.setSelector\r\n        };\r\n      }\r\n      return {\r\n        conceptName: concepts[semaphore].name,\r\n        conceptSemaphore: semaphore,\r\n        selector,\r\n        keys: selectorBase.join('.')\r\n      };\r\n    } else {\r\n      return undefined;\r\n    }\r\n  };\r\n\r\ntype Key = string | number | symbol;\r\n\r\ntype Join<L extends Key | undefined, R extends Key | undefined> = L extends\r\n  | string\r\n  | number\r\n  ? R extends string | number\r\n    ? `${L}.${R}`\r\n    : L\r\n  : R extends string | number\r\n  ? R\r\n  : undefined;\r\n\r\ntype Union<\r\n  L extends unknown | undefined,\r\n  R extends unknown | undefined\r\n> = L extends undefined\r\n  ? R extends undefined\r\n    ? undefined\r\n    : R\r\n  : R extends undefined\r\n  ? L\r\n  : L | R;\r\n\r\n// Use this type to define object types you want to skip (no path-scanning)\r\ntype ObjectsToIgnore = { new(...parms: any[]): any } | Date | Array<any>\r\n\r\ntype ValidObject<T> =  T extends object\r\n  ? T extends ObjectsToIgnore\r\n    ? false & 1\r\n    : T\r\n  : false & 1;\r\n\r\nexport type DotPath<\r\n  T extends object,\r\n  Prev extends Key | undefined = undefined,\r\n  Path extends Key | undefined = undefined,\r\n  PrevTypes extends object = T\r\n> = string &\r\n  {\r\n    [K in keyof T]:\r\n    // T[K] is a type already checked?\r\n    T[K] extends PrevTypes | T\r\n      //  Return all previous paths.\r\n      ? Union<Union<Prev, Path>, Join<Path, K>>\r\n      : // T[K] is an object?.\r\n      Required<T>[K] extends ValidObject<Required<T>[K]>\r\n      ? // Continue extracting\r\n        DotPath<Required<T>[K], Union<Prev, Path>, Join<Path, K>, PrevTypes | T>\r\n      :  // Return all previous paths, including current key.\r\n      Union<Union<Prev, Path>, Join<Path, K>>;\r\n  }[keyof T];\r\n/**\r\n * Will create a new KeyedSelector during runtime, for usage within your principles.\r\n * @Note Will want to expand this later, so that we can select into objects and arrays.\r\n *  This would allow us to lock parts of such in later revisions, not an immediate concern.\r\n */\r\nexport const createUnifiedKeyedSelector = <T extends object>(\r\n  concepts: Concepts,\r\n  semaphore: number,\r\n  keys: DotPath<T>,\r\n  setKeys?: (number | string)[]\r\n): KeyedSelector | undefined => {\r\n  const concept = concepts[semaphore];\r\n  try {\r\n    if (concept) {\r\n      const selectorBase = [concept.name, ...keys.split('.')];\r\n      if (setKeys) {\r\n        return {\r\n          conceptName: concept.name,\r\n          conceptSemaphore: semaphore,\r\n          selector: creation(selectorBase, selectorBase.length - 1, selectorBase.length) as SelectorFunction,\r\n          keys: concept.name + '.' + keys,\r\n          setKeys,\r\n          setSelector: setCreation(setKeys, setKeys.length - 1, setKeys.length)\r\n        };\r\n      }\r\n      return {\r\n        conceptName: concept.name,\r\n        conceptSemaphore: semaphore,\r\n        selector: creation(selectorBase, selectorBase.length - 1, selectorBase.length) as SelectorFunction,\r\n        keys: concept.name + '.' + keys,\r\n      };\r\n    }\r\n  } catch (err) {\r\n    console.error(err);\r\n    console.warn('ERROR AT: ', keys);\r\n  }\r\n  return undefined;\r\n};\r\n\r\nconst recordReturn = (key: string, previous: SelectorFunction) => {\r\n  return (obj: Record<string, unknown>) => {\r\n    if (obj[key] !== undefined) {\r\n      return previous(obj[key] as Record<string, unknown>);\r\n    } else {\r\n      return undefined;\r\n    }\r\n  };\r\n};\r\nconst finalReturn = (key: string) => {\r\n  return (obj: Record<string, unknown>) => {\r\n    if (obj[key] !== undefined) {\r\n      return obj[key];\r\n    } else {\r\n      return undefined;\r\n    }\r\n  };\r\n};\r\nconst tupleReturn = (key: string | number, previous: SelectorFunction) => {\r\n  return (obj: Record<string | number, unknown>) => {\r\n    if (obj[key] !== undefined) {\r\n      const previousSet = previous(obj);\r\n      if (previousSet) {\r\n        return [obj[key], ...previous(obj) as unknown[]];\r\n      }\r\n      return [obj[key]];\r\n    } else {\r\n      return undefined;\r\n    }\r\n  };\r\n};\r\nconst finalTupleReturn = (key: string | number) => {\r\n  return (obj: Record<string | number, unknown>) => {\r\n    if (obj[key] !== undefined) {\r\n      return [obj[key]];\r\n    } else {\r\n      return undefined;\r\n    }\r\n  };\r\n};\r\n\r\nconst creation = (keys: string[], index: number, length: number, prev?: SelectorFunction | undefined): SelectorFunction | undefined => {\r\n  let previous: SelectorFunction | undefined = prev;\r\n  let i = index;\r\n  if (index === length - 1) {\r\n    previous = finalReturn(keys[i]);\r\n    i--;\r\n  }\r\n  if (i !== 0 && previous) {\r\n    previous = recordReturn(keys[i], previous);\r\n    return creation(keys, i - 1, length, previous);\r\n  } else if (previous) {\r\n    return previous;\r\n  } else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nconst setCreation =\r\n  (keys: (string | number)[], index: number, length: number, prev?: SelectorFunction | undefined): SelectorFunction | undefined => {\r\n    let previous: SelectorFunction | undefined = prev;\r\n    let i = index;\r\n    if (index === length - 1) {\r\n      previous = finalTupleReturn(keys[i]);\r\n      i--;\r\n    }\r\n    if (i !== -1 && previous) {\r\n      previous = tupleReturn(keys[i], previous);\r\n      return setCreation(keys, i - 1, length, previous);\r\n    } else if (previous) {\r\n      return previous;\r\n    } else {\r\n      return undefined;\r\n    }\r\n  };\r\n\r\n// Temporary until there is a better means to create this form of deep selection\r\n//  As already I am having to go off script for specific array indexes, despite being able to assemble the logic\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport const assembleDynamicSelection = (selection: unknown[]): any => {\r\n  return selection.join('.');\r\n};\r\n\r\nexport function selectState<T>(concepts: Concepts, name: string): T | undefined {\r\n  const conceptKeys = Object.keys(concepts).map(key => Number(key));\r\n  const length = conceptKeys.length;\r\n  const select = (index: number): T | undefined => {\r\n    if (concepts[conceptKeys[index]].name === name) {\r\n      return concepts[index].state as T;\r\n    } else if (index < length - 1) {\r\n      return select(index + 1);\r\n    } else {\r\n      return undefined;\r\n    }\r\n  };\r\n  return select(0);\r\n}\r\n\r\n/**\r\n * Simple helper function that returns payload casted to T.\r\n */\r\nexport function selectPayload<T>(action: Action): T {\r\n  return action.payload as T;\r\n}\r\n\r\n// Note: The Concept Key within the selector has to be set Explicitly for now\r\nexport function selectSlice<T>(\r\n  concepts: Concepts,\r\n  keyed: KeyedSelector): T | undefined {\r\n  const concept: Concept | undefined = (() => {\r\n    if (keyed.conceptSemaphore === -1) {\r\n      const name = keyed.conceptName;\r\n      const conceptKeys = Object.keys(concepts);\r\n      const length = conceptKeys.length;\r\n      const select = (index: number): Concept | undefined => {\r\n        const i = Number(conceptKeys[index]);\r\n        const possible = concepts[i];\r\n        if (possible && possible.name === name) {\r\n          return concepts[i];\r\n        } else if (index < length) {\r\n          return select(index + 1);\r\n        } else {\r\n          return undefined;\r\n        }\r\n      };\r\n      return select(0);\r\n    } else {\r\n      return concepts[keyed.conceptSemaphore];\r\n    }\r\n  })();\r\n  if (concept === undefined) {return undefined;}\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  const cast = concept.state as Record<string, any>;\r\n  return keyed.selector(cast) as T | undefined;\r\n}\r\n\r\nexport function selectSet<T>(concepts: Concepts, keyed: KeyedSelector): T | undefined {\r\n  const state: T | undefined = selectSlice<T>(concepts, keyed);\r\n  if (keyed.setSelector) {\r\n    return (keyed.setSelector(state as Record<string | number, unknown>)) as T;\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function selectConcept(concepts: Concepts, name: string): Concept | undefined {\r\n  const conceptKeys = Object.keys(concepts);\r\n  const length = conceptKeys.length;\r\n  const select = (index: number): Concept | undefined => {\r\n    const i = Number(conceptKeys[index]);\r\n    if (concepts[i] && concepts[i].name === name) {\r\n      return concepts[i];\r\n    } else if (index < length) {\r\n      return select(index + 1);\r\n    } else {\r\n      return undefined;\r\n    }\r\n  };\r\n  return select(0);\r\n}\r\n\r\n/**\r\n * Advanced functionality, set a custom key path that may include array indexes.\r\n * @example createAdvancedKeys('some', 1, 'once', 2, 'me', 7, 'world', 4) : some.1.once.2.m.7.world.4\r\n * @param arr a series of keys that points to your targeted slice\r\n * @returns DotPath<T extends object>\r\n */\r\nexport function createAdvancedKeys<T extends object>(arr: unknown[]): DotPath<T> {\r\n  return arr.join('.') as DotPath<T>;\r\n}\r\n\r\ncreateConceptKeyedSelector<{something: unknown}>('something', 'something.1' as DotPath<{something:unknown}>);\r\n/**\r\n * Allows for the Unification of Concepts and a form of Data Oriented Functional Inheritance.\r\n * @within_principles Simply pass the supplied semaphore passed to your PrincipleFunction to gain access to that State.\r\n * @outside_selection Use selectState targeting that Unified Concept Name\r\n */\r\n\r\n// Either returns the current concept's unified state, or informs that the concept has been removed and the principles needs shutdown\r\nexport function selectUnifiedState<T>(concepts: Concepts, semaphore: number): T | undefined {\r\n  if (concepts[semaphore]) {\r\n    return concepts[semaphore].state as T;\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\nexport const select = ({\r\n  createUnifiedKeyedSelector,\r\n  createConceptKeyedSelector,\r\n  createAdvancedKeys,\r\n  updateUnifiedKeyedSelector,\r\n  state: selectState,\r\n  set: selectSet,\r\n  payLoad: selectPayload,\r\n  slice: selectSlice,\r\n  concept: selectConcept,\r\n  unifiedState: selectUnifiedState,\r\n});"},"For the asynchronous graph programming framework Stratimux, define the Stage Planner model file.\r\nThis file introduces the Unified Subject, that allows for users to stage plans based on observation of the Concepts stream.\r\nThe Stage Planner paradigm is what allows for the ease of working within a recursive run time, via setting plans to specific stages\r\nin order to prevent action overflow. Action overflow is when a function is stuck within a recursive loop. This paradigm\r\nalso ensures Stratimux of its own provable termination in majority of configurations.":{"type":"project","content":"/* eslint-disable complexity */\r\nimport { Subject } from 'rxjs';\r\nimport { Concepts } from './concept';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { KeyedSelector, createConceptKeyedSelector, select, selectSlice } from './selector';\r\nimport { Action, ActionType } from './action';\r\nimport { axiumSelectOpen } from '../concepts/axium/axium.selector';\r\nimport { ownershipSelectInitialized } from '../concepts/ownership/ownership.selector';\r\nimport { getAxiumState, isAxiumOpen } from './axium';\r\nimport { initializeTopic } from '../concepts/axium/strategies/initialization.strategy';\r\nimport { ownershipSetOwnerShipModeTopic } from '../concepts/ownership/strategies/setOwnerShipMode.strategy';\r\n\r\nexport type Plan = {\r\n  id: number;\r\n  space: number;\r\n  title: string;\r\n  stages: Staging[],\r\n  stage: number;\r\n  stageFailed: number;\r\n  beat: number;\r\n  offBeat: number;\r\n  timer: NodeJS.Timeout[];\r\n  changeAggregator: Record<string, KeyedSelector>;\r\n}\r\n\r\nexport type Stage = (\r\n  concepts: Concepts,\r\n  dispatch: (action: Action, options: dispatchOptions, ) => void,\r\n  changes?: KeyedSelector[]\r\n) => void;\r\n\r\nexport type Staging = {\r\n  stage: Stage;\r\n  selectors: KeyedSelector[];\r\n  firstRun: boolean;\r\n  priority?: number\r\n  beat?: number,\r\n};\r\n\r\nexport type PartialStaging = {\r\n  stage: Stage;\r\n  selectors?: KeyedSelector[];\r\n  priority?: number\r\n  beat?: number,\r\n};\r\n\r\nexport type StagePlanner = {\r\n  title: string;\r\n  planId: number;\r\n  conclude: () => void;\r\n}\r\n\r\nexport type NamedStagePlanner = {\r\n  name: string;\r\n  title: string;\r\n  planId: number;\r\n  conclude: () => void;\r\n}\r\n\r\nexport type dispatchOptions = {\r\n  runOnce?: boolean;\r\n  throttle?: number;\r\n  iterateStage?: boolean;\r\n  setStage?: number;\r\n  setStageSelectors?: {\r\n    stage: number,\r\n    selectors: KeyedSelector[]\r\n  };\r\n  setStagePriority?: {\r\n    stage: number,\r\n    priority: number\r\n  };\r\n  setStageBeat?: {\r\n    stage: number,\r\n    beat: number\r\n  };\r\n  newSelectors?: KeyedSelector[];\r\n  newPriority?: number;\r\n  newBeat?: number;\r\n}\r\n\r\nexport type Dispatcher = (action: Action, options: dispatchOptions) => void;\r\n\r\nexport type StageDelimiter = {\r\n  stage: number,\r\n  prevActions: ActionType[],\r\n  unionExpiration: number[];\r\n  runOnceMap: Map<string, boolean>\r\n}\r\n\r\n/**\r\n * Used in principle plans that are loaded during axium initialization\r\n */\r\nexport const stageWaitForOpenThenIterate = (func: () => Action): Staging => (createStage((concepts: Concepts, dispatch: Dispatcher) => {\r\n  if (isAxiumOpen(concepts) && getAxiumState(concepts).lastStrategy === initializeTopic) {\r\n    dispatch(func(), {\r\n      iterateStage: true\r\n    });\r\n  }\r\n}, { selectors: [axiumSelectOpen] }));\r\n\r\nexport const stageWaitForOwnershipThenIterate =\r\n  (func: () => Action): Staging => (createStage((concepts: Concepts, dispatch: Dispatcher) => {\r\n    if (selectSlice(concepts, ownershipSelectInitialized) && getAxiumState(concepts).lastStrategy === ownershipSetOwnerShipModeTopic) {\r\n      dispatch(func(), {\r\n        iterateStage: true\r\n      });\r\n    }\r\n  }, { selectors: [ownershipSelectInitialized] }));\r\n\r\n/**\r\n * Helper function to aid readability of composing plans, otherwise you may directly create a Staging Entity, selectors non optional\r\n * @param stage - (concepts, dispatch) => {}\r\n * @param selectors - Array of observed dependencies to execute your stage\r\n * @param priority - Adding this property will change the order in which your plan is notified on each state change\r\n * @param beat - Will fire once, then if informed again within your supplied beat, will fire after such time\r\n * @returns stage: Stage, selectors: KeyedSelector[], priority?: number, beat?: number\r\n */\r\nexport const createStage = (stage: Stage, options?: { selectors?: KeyedSelector[], priority?: number, beat?: number}): Staging => {\r\n  if (options) {\r\n    return {\r\n      stage,\r\n      selectors: options.selectors ? options.selectors : [],\r\n      firstRun: true,\r\n      priority: options.priority,\r\n      beat: options.beat\r\n    };\r\n  } else {\r\n    return {\r\n      stage,\r\n      firstRun: true,\r\n      selectors: []\r\n    };\r\n  }\r\n};\r\n\r\n// Token to denote ALL, using a selector that utilizes this token should return undefined\r\nconst ALL = '*4||*';\r\n\r\nconst handleRun =\r\n  (stageDelimiter: StageDelimiter, plan: Plan, action: Action, options?: dispatchOptions)\r\n    : [StageDelimiter, boolean] => {\r\n    if (options?.runOnce) {\r\n      const stageRunner = stageDelimiter.runOnceMap.get(action.type + plan.stage);\r\n      if (stageRunner === undefined) {\r\n        stageDelimiter.runOnceMap.set(action.type + plan.stage, true);\r\n        return [\r\n          stageDelimiter, true\r\n        ];\r\n      } else {\r\n        stageDelimiter.runOnceMap.set(action.type + plan.stage, false);\r\n        return [\r\n          stageDelimiter, false\r\n        ];\r\n      }\r\n    }\r\n    return [\r\n      stageDelimiter,\r\n      true\r\n    ];\r\n  };\r\n\r\nconst handleStageDelimiter =\r\n  (plan: Plan, action: Action, delimiter?: StageDelimiter, options?: dispatchOptions): [StageDelimiter, boolean] => {\r\n    let stageDelimiter = delimiter;\r\n    let goodAction = true;\r\n    if (stageDelimiter &&\r\n        stageDelimiter.prevActions.includes(action.type) &&\r\n        options?.throttle === undefined) {\r\n      if (plan.stage !== stageDelimiter?.stage) {\r\n        stageDelimiter = {\r\n          stage: plan.stage,\r\n          prevActions: [action.type],\r\n          unionExpiration: [action.expiration],\r\n          runOnceMap: new Map()\r\n        };\r\n      } else {\r\n        goodAction = false;\r\n      }\r\n    } else if (stageDelimiter) {\r\n      if (stageDelimiter.prevActions.length > 4) {\r\n        stageDelimiter = {\r\n          stage: plan.stage,\r\n          prevActions: [\r\n            stageDelimiter.prevActions[1],\r\n            stageDelimiter.prevActions[2],\r\n            stageDelimiter.prevActions[3],\r\n            stageDelimiter.prevActions[4],\r\n            action.type\r\n          ],\r\n          unionExpiration: [\r\n            stageDelimiter.unionExpiration[1],\r\n            stageDelimiter.unionExpiration[2],\r\n            stageDelimiter.unionExpiration[3],\r\n            stageDelimiter.unionExpiration[4],\r\n            action.expiration\r\n          ],\r\n          runOnceMap: new Map()\r\n        };\r\n      } else {\r\n        stageDelimiter = {\r\n          stage: plan.stage,\r\n          prevActions: [...stageDelimiter.prevActions, action.type],\r\n          unionExpiration: [...stageDelimiter.unionExpiration, action.expiration],\r\n          runOnceMap: new Map()\r\n        };\r\n      }\r\n    } else {\r\n      stageDelimiter = {\r\n        stage: plan.stage,\r\n        prevActions: [action.type],\r\n        unionExpiration: [action.expiration],\r\n        runOnceMap: new Map()\r\n      };\r\n    }\r\n    return [\r\n      stageDelimiter,\r\n      goodAction\r\n    ];\r\n  };\r\n\r\nconst Inner = 0;\r\nconst Base = 1;\r\nconst Outer = 2;\r\n\r\nexport class UnifiedSubject extends Subject<Concepts> {\r\n  private planId = -1;\r\n  private currentPlans: Map<number, Plan> = new Map();\r\n  private stageDelimiters: Map<number, StageDelimiter> = new Map();\r\n  private concepts: Concepts = {};\r\n  // Assemble front of line\r\n  private priorityQue: {planID: number, priority: number, stage: number, selectors: KeyedSelector[]}[] = [];\r\n  private priorityExists: Map<string, boolean> = new Map();\r\n  private frequencyMap: Map<string, number> = new Map();\r\n  private selectors: Map<string, {selector: KeyedSelector, ids: number[]}> = new Map();\r\n  // Assemble back of line, exempts priority que members\r\n  private ques: {\r\n    priorityQue: {planID: number, priority: number, stage: number, selectors: KeyedSelector[]}[],\r\n    generalQue: number[],\r\n  }[] = [{generalQue: [], priorityQue: []}, {generalQue: [], priorityQue: []}, {generalQue: [], priorityQue: []}];\r\n  // private generalQue: number[] = [];\r\n  // [TODO Unify Streams]: Simplify streams into one single UnifiedSubject\r\n  // [Experiment notes]: When attempting to unify all streams the chain test presented a ghost count repeating at 14 with both 0 and 2\r\n  // [Punt]: The main issue with this simplification is the order in which withLatest is notified\r\n  // In order to fully facilitate this change we would need to add an innerQue, but likewise can just have 3 streams\r\n  // private outerQue: number[] = [];\r\n  // The above approach is enhanced by a onChange dict\r\n  constructor() {\r\n    super();\r\n    this.planId = 0;\r\n  }\r\n\r\n  protected createPriorityKey(planId: number, stage: number) {\r\n    return `${planId}${stage}`;\r\n  }\r\n\r\n  protected handleAddSelector(selectors: KeyedSelector[], id: number) {\r\n    if (selectors.length === 0) {\r\n      const ALL_SELECTOR = select.createConceptKeyedSelector(ALL, ALL);\r\n      this.addSelector(ALL_SELECTOR, id);\r\n    }\r\n    selectors.forEach(selector => this.addSelector(selector, id));\r\n  }\r\n\r\n  protected handleNewStageOptions = (plan: Plan, options: dispatchOptions, next: number): boolean => {\r\n    let evaluate = false;\r\n    if (options.newPriority) {\r\n      plan.stages[plan.stage].priority = options.newPriority;\r\n      evaluate = true;\r\n    }\r\n    if (options.newSelectors) {\r\n      this.handleRemoveSelector(plan.stages[plan.stage].selectors, plan.id);\r\n      plan.stages[plan.stage].selectors = options.newSelectors;\r\n      this.handleAddSelector(plan.stages[plan.stage].selectors, plan.id);\r\n      evaluate = true;\r\n    }\r\n    if (options.newBeat) {\r\n      plan.stages[plan.stage].beat = options.newBeat;\r\n      if (next === -1) {\r\n        plan.beat = options.newBeat;\r\n      }\r\n      evaluate = true;\r\n    }\r\n    return evaluate;\r\n  };\r\n\r\n  protected handleSetStageOptions = (plan: Plan, options: dispatchOptions) => {\r\n    if (options.setStageSelectors && plan.stages[options.setStageSelectors.stage]) {\r\n      plan.stages[options.setStageSelectors.stage].selectors = options.setStageSelectors.selectors;\r\n    }\r\n    if (options.setStagePriority && plan.stages[options.setStagePriority.stage]) {\r\n      plan.stages[options.setStagePriority.stage].priority = options.setStagePriority.priority;\r\n    }\r\n    if (options.setStageBeat && plan.stages[options.setStageBeat.stage]) {\r\n      plan.stages[options.setStageBeat.stage].beat = options.setStageBeat.beat;\r\n    }\r\n  };\r\n\r\n  protected addSelector(selector: KeyedSelector, id: number) {\r\n    const s = this.selectors.get(selector.keys);\r\n    if (s) {\r\n      this.selectors.set(selector.keys, {selector, ids: [...s.ids, id]});\r\n    } else {\r\n      this.selectors.set(selector.keys, {selector, ids: [id]});\r\n    }\r\n  }\r\n\r\n  protected handleRemoveSelector(selectors: KeyedSelector[], id: number) {\r\n    if (selectors.length === 0) {\r\n      const ALL_SELECTOR = select.createConceptKeyedSelector(ALL, ALL);\r\n      this.removeSelector(ALL_SELECTOR, id);\r\n    }\r\n    selectors.forEach(selector => this.removeSelector(selector, id));\r\n  }\r\n\r\n  protected removeSelector(selector: KeyedSelector, id: number) {\r\n    const s = this.selectors.get(selector.keys);\r\n    if (s) {\r\n      if (s.ids.length - 1 === 0) {\r\n        this.selectors.delete(selector.keys);\r\n      } else {\r\n        this.selectors.set(selector.keys, {selector, ids: s.ids.filter(idx => idx !== id)});\r\n      }\r\n    }\r\n  }\r\n\r\n  protected createPlan(title: string, stages: PartialStaging[], space: number): Plan {\r\n    const planId = this.planId;\r\n    this.planId += 1;\r\n    const staged: Staging[] = stages.map<Staging>(s => {\r\n      return {\r\n        stage: s.stage,\r\n        selectors: s.selectors ? s.selectors : [],\r\n        firstRun: true,\r\n        priority: s.priority,\r\n        beat: s.beat\r\n      };\r\n    });\r\n    const beat = staged[0].beat;\r\n    return {\r\n      id: planId,\r\n      space,\r\n      title,\r\n      stages: staged,\r\n      stage: 0,\r\n      stageFailed: -1,\r\n      beat: beat ? beat : -1,\r\n      offBeat: -1,\r\n      timer: [],\r\n      changeAggregator: {}\r\n    };\r\n  }\r\n\r\n  protected initPlan(plan: Plan): StagePlanner {\r\n    this.currentPlans.set(plan.id, plan);\r\n    this.handleAddSelector(plan.stages[plan.stage].selectors, plan.id);\r\n    this.manageQues();\r\n    const conclude = () => {\r\n      this.deletePlan(plan.id);\r\n    };\r\n    return {\r\n      title: plan.title,\r\n      planId: plan.id,\r\n      conclude: conclude.bind(this)\r\n    };\r\n  }\r\n\r\n  // [TODO Unify Streams]\r\n  innerPlan(title: string, stages: PartialStaging[]) {\r\n    return this.initPlan(this.createPlan(title, stages, Inner));\r\n  }\r\n\r\n  outerPlan(title: string, stages: PartialStaging[]) {\r\n    return this.initPlan(this.createPlan(title, stages, Outer));\r\n  }\r\n\r\n  plan(title: string, stages: Staging[]): StagePlanner {\r\n    return this.initPlan(this.createPlan(title, stages, Base));\r\n  }\r\n\r\n  protected deletePlan(planId: number) {\r\n    const plan = this.currentPlans.get(planId);\r\n    if (plan) {\r\n      this.currentPlans.delete(planId);\r\n      const selectors = plan.stages[plan.stage]?.selectors;\r\n      if (selectors) {\r\n        this.handleRemoveSelector(selectors, plan.id);\r\n      }\r\n      this.manageQues();\r\n    }\r\n    return plan;\r\n  }\r\n\r\n  protected updateFrequencyMap() {\r\n    const que = this.priorityQue;\r\n    const map: typeof this.frequencyMap = new Map();\r\n\r\n    que.forEach(plan => {\r\n      plan.selectors.forEach(selector => {\r\n        const frequency = map.get(selector.keys);\r\n        if (frequency) {\r\n          map.set(selector.keys, frequency + plan.priority);\r\n        } else {\r\n          map.set(selector.keys, plan.priority);\r\n        }\r\n      });\r\n    });\r\n\r\n    this.frequencyMap = map;\r\n  }\r\n\r\n  protected assemblePriorityQue() {\r\n    let prioritize = false;\r\n    const priorityMap: typeof this.priorityExists = new Map();\r\n    const newList: {\r\n      inner: {planID: number, priority: number, stage: number, selectors: KeyedSelector[]}[],\r\n      base: {planID: number, priority: number, stage: number, selectors: KeyedSelector[]}[],\r\n      outer: {planID: number, priority: number, stage: number, selectors: KeyedSelector[]}[]\r\n    } = {\r\n      inner: [],\r\n      base: [],\r\n      outer: []\r\n    };\r\n    for (const [_, plan] of this.currentPlans) {\r\n      const stage = plan.stages[plan.stage];\r\n      const priority = stage.priority;\r\n      if (priority) {\r\n        prioritize = true;\r\n        const key = this.createPriorityKey(plan.id, plan.stage);\r\n        const selectors = plan.stages[plan.stage].selectors;\r\n        priorityMap.set(key, true);\r\n        const entry = {\r\n          planID: plan.id,\r\n          priority,\r\n          stage: plan.stage,\r\n          selectors,\r\n        };\r\n        switch (plan.space) {\r\n        case Inner: {\r\n          newList.inner.push(entry);\r\n          break;\r\n        }\r\n        case Base: {\r\n          newList.base.push(entry);\r\n          break;\r\n        }\r\n        case Outer: {\r\n          newList.outer.push(entry);\r\n          break;\r\n        }\r\n        default: {\r\n          //\r\n        }\r\n        }\r\n        this.priorityExists.set(key, true);\r\n      }\r\n    }\r\n    if (!prioritize) {\r\n      this.ques[Inner].priorityQue = [];\r\n      this.ques[Base].priorityQue = [];\r\n      this.ques[Outer].priorityQue = [];\r\n    } else {\r\n      this.ques[Inner].priorityQue = newList.inner.sort((a, b) => b.priority - a.priority);\r\n      this.ques[Base].priorityQue = newList.base.sort((a, b) => b.priority - a.priority);\r\n      this.ques[Outer].priorityQue = newList.outer.sort((a, b) => b.priority - a.priority);\r\n    }\r\n    // This will cause an issue\r\n    this.priorityExists = priorityMap;\r\n    this.updateFrequencyMap();\r\n  }\r\n\r\n  protected assembleGeneralQues() {\r\n    const generalMap: {\r\n      inner: Map<string, {selector: KeyedSelector, planIDs: number[], priorityAggregate: number}>\r\n      base: Map<string, {selector: KeyedSelector, planIDs: number[], priorityAggregate: number}>\r\n      outer: Map<string, {selector: KeyedSelector, planIDs: number[], priorityAggregate: number}>\r\n    } = {\r\n      inner: new Map(),\r\n      base: new Map(),\r\n      outer: new Map()\r\n    };\r\n    for (const [_, plan] of this.currentPlans) {\r\n      // let map = generalMap;\r\n      const stage = plan.stages[plan.stage];\r\n      const priority = stage.priority;\r\n      let target = generalMap.inner;\r\n      switch (plan.space) {\r\n      case Base: {\r\n        target = generalMap.base;\r\n        break;\r\n      }\r\n      case Outer: {\r\n        target = generalMap.outer;\r\n        break;\r\n      }\r\n      default: {\r\n        //\r\n      }\r\n      }\r\n      if (priority === undefined) {\r\n        const prepareMap = (selector: KeyedSelector) => {\r\n          const entry = target.get(selector.keys);\r\n          const frequency = this.frequencyMap.get(selector.keys);\r\n          if (entry) {\r\n            entry.planIDs.push(plan.id);\r\n          } else if (frequency) {\r\n            target.set(selector.keys, {\r\n              planIDs: [plan.id],\r\n              priorityAggregate: frequency,\r\n              selector: selector\r\n            });\r\n          } else {\r\n            target.set(selector.keys, {\r\n              planIDs: [plan.id],\r\n              priorityAggregate: 0,\r\n              selector: selector\r\n            });\r\n          }\r\n        };\r\n        if (stage.selectors.length === 0) {\r\n          prepareMap(createConceptKeyedSelector(ALL, ALL));\r\n        } else {\r\n          for (const selector of stage.selectors) {\r\n            prepareMap(selector);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    const generalIdMap: {\r\n      inner: Map<number, number>\r\n      base: Map<number, number>\r\n      outer: Map<number, number>\r\n    } = {\r\n      inner: new Map(),\r\n      base: new Map(),\r\n      outer: new Map()\r\n    };\r\n    const handleSlice = (slice: {selector: KeyedSelector, planIDs: number[], priorityAggregate: number}, map: Map<number, number>) => {\r\n      slice.planIDs.forEach(id => {\r\n        const priority = map.get(id);\r\n        if (priority) {\r\n          map.set(id, priority + slice.priorityAggregate);\r\n        } else {\r\n          map.set(id, slice.priorityAggregate);\r\n        }\r\n      });\r\n    };\r\n    generalMap.inner.forEach((slice) => {\r\n      handleSlice(slice, generalIdMap.inner);\r\n    });\r\n    generalMap.base.forEach((slice) => {\r\n      handleSlice(slice, generalIdMap.base);\r\n    });\r\n    generalMap.outer.forEach((slice) => {\r\n      handleSlice(slice, generalIdMap.outer);\r\n    });\r\n    const flatten = (map: Map<number, number>) => {\r\n      const flat = [];\r\n      for (const [id, frequency] of map.entries()) {\r\n        flat.push([id, frequency]);\r\n      }\r\n      flat.sort((a, b) => b[1] - a[1]);\r\n      // We should add a selector union\r\n      return flat.map(([id, _]) => id);\r\n    };\r\n    this.ques[Inner].generalQue = flatten(generalIdMap.inner);\r\n    this.ques[Base].generalQue = flatten(generalIdMap.base);\r\n    this.ques[Outer].generalQue = flatten(generalIdMap.outer);\r\n  }\r\n\r\n  protected manageQues() {\r\n    this.assemblePriorityQue();\r\n    this.assembleGeneralQues();\r\n  }\r\n\r\n  protected _dispatch(\r\n    axiumState: AxiumState,\r\n    plan: Plan,\r\n    action: Action,\r\n    options: dispatchOptions): void {\r\n    let stageDelimiter = this.stageDelimiters.get(plan.id);\r\n    let throttle = false;\r\n    let goodAction = true;\r\n    let run = true;\r\n    [stageDelimiter, goodAction] = handleStageDelimiter(plan, action, stageDelimiter, options);\r\n    [stageDelimiter, run] = handleRun(stageDelimiter, plan, action, options);\r\n    this.stageDelimiters.set(plan.id, stageDelimiter);\r\n    if (goodAction && run) {\r\n      const action$ = axiumState.action$ as Subject<Action>;\r\n      if (options?.throttle !== undefined) {\r\n        let previousExpiration = 0;\r\n        for (let i = 0; i < stageDelimiter.prevActions.length; i++) {\r\n          if (stageDelimiter.prevActions[i] === action.type) {\r\n            previousExpiration = stageDelimiter.unionExpiration[i];\r\n            break;\r\n          }\r\n        }\r\n        if (previousExpiration !== action.expiration && action.expiration - previousExpiration < options?.throttle) {\r\n          throttle = true;\r\n        } else {\r\n          for (let i = 0; i < stageDelimiter.prevActions.length; i++) {\r\n            if (stageDelimiter.prevActions[i] === action.type) {\r\n              stageDelimiter.unionExpiration[i] = action.expiration;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      this.stageDelimiters.set(plan.id, stageDelimiter);\r\n      if (!throttle && run) {\r\n        let next = -1;\r\n        const evaluate = this.handleNewStageOptions(plan, options, next);\r\n        this.handleSetStageOptions(plan, options);\r\n        if (options?.iterateStage) {\r\n          next = plan.stage + 1;\r\n          // this.updatePlanSelector(plan, plan.stage, next < plan.stages.length ? next : undefined);\r\n        }\r\n        if (options?.setStage !== undefined) {\r\n          next = options.setStage;\r\n        }\r\n        if (next !== -1) {\r\n          // Don't like having to do this.\r\n          // Double check this logic while writing the unit test.\r\n          if (plan.stages[plan.stage]) {\r\n            this.handleRemoveSelector(plan.stages[plan.stage].selectors, plan.id);\r\n          }\r\n          plan.stage = next;\r\n          if (plan.stages[plan.stage]) {\r\n            this.handleAddSelector(plan.stages[plan.stage].selectors, plan.id);\r\n          }\r\n          this.manageQues();\r\n          const beat = plan.stages[plan.stage].beat;\r\n          plan.beat = beat !== undefined ? beat : -1;\r\n          stageDelimiter.prevActions = [];\r\n          stageDelimiter.unionExpiration = [];\r\n          stageDelimiter.runOnceMap = new Map();\r\n          plan.changeAggregator = {};\r\n          this.stageDelimiters.set(plan.id, stageDelimiter);\r\n        }\r\n        if (evaluate && next === -1) {\r\n          this.manageQues();\r\n        }\r\n        // Horrifying\r\n        // Keep in place, this prevents branch prediction from creating ghost actions if there is an action overflow.\r\n        if (plan.stageFailed === -1) {\r\n          action$.next(action);\r\n        }\r\n      }\r\n    } else if (\r\n      options?.runOnce === undefined &&\r\n      (!options.throttle && (options.iterateStage === undefined || options.setStage === plan.stage))\r\n    ) {\r\n      plan.stageFailed = plan.stage;\r\n      plan.stage = plan.stages.length;\r\n      console.error('DELETED PLAN: ', plan.id);\r\n      const deleted = this.deletePlan(plan.id);\r\n      if (deleted) {\r\n        axiumState.badPlans.push(plan);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected execute(plan: Plan, index: number, changes: KeyedSelector[]): void {\r\n    const axiumState = getAxiumState(this.concepts);\r\n    const dispatcher: Dispatcher = (() => (action: Action, options: dispatchOptions) => {\r\n      this._dispatch(axiumState, plan, action, options);\r\n    }).bind(this)();\r\n    plan.stages[index].stage(this.concepts, dispatcher, changes);\r\n  }\r\n\r\n  protected nextPlans() {\r\n    this.currentPlans.forEach(plan => {\r\n      this.nextPlan(plan, []);\r\n    });\r\n  }\r\n\r\n  protected nextPlan(plan: Plan, changes: KeyedSelector[]) {\r\n    const index = plan.stage;\r\n    if (index < plan.stages.length) {\r\n      if (plan.beat > -1) {\r\n        const timer = plan.timer;\r\n        const now = Date.now();\r\n        if (plan.offBeat < now) {\r\n          plan.offBeat = Date.now() + plan.beat;\r\n          this.execute(plan, index, changes);\r\n        } else if (timer.length === 0 && plan.offBeat > now) {\r\n          // Logic to push changes into aggregator\r\n          changes.forEach(key => {\r\n            plan.changeAggregator[key.keys] = key;\r\n          });\r\n          timer.push(setTimeout(() => {\r\n            const changeAggregation = Object.keys(plan.changeAggregator).map(k => plan.changeAggregator[k]);\r\n            plan.changeAggregator = {};\r\n            plan.timer = [];\r\n            plan.offBeat = Date.now() + plan.beat;\r\n            this.execute(plan, index, changeAggregation);\r\n          }, plan.offBeat - Date.now()));\r\n        } else {\r\n          changes.forEach(key => {\r\n            plan.changeAggregator[key.keys] = key;\r\n          });\r\n        }\r\n      } else {\r\n        this.execute(plan, index, changes);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected nextSubs() {\r\n    const {observers} = this;\r\n    const len = observers.length;\r\n    const nextSub = (index: number) => {\r\n      if (observers[index]) {\r\n        observers[index].next(this.concepts);\r\n      }\r\n      if (index < len - 1) {\r\n        nextSub(index + 1);\r\n      }\r\n    };\r\n    nextSub(0);\r\n  }\r\n\r\n  protected handleChange(concepts: Concepts, blocking = false) {\r\n    const oldConcepts = this.concepts;\r\n    this.concepts = concepts;\r\n    const notifyIds: Map<number, KeyedSelector[]> = new Map();\r\n    for (const [_, slice] of this.selectors) {\r\n      const {selector, ids} = slice;\r\n      let notify = false;\r\n      if (slice.selector.conceptName === ALL) {\r\n        notify = true;\r\n      } else {\r\n        const incoming = select.slice(this.concepts, selector);\r\n        const original = select.slice(oldConcepts, selector);\r\n        if (typeof incoming === 'object' && !Object.is(incoming, original)) {\r\n          // stuff\r\n          notify = true;\r\n        } else if (incoming !== original) {\r\n          notify = true;\r\n        }\r\n      }\r\n      if (notify) {\r\n        ids.forEach(id => {\r\n          const n = notifyIds.get(id);\r\n          if (n && selector.conceptName !== ALL) {\r\n            n.push(selector);\r\n          } else if (selector.conceptName !== ALL) {\r\n            notifyIds.set(id, [selector]);\r\n          } else {\r\n            notifyIds.set(id, []);\r\n          }\r\n        });\r\n      }\r\n    }\r\n    const notification = (id: number) => {\r\n      const ready = notifyIds.get(id);\r\n      const plan = this.currentPlans.get(id);\r\n      if (plan && ready !== undefined) {\r\n        this.nextPlan(plan as Plan, ready);\r\n      } else if (plan && plan.stages[plan.stage].firstRun) {\r\n        // console.log('FIRST RUN: ', plan.title);\r\n        plan.stages[plan.stage].firstRun = false;\r\n        this.nextPlan(plan as Plan, []);\r\n      }\r\n    };\r\n    for (const p of this.ques[Inner].priorityQue) {\r\n      notification(p.planID);\r\n    }\r\n    for (const g of this.ques[Inner].generalQue) {\r\n      notification(g);\r\n    }\r\n    if (!blocking) {\r\n      for (const p of this.ques[Base].priorityQue) {\r\n        notification(p.planID);\r\n      }\r\n      for (const g of this.ques[Base].generalQue) {\r\n        notification(g);\r\n      }\r\n      for (const p of this.ques[Outer].priorityQue) {\r\n        notification(p.planID);\r\n      }\r\n      for (const g of this.ques[Outer].generalQue) {\r\n        notification(g);\r\n      }\r\n    }\r\n  }\r\n\r\n  next(concepts: Concepts) {\r\n    if (!this.closed) {\r\n      this.handleChange(concepts);\r\n      // We notify subs last to encourage actions being acted upon observations\r\n      // Then by utilizing a set quality we may inform the next observation of the change\r\n      this.nextSubs();\r\n    }\r\n  }\r\n  init(concepts: Concepts) {\r\n    this.concepts = concepts;\r\n  }\r\n  nextBlocking(concepts: Concepts) {\r\n    if (!this.closed) {\r\n      this.handleChange(concepts, true);\r\n    }\r\n  }\r\n}"},"For the asynchronous graph programming framework Stratimux, generate a test to ensure that actions are being created as intended.":{"type":"project","content":"import { createAction } from '../model/action';\r\nimport { counterAdd, counterAddType } from '../concepts/counter/qualities/add.quality';\r\n\r\ntest('Axium add Concepts Strategy Test', (done) => {\r\n  const something = createAction('something');\r\n  expect(something.type).toBe('something');\r\n  const add = counterAdd();\r\n  expect(add.type).toBe(counterAddType);\r\n  console.log(add.type);\r\n  done();\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test to ensure that the ActionController model is working as intended.":{"type":"project","content":"import { ActionController, createActionController$ } from '../model/actionController';\r\nimport { axiumBadActionType  } from '../concepts/axium/qualities/badAction.quality';\r\nimport { axiumLog, axiumLogType } from '../concepts/axium/qualities/log.quality';\r\n\r\ntest('ActionController Expired Test', (done) => {\r\n  const act = axiumLog(undefined, undefined, 200);\r\n  const cont = new ActionController(act);\r\n  cont.subscribe(action => {\r\n    expect(action.type).toBe(axiumBadActionType);\r\n    done();\r\n  });\r\n});\r\n\r\ntest('ActionController Next Test', (done) => {\r\n  const act = axiumLog(undefined, undefined, 200);\r\n  const cont = new ActionController(act);\r\n  cont.subscribe(action => {\r\n    expect(action.type).toBe(axiumLogType);\r\n    done();\r\n  });\r\n  cont.fire(act);\r\n});\r\n\r\ntest('ActionController createActionController$ Test', (done) => {\r\n  const act = axiumLog(undefined, undefined, 200);\r\n  const cont = createActionController$(act, (controller, action) => {\r\n    controller.fire(action);\r\n  });\r\n  cont.subscribe(action => {\r\n    expect(action.type).toBe(axiumLogType);\r\n    done();\r\n  });\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test that ensures that the Axium can add concepts into its conceptual sets.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { select, selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, countingStrategy, counterName } from '../concepts/counter/counter.concept';\r\nimport { addConceptsToAddQueThenBlockStrategy } from '../concepts/axium/strategies/addConcept.strategy';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { countingTopic } from '../concepts/counter/strategies/counting.strategy';\r\nimport { forEachConcept } from '../model/concept';\r\nimport { createStage } from '../model/stagePlanner';\r\nimport { axiumSelectOpen } from '../concepts/axium/axium.selector';\r\n\r\ntest('Axium add Concepts Strategy Test', (done) => {\r\n  const axium = createAxium('axiumAddConceptTest',[], true, true);\r\n  const plan = axium.plan('Add Concepts Stage',[\r\n    createStage((concepts, dispatch) => {\r\n      console.log('Add Counter Concept');\r\n      dispatch(\r\n        strategyBegin(\r\n          addConceptsToAddQueThenBlockStrategy(concepts,[createCounterConcept()])\r\n        ),\r\n        {\r\n          iterateStage: true\r\n        }\r\n      );\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      if (select.slice(concepts, axiumSelectOpen)) {\r\n        let exists = false;\r\n        console.log('CHECK CONCEPTS', concepts);\r\n        forEachConcept(concepts, (concept) => {\r\n          if (concept.name === counterName) {\r\n            exists = true;\r\n            const str = countingStrategy();\r\n            console.log('Dispatched', str);\r\n            dispatch(strategyBegin(str), {\r\n              iterateStage: true\r\n            });\r\n            expect(exists).toBe(true);\r\n          }\r\n        });\r\n      }\r\n    }, { selectors: [axiumSelectOpen] }),\r\n    createStage((concepts) => {\r\n      const axiumState = concepts[0].state as AxiumState;\r\n      console.log('Check for final counting topic', axiumState.lastStrategy, concepts[1]?.state);\r\n      if (axiumState.lastStrategy === countingTopic) {\r\n        const counter = selectState<CounterState>(concepts, counterName);\r\n        expect(counter?.count).toBe(1);\r\n        setTimeout(() => {done();}, 500);\r\n        plan.conclude();\r\n        axium.close();\r\n      }\r\n    })\r\n  ]);\r\n});"},"For the asynchronous graph programming framework Stratimux,\r\ngenerate a test to ensure that the strategy consumer function strategyRecurse is functioning as intended.":{"type":"project","content":"/*<$\r\nFor the asynchronous graph programming framework Stratimux,\r\ngenerate a test to ensure that the strategy consumer function strategyRecurse is functioning as intended.\r\n$>*/\r\n/*<#*/"},"For the asynchronous graph programming framework Stratimux, generate a test to ensure the Axium's ability to stitch strategies together and likewise\r\nfor the getAxiumState helper function to properly return the current axium state.":{"type":"project","content":"/*<$\r\nFor the asynchronous graph programming framework Stratimux, generate a test to ensure the Axium's ability to stitch strategies together and likewise\r\nfor the getAxiumState helper function to properly return the current axium state.\r\n$>*/\r\n/*<#*/"},"For the asynchronous graph programming framework Stratimux generate an Experiment Concept that will be used to test deferred changes\r\naccumulated for stage that has a beat and selectors":{"type":"project","content":"import { beatSelectorChangesAddToCountOneQuality } from './qualities/addToCountOne.quality';\r\nimport { createConcept } from '../../model/concept';\r\nimport { beatSelectorChangesAddToCountTwoQuality } from './qualities/addToCountTwo.quality';\r\nimport { beatSelectorChangesAddToCountThreeQuality } from './qualities/addToCountThree.quality';\r\nimport { beatSelectorChangesAddToCountFourQuality } from './qualities/addToCountFour.quality';\r\nimport { beatSelectorChangesAddToCountFiveQuality } from './qualities/addToCountFive.quality';\r\nimport { beatSelectorChangesAddToCountSixQuality } from './qualities/addToCountSix.quality';\r\nimport { beatSelectorChangesAddToCountSevenQuality } from './qualities/addToCountSeven.quality';\r\n\r\nexport type BeatSelectorChangesState = {\r\n    countOne: number\r\n    countTwo: number\r\n    countThree: number\r\n    countFour: number\r\n    countFive: number\r\n    countSix: number\r\n    countSeven: number\r\n}\r\n\r\nexport const beatSelectorChangesName = 'beatSelectorChanges';\r\n\r\nconst initialBeatSelectorChangesState: BeatSelectorChangesState = {\r\n  countOne: 0,\r\n  countTwo: 0,\r\n  countThree: 0,\r\n  countFour: 0,\r\n  countFive: 0,\r\n  countSix: 0,\r\n  countSeven: 0,\r\n};\r\n\r\nexport const createBeatSelectorChangesConcept = () => {\r\n  return createConcept(\r\n    beatSelectorChangesName,\r\n    initialBeatSelectorChangesState,\r\n    [\r\n      beatSelectorChangesAddToCountOneQuality,\r\n      beatSelectorChangesAddToCountTwoQuality,\r\n      beatSelectorChangesAddToCountThreeQuality,\r\n      beatSelectorChangesAddToCountFourQuality,\r\n      beatSelectorChangesAddToCountFiveQuality,\r\n      beatSelectorChangesAddToCountSixQuality,\r\n      beatSelectorChangesAddToCountSevenQuality,\r\n    ]\r\n  );\r\n};"},"For the asynchronous graph programming framework Stratimux and BeatSelectorChanges Concept,\r\ngenerate a KeyedSelector for the BeatSelectorChanges's count variants state properties.":{"type":"project","content":"import { KeyedSelector, createConceptKeyedSelector } from '../../model/selector';\r\nimport { BeatSelectorChangesState } from './beatSelectorChanges.concept';\r\n\r\nexport const beatSelectorChangesSelectCountOne: KeyedSelector =\r\n  createConceptKeyedSelector<BeatSelectorChangesState>('beatSelectorChanges', 'countOne');\r\nexport const beatSelectorChangesSelectCountTwo: KeyedSelector =\r\n  createConceptKeyedSelector<BeatSelectorChangesState>('beatSelectorChanges', 'countTwo');\r\nexport const beatSelectorChangesSelectCountThree: KeyedSelector =\r\n  createConceptKeyedSelector<BeatSelectorChangesState>('beatSelectorChanges', 'countThree');\r\nexport const beatSelectorChangesSelectCountFour: KeyedSelector =\r\n  createConceptKeyedSelector<BeatSelectorChangesState>('beatSelectorChanges', 'countFour');\r\nexport const beatSelectorChangesSelectCountFive: KeyedSelector =\r\n  createConceptKeyedSelector<BeatSelectorChangesState>('beatSelectorChanges', 'countFive');\r\nexport const beatSelectorChangesSelectCountSix: KeyedSelector =\r\n  createConceptKeyedSelector<BeatSelectorChangesState>('beatSelectorChanges', 'countSix');\r\nexport const beatSelectorChangesSelectCountSeven: KeyedSelector =\r\n  createConceptKeyedSelector<BeatSelectorChangesState>('beatSelectorChanges', 'countSeven');"},"For the asynchronous graph programming framework Stratimux generate a test that ensures that changes are properly deferred\r\nutilizing the provided BeatSelectorChanges concept":{"type":"project","content":"import { createAxium, getAxiumState } from '../../model/axium';\r\nimport { createStage } from '../../model/stagePlanner';\r\nimport { generateRandomCountingStrategy } from './strategies/generateCountingStrategy.strategy';\r\nimport { beatSelectorChangesName, createBeatSelectorChangesConcept } from './beatSelectorChanges.concept';\r\nimport { initializeTopic } from '../../concepts/axium/strategies/initialization.strategy';\r\nimport { strategyBegin } from '../../model/actionStrategy';\r\nimport {\r\n  beatSelectorChangesSelectCountFive,\r\n  beatSelectorChangesSelectCountFour,\r\n  beatSelectorChangesSelectCountOne,\r\n  beatSelectorChangesSelectCountSeven,\r\n  beatSelectorChangesSelectCountSix,\r\n  beatSelectorChangesSelectCountThree,\r\n  beatSelectorChangesSelectCountTwo\r\n} from './beatSelectorChanges.selector';\r\nimport { selectSlice, selectState } from '../../model/selector';\r\njest.setTimeout(30000);\r\ntest('Deferred Beat Selector Changes Test', (done) => {\r\n  const beat = 7000;\r\n  const [tally, strategy, topic] = generateRandomCountingStrategy();\r\n  const axium = createAxium('Beat Selector Changes properly defers accumulated changes', [\r\n    createBeatSelectorChangesConcept()\r\n  ]);\r\n  const plan = axium.plan('Prolonged Counting Strategy', [\r\n    createStage((concepts, dispatch) => {\r\n      if (getAxiumState(concepts).lastStrategy === initializeTopic) {\r\n        dispatch(strategyBegin(strategy), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, _, changes) => {\r\n      if (getAxiumState(concepts).lastStrategy === topic) {\r\n        expect(selectSlice(concepts, beatSelectorChangesSelectCountOne)).toBe(tally[0]);\r\n        expect(selectSlice(concepts, beatSelectorChangesSelectCountTwo)).toBe(tally[1]);\r\n        expect(selectSlice(concepts, beatSelectorChangesSelectCountThree)).toBe(tally[2]);\r\n        expect(selectSlice(concepts, beatSelectorChangesSelectCountFour)).toBe(tally[3]);\r\n        expect(selectSlice(concepts, beatSelectorChangesSelectCountFive)).toBe(tally[4]);\r\n        expect(selectSlice(concepts, beatSelectorChangesSelectCountSix)).toBe(tally[5]);\r\n        expect(selectSlice(concepts, beatSelectorChangesSelectCountSeven)).toBe(tally[6]);\r\n        expect(changes?.length).toBe(tally.length);\r\n        setTimeout(() => {\r\n          plan.conclude();\r\n          axium.close();\r\n          done();\r\n        }, 500);\r\n      }\r\n    }, {\r\n      beat,\r\n      selectors: [\r\n        beatSelectorChangesSelectCountOne,\r\n        beatSelectorChangesSelectCountTwo,\r\n        beatSelectorChangesSelectCountThree,\r\n        beatSelectorChangesSelectCountFour,\r\n        beatSelectorChangesSelectCountFive,\r\n        beatSelectorChangesSelectCountSix,\r\n        beatSelectorChangesSelectCountSeven,\r\n      ]\r\n    })\r\n  ]);\r\n});"},"For the asynchronous graph programming framework Stratimux and BeatSelectorChanges Concept,\r\ngenerate a quality that will increment the state's countFive by one.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { BeatSelectorChangesState } from '../beatSelectorChanges.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  beatSelectorChangesAddToCountFive,\r\n  beatSelectorChangesAddToCountFiveType,\r\n  beatSelectorChangesAddToCountFiveQuality\r\n] = createQualitySet({\r\n  type: 'BeatSelectorChanges AddToCountFive',\r\n  reducer: (state: BeatSelectorChangesState) => {\r\n    return {\r\n      ...state,\r\n      countFive: state.countFive + 1\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator,\r\n});"},"For the asynchronous graph programming framework Stratimux and BeatSelectorChanges Concept,\r\ngenerate a quality that will increment the state's countFour by one.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { BeatSelectorChangesState } from '../beatSelectorChanges.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  beatSelectorChangesAddToCountFour,\r\n  beatSelectorChangesAddToCountFourType,\r\n  beatSelectorChangesAddToCountFourQuality\r\n] = createQualitySet({\r\n  type: 'BeatSelectorChanges AddToCountFour',\r\n  reducer: (state: BeatSelectorChangesState) => {\r\n    return {\r\n      ...state,\r\n      countFour: state.countFour + 1\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator,\r\n});"},"For the asynchronous graph programming framework Stratimux and BeatSelectorChanges Concept,\r\ngenerate a quality that will increment the state's countOne by one.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { BeatSelectorChangesState } from '../beatSelectorChanges.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  beatSelectorChangesAddToCountOne,\r\n  beatSelectorChangesAddToCountOneType,\r\n  beatSelectorChangesAddToCountOneQuality\r\n] = createQualitySet({\r\n  type: 'BeatSelectorChanges AddToCountOne',\r\n  reducer: (state: BeatSelectorChangesState) => {\r\n    return {\r\n      ...state,\r\n      countOne: state.countOne + 1\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator,\r\n});"},"For the asynchronous graph programming framework Stratimux and BeatSelectorChanges Concept,\r\ngenerate a quality that will increment the state's countSeven by one.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { BeatSelectorChangesState } from '../beatSelectorChanges.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  beatSelectorChangesAddToCountSeven,\r\n  beatSelectorChangesAddToCountSevenType,\r\n  beatSelectorChangesAddToCountSevenQuality\r\n] = createQualitySet({\r\n  type: 'BeatSelectorChanges AddToCountSeven',\r\n  reducer: (state: BeatSelectorChangesState) => {\r\n    return {\r\n      ...state,\r\n      countSeven: state.countSeven + 1\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator,\r\n});"},"For the asynchronous graph programming framework Stratimux and BeatSelectorChanges Concept,\r\ngenerate a quality that will increment the state's countSix by one.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { BeatSelectorChangesState } from '../beatSelectorChanges.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  beatSelectorChangesAddToCountSix,\r\n  beatSelectorChangesAddToCountSixType,\r\n  beatSelectorChangesAddToCountSixQuality\r\n] = createQualitySet({\r\n  type: 'BeatSelectorChanges AddToCountSix',\r\n  reducer: (state: BeatSelectorChangesState) => {\r\n    return {\r\n      ...state,\r\n      countSix: state.countSix + 1\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator,\r\n});"},"For the asynchronous graph programming framework Stratimux and BeatSelectorChanges Concept,\r\ngenerate a quality that will increment the state's countThree by one.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { BeatSelectorChangesState } from '../beatSelectorChanges.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  beatSelectorChangesAddToCountThree,\r\n  beatSelectorChangesAddToCountThreeType,\r\n  beatSelectorChangesAddToCountThreeQuality\r\n] = createQualitySet({\r\n  type: 'BeatSelectorChanges AddToCountThree',\r\n  reducer: (state: BeatSelectorChangesState) => {\r\n    return {\r\n      ...state,\r\n      countThree: state.countThree + 1\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator,\r\n});"},"For the asynchronous graph programming framework Stratimux and BeatSelectorChanges Concept,\r\ngenerate a quality that will increment the state's countTwo by one.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { BeatSelectorChangesState } from '../beatSelectorChanges.concept';\r\nimport { createQualitySet } from '../../../model/quality';\r\n\r\nexport const [\r\n  beatSelectorChangesAddToCountTwo,\r\n  beatSelectorChangesAddToCountTwoType,\r\n  beatSelectorChangesAddToCountTwoQuality\r\n] = createQualitySet({\r\n  type: 'BeatSelectorChanges AddToCountTwo',\r\n  reducer: (state: BeatSelectorChangesState) => {\r\n    return {\r\n      ...state,\r\n      countTwo: state.countTwo + 1\r\n    };\r\n  },\r\n  methodCreator: defaultMethodCreator,\r\n});"},"For the asynchronous graph programming framework Stratimux generate an ActionStrategy that will randomly increment each\r\nBeatSelectorChanges count variants for 100 steps.":{"type":"project","content":"import { ActionNode, ActionStrategy, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { beatSelectorChangesAddToCountOne } from '../qualities/addToCountOne.quality';\r\nimport { beatSelectorChangesAddToCountThree } from '../qualities/addToCountThree.quality';\r\nimport { beatSelectorChangesAddToCountTwo } from '../qualities/addToCountTwo.quality';\r\nimport { beatSelectorChangesAddToCountFour } from '../qualities/addToCountFour.quality';\r\nimport { beatSelectorChangesAddToCountFive } from '../qualities/addToCountFive.quality';\r\nimport { beatSelectorChangesAddToCountSix } from '../qualities/addToCountSix.quality';\r\nimport { beatSelectorChangesAddToCountSeven } from '../qualities/addToCountSeven.quality';\r\n\r\nfunction getRandomRange(min: number, max: number) {\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\nexport const generateRandomCountingStrategy = (): [\r\n  [number, number, number, number, number, number, number],\r\n  ActionStrategy,\r\n  string\r\n] => {\r\n  const steps = 100;\r\n  const variantTally = new Array(7).fill(0) as [number, number, number, number, number, number, number];\r\n  const variants = [\r\n    beatSelectorChangesAddToCountOne,\r\n    beatSelectorChangesAddToCountTwo,\r\n    beatSelectorChangesAddToCountThree,\r\n    beatSelectorChangesAddToCountFour,\r\n    beatSelectorChangesAddToCountFive,\r\n    beatSelectorChangesAddToCountSix,\r\n    beatSelectorChangesAddToCountSeven,\r\n  ];\r\n  let selection = Math.floor(getRandomRange(0, 6));\r\n  let previousStep: ActionNode =\r\n    createActionNode(variants[selection](), {\r\n      successNode: null,\r\n      failureNode: null\r\n    });\r\n  const stepFirst = previousStep;\r\n  variantTally[selection]++;\r\n  for (let i = 0; i < steps; i++) {\r\n    selection = Math.round(getRandomRange(0, 6));\r\n    const newStep: ActionNode =\r\n      createActionNode(variants[selection](), {\r\n        successNode: null,\r\n        failureNode: null\r\n      });\r\n    variantTally[selection]++;\r\n\r\n    previousStep.successNode = newStep;\r\n    previousStep = newStep;\r\n  }\r\n  previousStep.successNode = null;\r\n\r\n  const topic = `Generated Counting Strategy, using ${variantTally}`;\r\n  return [\r\n    variantTally,\r\n    createStrategy({\r\n      initialNode: stepFirst,\r\n      topic,\r\n    }),\r\n    topic\r\n  ];\r\n};"},"For the asynchronous graph programming framework Stratimux and Chain Concept, generate a test ensure that chain is working as intended.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { Concepts } from '../model/concept';\r\nimport { primeAction } from '../model/action';\r\nimport { selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, counterName } from '../concepts/counter/counter.concept';\r\nimport { ChainState, chainName, createChainConcept } from '../concepts/chain/chain.concept';\r\nimport { chainPrepareChain } from '../concepts/chain/qualities/prepareChain.quality';\r\nimport { counterAdd } from '../concepts/counter/qualities/add.quality';\r\nimport { counterSubtract } from '../concepts/counter/qualities/subtract.quality';\r\nimport { chainEnd } from '../concepts/chain/qualities/chainEnd.quality';\r\n\r\ntest('Axium Test', (done) => {\r\n  const axium = createAxium('chainConceptTest', [createCounterConcept(), createChainConcept()], true, true);\r\n  let count = 0;\r\n  let willDispatch = true;\r\n  const sub = axium.subscribe((concepts: Concepts) => {\r\n    count++;\r\n    if (willDispatch) {\r\n      willDispatch = false;\r\n      const primedAdd = primeAction(concepts, counterAdd());\r\n      const primedSubtract = primeAction(concepts, counterSubtract());\r\n      const primedEnd = primeAction(concepts, chainEnd());\r\n      const primedPrepareChain =\r\n      primeAction(concepts,\r\n        chainPrepareChain({\r\n          actions: [\r\n            primedAdd,\r\n            primedAdd,\r\n            primedSubtract,\r\n            primedAdd,\r\n            primedSubtract,\r\n            primedAdd,\r\n            primedEnd\r\n          ]\r\n        }));\r\n      axium.dispatch(primedPrepareChain);\r\n    }\r\n    else if (selectState<ChainState>(concepts, chainName)?.end) {\r\n      const counter = selectState<CounterState>(concepts, counterName);\r\n      expect(counter?.count).toBe(2);\r\n      setTimeout(() => {done();}, 500);\r\n      axium.close();\r\n      sub.unsubscribe();\r\n    }\r\n  });\r\n});"},"For the asynchronous graph programming framework Stratimux,\r\ngenerate a test to that ensures the functionality of is concept loaded and are concept loaded helper functions.":{"type":"project","content":"import { counterName, createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { createAxium } from '../model/axium';\r\nimport { areConceptsLoaded, chainName, createChainConcept, isConceptLoaded } from '../index';\r\nimport { createStage } from '../model/stagePlanner';\r\n\r\ntest('Concepts exists', (done) => {\r\n  const axium = createAxium('Mock Axium', [createCounterConcept()]);\r\n  axium.plan('Check Concepts', [\r\n    createStage((concepts, __) => {\r\n      if (isConceptLoaded(concepts, counterName)) {\r\n        expect(true).toBe(true);\r\n        done();\r\n      } else {\r\n        expect(false).toBe(true);\r\n        done();\r\n      }\r\n    }),\r\n  ]);\r\n});\r\n\r\ntest('Concepts exists', (done) => {\r\n  const axium = createAxium('Mock Axium', [createCounterConcept(), createChainConcept()]);\r\n  const stage = axium.plan('Check Concepts', [\r\n    createStage((concepts, __) => {\r\n      if (areConceptsLoaded(concepts, [counterName, chainName])) {\r\n        expect(true).toBe(true);\r\n        stage.conclude();\r\n        axium.close();\r\n        done();\r\n      } else {\r\n        expect(false).toBe(true);\r\n        stage.conclude();\r\n        axium.close();\r\n        done();\r\n      }\r\n    }),\r\n  ]);\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test that logs how a concept would be parsed to a stream to the console.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { conceptsToString } from '../model/concept';\r\n\r\ntest('Axium Counting Strategy Test', (done) => {\r\n  const axium = createAxium('axiumStrategyTest', [createCounterConcept()], true, true);\r\n  const sub = axium.subscribe(concepts => {\r\n    console.log('CONCEPTS:', conceptsToString(concepts));\r\n    expect(true).toBe(true);\r\n    sub.unsubscribe();\r\n    setTimeout(() => {\r\n      done();\r\n    }, 500);\r\n  });\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a tests and demonstrates how debouncing methods perform their functionality.":{"type":"project","content":"import { axiumSelectLastStrategy, axiumSelectLastStrategyData } from '../concepts/axium/axium.selector';\r\nimport { axiumKick } from '../concepts/axium/qualities/kick.quality';\r\nimport { CounterState, counterName, createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { ExperimentState, createExperimentConcept, createExperimentState, experimentName } from '../concepts/experiment/experiment.concept';\r\nimport {\r\n  experimentDebounceAsyncIterateIdThenReceiveInMethodQuality\r\n} from '../concepts/experiment/qualities/debounceAsyncIterateIdThenReceiveInMethod.quality';\r\nimport { experimentAsyncDebounceNextActionNodeQuality } from '../concepts/experiment/qualities/debounceAsyncNextActionNode.quality';\r\nimport {\r\n  ExperimentDebounceIterateIdThenReceiveInMethodPayload,\r\n  experimentDebounceIterateIdThenReceiveInMethodQuality\r\n} from '../concepts/experiment/qualities/debounceIterateIdThenReceiveInMethod.quality';\r\nimport { experimentDebounceNextActionNodeQuality } from '../concepts/experiment/qualities/debounceNextActionNode.quality';\r\nimport { experimentAsyncDebounceAddOneStrategy } from '../concepts/experiment/strategies/asyncDebounceAddOne.strategy';\r\nimport { experimentDebounceAddOneStrategy } from '../concepts/experiment/strategies/debounceAddOne.strategy';\r\nimport {\r\n  experimentDebounceAsyncIterateIdThenAddToData,\r\n  experimentDebounceAsyncIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/debounceAsyncIterateIdThenAddToData.strategy';\r\nimport {\r\n  experimentDebounceIterateIdThenAddToData,\r\n  experimentDebounceIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/debounceIterateIdThenAddToData.strategy';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { createAxium } from '../model/axium';\r\nimport { selectSlice, selectState } from '../model/selector';\r\nimport { createStage } from '../model/stagePlanner';\r\n\r\ntest('Debounce method prevent excess count', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentDebounceNextActionNodeQuality]);\r\n  const axium = createAxium('Experiment async method creator with State', [createCounterConcept(), experiment]);\r\n  const plan = axium.plan('Experiment debounce add one', [\r\n    createStage((_, dispatch) => {\r\n      dispatch(strategyBegin(experimentDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((_, dispatch) => {\r\n      dispatch(strategyBegin(experimentDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((_, dispatch) => {\r\n      dispatch(strategyBegin(experimentDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((concepts, _) => {\r\n      const counterState = selectState<CounterState>(concepts, counterName);\r\n      console.log('Debounce HIT 4', counterState);\r\n      if (counterState?.count === 1) {\r\n        console.log('Final Debounce HIT 4', counterState);\r\n        expect(counterState.count).toBe(1);\r\n        plan.conclude();\r\n        done();\r\n      }\r\n    })\r\n  ]);\r\n});\r\n\r\ntest('Async debounce method prevent excess count', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentAsyncDebounceNextActionNodeQuality]);\r\n  const axium = createAxium('Experiment async debounce', [createCounterConcept(), experiment]);\r\n  const plan = axium.plan('Experiment async debounce add one', [\r\n    createStage((_, dispatch) => {\r\n      dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((_, dispatch) => {\r\n      dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((_, dispatch) => {\r\n      dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((concepts, _) => {\r\n      const counterState = selectState<CounterState>(concepts, counterName);\r\n      console.log('Async Debounce HIT 4', counterState);\r\n      if (counterState?.count === 1) {\r\n        console.log('FINAL Async Debounce HIT 4', counterState);\r\n        expect(counterState.count).toBe(1);\r\n        plan.conclude();\r\n      }\r\n    })\r\n  ]);\r\n  setTimeout(() => {\r\n    const secondPlan = axium.plan('Second experiment async debounce add one', [\r\n      createStage((_, dispatch) => {\r\n        dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n          iterateStage: true\r\n        });\r\n      }),\r\n      createStage((_, dispatch) => {\r\n        dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n          iterateStage: true\r\n        });\r\n      }),\r\n      createStage((_, dispatch) => {\r\n        dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n          iterateStage: true\r\n        });\r\n      }),\r\n      createStage((concepts, _) => {\r\n        const counterState = selectState<CounterState>(concepts, counterName);\r\n        console.log('Async 2 Debounce HIT 4', counterState);\r\n        if (counterState?.count === 2) {\r\n          console.log('FINAL Async 2 Debounce HIT 4', counterState);\r\n          expect(counterState.count).toBe(2);\r\n          secondPlan.conclude();\r\n          axium.close();\r\n          setTimeout(() => {\r\n            done();\r\n          }, 500);\r\n        }\r\n      })\r\n    ]);\r\n    // Axium must be primed, therefore we kick it back into gear.\r\n    // Downside of halting quality.\r\n    axium.dispatch(axiumKick());\r\n  }, 1000);\r\n});\r\n\r\ntest('Debounce Method Test with State id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentDebounceIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.plan('Debounce Iterate id with concepts', [\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Debounce: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Debounce: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, _) => {\r\n      const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const data = selectSlice<ExperimentState & ExperimentDebounceIterateIdThenReceiveInMethodPayload>(\r\n          concepts,\r\n          axiumSelectLastStrategyData\r\n        );\r\n        console.log('Debounce: ', experimentState.id, lastStrategy, data);\r\n        if (lastStrategy === experimentDebounceIterateIdThenAddToDataTopic) {\r\n          if (data) {\r\n            console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n            expect(data.id).toBe(3);\r\n            expect(data.setId).toBe(2);\r\n            expect(experimentState.id).toBe(3);\r\n            plan.conclude();\r\n          }\r\n        }\r\n      }\r\n    })\r\n  ]);\r\n  setTimeout(() => {\r\n    console.log('BEGIN 2ND PLAN');\r\n    const secondPlan = axium.plan('Second experiment debounce add one', [\r\n      createStage((concepts, dispatch) => {\r\n        console.log('2 Debounce initial dispatch');\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }),\r\n      createStage((concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('2 Debounce: ', experimentState.id, lastStrategy, data);\r\n          dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }),\r\n      createStage((concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('2 Debounce: ', experimentState.id, lastStrategy, data);\r\n          dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }),\r\n      createStage((concepts, _) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState & ExperimentDebounceIterateIdThenReceiveInMethodPayload>(\r\n            concepts,\r\n            axiumSelectLastStrategyData\r\n          );\r\n          console.log('2 Debounce: ', experimentState.id, lastStrategy, data);\r\n          if (lastStrategy === experimentDebounceIterateIdThenAddToDataTopic) {\r\n            if (data && data.id === 6) {\r\n              console.log('2 Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n              expect(data.id).toBe(6);\r\n              expect(data.setId).toBe(5);\r\n              expect(experimentState.id).toBe(6);\r\n              secondPlan.conclude();\r\n              axium.close();\r\n              done();\r\n            }\r\n          }\r\n        }\r\n      })\r\n    ]);\r\n    // Kick\r\n    axium.dispatch(axiumKick());\r\n  }, 1000);\r\n});\r\n\r\ntest('Debounce Async Method Test with State id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentDebounceAsyncIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.plan('Debounce Async Iterate id with concepts', [\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        dispatch(strategyBegin(experimentDebounceAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Async Debounce: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentDebounceAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Async Debounce: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentDebounceAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState & ExperimentDebounceIterateIdThenReceiveInMethodPayload>(\r\n          concepts,\r\n          axiumSelectLastStrategyData\r\n        );\r\n        console.log('Async Debounce: ', experimentState.id, lastStrategy, data);\r\n        if (lastStrategy === experimentDebounceAsyncIterateIdThenAddToDataTopic) {\r\n          if (data) {\r\n            console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n            expect(data.id).toBe(3);\r\n            expect(data.setId).toBe(2);\r\n            expect(experimentState.id).toBe(3);\r\n            plan.conclude();\r\n          }\r\n        }\r\n      }\r\n    })\r\n  ]);\r\n  setTimeout(() => {\r\n    console.log('BEGIN 2ND PLAN');\r\n    const secondPlan = axium.plan('Second experiment async debounce add one', [\r\n      createStage((concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const strategy = experimentDebounceAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }),\r\n      createStage((concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('2 Async Debounce: ', experimentState.id, lastStrategy, data);\r\n          const strategy = experimentDebounceAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }),\r\n      createStage((concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('2 Async Debounce: ', experimentState.id, lastStrategy, data);\r\n          const strategy = experimentDebounceAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }),\r\n      createStage((concepts, _) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState & ExperimentDebounceIterateIdThenReceiveInMethodPayload>(\r\n            concepts,\r\n            axiumSelectLastStrategyData\r\n          );\r\n          console.log('2 Async Debounce: ', experimentState.id, lastStrategy, data);\r\n          if (lastStrategy === experimentDebounceAsyncIterateIdThenAddToDataTopic + 2) {\r\n            if (data) {\r\n              console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n              expect(data.id).toBe(6);\r\n              expect(data.setId).toBe(5);\r\n              expect(experimentState.id).toBe(6);\r\n              secondPlan.conclude();\r\n              axium.close();\r\n              done();\r\n            }\r\n          }\r\n        }\r\n      })\r\n    ]);\r\n    // Kick\r\n    axium.dispatch(axiumKick());\r\n  }, 1000);\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test to ensure that method helpers are working as intended.":{"type":"project","content":"import { axiumSelectLastStrategy, axiumSelectLastStrategyData } from '../concepts/axium/axium.selector';\r\nimport { axiumKick } from '../concepts/axium/qualities/kick.quality';\r\nimport { ExperimentState, createExperimentConcept, createExperimentState, experimentName } from '../concepts/experiment/experiment.concept';\r\nimport {\r\n  experimentAsyncIterateIdThenReceiveInMethod,\r\n  experimentAsyncIterateIdThenReceiveInMethodQuality\r\n} from '../concepts/experiment/qualities/asyncIterateIdThenReceiveInMethod.quality';\r\nimport { experimentIterateIdThenReceiveInMethodQuality } from '../concepts/experiment/qualities/iterateIdThenReceiveInMethod.quality';\r\nimport { experimentMockToTrueQuality } from '../concepts/experiment/qualities/mockToTrue.quality';\r\nimport { experimentTimerEmitActionQuality } from '../concepts/experiment/qualities/timerEmitAction.quality';\r\nimport { experimentTimerEmitActionWithStateQuality } from '../concepts/experiment/qualities/timerEmitActionWithState.quality';\r\nimport {\r\n  experimentAsyncIterateIdThenAddToData,\r\n  experimentAsyncIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/asyncIterateIdThenAddToData.strategy';\r\nimport {\r\n  iterateIdThenAddToData,\r\n  experimentIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/iterateIdThenAddToData.strategy';\r\nimport { experimentTimedMockToTrue } from '../concepts/experiment/strategies/timedMockToTrue.strategy';\r\nimport {\r\n  timedMockToTrueWithState,\r\n  experimentTimedMockToTrueWithStateTopic\r\n} from '../concepts/experiment/strategies/timedMockToTrueWithState.strategy';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { createAxium } from '../model/axium';\r\nimport { selectSlice, selectState } from '../model/selector';\r\nimport { createStage, stageWaitForOpenThenIterate } from '../model/stagePlanner';\r\n\r\ntest('Async Method Test', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentTimerEmitActionQuality, experimentMockToTrueQuality]);\r\n  const axium = createAxium('Experiment async method creator', [experiment]);\r\n  const plan = axium.plan('timed mock to true', [\r\n    stageWaitForOpenThenIterate(() => axiumKick()),\r\n    createStage((_, dispatch) => {\r\n      dispatch(strategyBegin(experimentTimedMockToTrue()), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState?.mock) {\r\n        expect(experimentState.mock).toBe(true);\r\n        plan.conclude();\r\n        axium.close();\r\n        done();\r\n      }\r\n    })\r\n  ]);\r\n});\r\n\r\ntest('Async Method Plain Iterate Id Test', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentAsyncIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment async method creator', [experiment]);\r\n  const plan = axium.plan('timed mock to true', [\r\n    stageWaitForOpenThenIterate(() => axiumKick()),\r\n    createStage((_, dispatch) => {\r\n      dispatch(experimentAsyncIterateIdThenReceiveInMethod(), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      console.log(experiment.state);\r\n      if (experimentState?.id) {\r\n        expect(experimentState.id).toBe(1);\r\n        setTimeout(() => {\r\n          plan.conclude();\r\n          axium.close();\r\n        }, 50);\r\n        done();\r\n      }\r\n    })\r\n  ]);\r\n});\r\n\r\ntest('Async Method with State Test', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentTimerEmitActionWithStateQuality, experimentMockToTrueQuality]);\r\n  const axium = createAxium('Experiment async method creator with State', [experiment]);\r\n  const plan = axium.plan('timed mock to true', [\r\n    stageWaitForOpenThenIterate(() => axiumKick()),\r\n    createStage((_, dispatch) => {\r\n      dispatch(strategyBegin(timedMockToTrueWithState()), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        if (lastStrategy === experimentTimedMockToTrueWithStateTopic) {\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          if (data) {\r\n            expect(data.mock).toBe(false);\r\n            expect(experimentState.mock).toBe(true);\r\n            plan.conclude();\r\n            axium.close();\r\n            done();\r\n          }\r\n        }\r\n      }\r\n    })\r\n  ]);\r\n});\r\n\r\ntest('Method Test with State id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.plan('Iterate id', [\r\n    stageWaitForOpenThenIterate(() => axiumKick()),\r\n    createStage((_, dispatch) => {\r\n      dispatch(strategyBegin(iterateIdThenAddToData()), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        console.log('CHECK LAST STRATEGY', lastStrategy);\r\n        if (lastStrategy === experimentIterateIdThenAddToDataTopic) {\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          if (data) {\r\n            console.log('Strategy Data: ', data.id, 'Experiment State ID: ', experimentState.id);\r\n            expect(data.id).toBe(0);\r\n            expect(experimentState.id).toBe(1);\r\n            plan.conclude();\r\n            axium.close();\r\n            done();\r\n          }\r\n        }\r\n      }\r\n    })\r\n  ]);\r\n});\r\n\r\ntest('Async Method Test with State id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentAsyncIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.plan('Iterate id', [\r\n    stageWaitForOpenThenIterate(() => axiumKick()),\r\n    createStage((_, dispatch) => {\r\n      dispatch(strategyBegin(experimentAsyncIterateIdThenAddToData()), {\r\n        iterateStage: true\r\n      });\r\n    }),\r\n    createStage((concepts, _) => {\r\n      const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        if (lastStrategy === experimentAsyncIterateIdThenAddToDataTopic) {\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          if (data) {\r\n            console.log('Async Strategy Data: ', data.id, 'Experiment State ID: ', experimentState.id);\r\n            expect(data.id).toBe(0);\r\n            expect(experimentState.id).toBe(1);\r\n            plan.conclude();\r\n            axium.close();\r\n            done();\r\n          }\r\n        }\r\n      }\r\n    })\r\n  ]);\r\n});"},"For the asynchronous graph programming framework Stratimux generate a test that ensures that each possible plan options functions alongside in the axium":{"type":"project","content":"import { createExperimentPlanOptionsConcept } from './newPlanOptions.concept';\r\nimport { createAxium, getAxiumState } from '../../model/axium';\r\nimport { createStage } from '../../model/stagePlanner';\r\nimport { selectSlice } from '../../model/selector';\r\nimport { experimentPlanOptionsIsReady } from './qualities/isReady.quality';\r\nimport { axiumKick } from '../../concepts/axium/qualities/kick.quality';\r\nimport { axiumSelectOpen } from '../../concepts/axium/axium.selector';\r\njest.setTimeout(30000);\r\ntest('prioritized plans with selectors Test', (done) => {\r\n  const planPrioritizedSelectors = createAxium('Plan New Stage Priority Test', [\r\n    createExperimentPlanOptionsConcept()\r\n  ]);\r\n  const num = 100;\r\n  const allShouldBeTrue = new Array(num).fill(false);\r\n  const stressTest = (id: number) => {\r\n    console.log('INIT ', id);\r\n    const plan = planPrioritizedSelectors.plan('Ensure that prioritized plans with selectors allow for each plan to be informed', [\r\n      createStage((concepts, dispatch) => {\r\n        if (selectSlice(concepts, axiumSelectOpen)) {\r\n          console.log(`FIRE ${id}`, allShouldBeTrue, getAxiumState(concepts).open);\r\n          dispatch(axiumKick(), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }, { priority: (num + 1) - id, selectors: [axiumSelectOpen] }),\r\n      createStage(() => {\r\n        allShouldBeTrue[id] = true;\r\n        plan.conclude();\r\n      })\r\n    ]);\r\n  };\r\n  allShouldBeTrue.forEach((_, id) => stressTest(id));\r\n  planPrioritizedSelectors.dispatch(experimentPlanOptionsIsReady());\r\n  setTimeout(() => {\r\n    let trueCount = 0;\r\n    allShouldBeTrue.forEach(b => {\r\n      if (b) {\r\n        trueCount++;\r\n      }\r\n    });\r\n    console.log('FINAL: ', allShouldBeTrue);\r\n    expect(trueCount).toBe(allShouldBeTrue.length);\r\n    planPrioritizedSelectors.close();\r\n    setTimeout(() => {\r\n      done();\r\n    }, 5000);\r\n    done();\r\n  }, 2000);\r\n});"},"For the asynchronous graph programming framework Stratimux and a Experiment PlanOptions Concept, generate both possible selectors":{"type":"project","content":"import { experimentName } from '../../concepts/experiment/experiment.concept';\r\nimport { KeyedSelector, createConceptKeyedSelector } from '../../model/selector';\r\nimport { ExperimentPlanOptionsState } from './newPlanOptions.concept';\r\n\r\nexport const experimentPlanOptionsReadySelector: KeyedSelector =\r\n  createConceptKeyedSelector<ExperimentPlanOptionsState>(experimentName, 'ready');\r\n\r\nexport const experimentPlanOptionsValueSelector: KeyedSelector =\r\n  createConceptKeyedSelector<ExperimentPlanOptionsState>(experimentName, 'value');"},"For the asynchronous graph programming framework Stratimux generate a test that ensures that users can set new selectors for their stages and another\r\ntest to ensure that they can change the priority of their stages and again for beat":{"type":"project","content":"import { createExperimentPlanOptionsConcept } from './newPlanOptions.concept';\r\nimport { createAxium } from '../../model/axium';\r\nimport { createStage } from '../../model/stagePlanner';\r\nimport { KeyedSelector, selectSlice } from '../../model/selector';\r\nimport { planOptionsSelect } from './newPlanOptions.selectors';\r\nimport { experimentToggleAllSeven } from './qualities/toggleAllSeven.quality';\r\nimport { experimentPlanOptionsAddValue } from './qualities/addValue.quality';\r\nimport { experimentPlanOptionsIsReady } from './qualities/isReady.quality';\r\nimport { experimentPlanOptionsReadySelector } from './newPlanOptions.selector';\r\n\r\ntest('New Plan Options Selector Test', (done) => {\r\n  const planNewStageSelectors = createAxium('Plan New Stage Selectors Test', [\r\n    createExperimentPlanOptionsConcept()\r\n  ]);\r\n  let count = 0;\r\n  const plan = planNewStageSelectors.plan('Ensure New Selectors Can be set on a single stage', [\r\n    createStage((_, dispatch, changes) => {\r\n      // First run will be all\r\n      const selectors: KeyedSelector[] = [];\r\n      let final = false;\r\n      if (count === 0) {\r\n        selectors.push(planOptionsSelect.one);\r\n        expect(changes?.length).toBe(0);\r\n      } else if (count === 1) {\r\n        selectors.push(planOptionsSelect.one);\r\n        selectors.push(planOptionsSelect.two);\r\n        expect(changes?.length).toBe(1);\r\n      } else if (count === 2) {\r\n        selectors.push(planOptionsSelect.one);\r\n        selectors.push(planOptionsSelect.two);\r\n        selectors.push(planOptionsSelect.three);\r\n        expect(changes?.length).toBe(2);\r\n      } else if (count === 3) {\r\n        selectors.push(planOptionsSelect.one);\r\n        selectors.push(planOptionsSelect.two);\r\n        selectors.push(planOptionsSelect.three);\r\n        selectors.push(planOptionsSelect.four);\r\n        expect(changes?.length).toBe(3);\r\n      } else if (count === 4) {\r\n        selectors.push(planOptionsSelect.one);\r\n        selectors.push(planOptionsSelect.two);\r\n        selectors.push(planOptionsSelect.three);\r\n        selectors.push(planOptionsSelect.four);\r\n        selectors.push(planOptionsSelect.five);\r\n        expect(changes?.length).toBe(4);\r\n      } else if (count === 5) {\r\n        selectors.push(planOptionsSelect.one);\r\n        selectors.push(planOptionsSelect.two);\r\n        selectors.push(planOptionsSelect.three);\r\n        selectors.push(planOptionsSelect.four);\r\n        selectors.push(planOptionsSelect.five);\r\n        selectors.push(planOptionsSelect.six);\r\n        expect(changes?.length).toBe(5);\r\n      } else if (count === 6) {\r\n        selectors.push(planOptionsSelect.one);\r\n        selectors.push(planOptionsSelect.two);\r\n        selectors.push(planOptionsSelect.three);\r\n        selectors.push(planOptionsSelect.four);\r\n        selectors.push(planOptionsSelect.five);\r\n        selectors.push(planOptionsSelect.six);\r\n        selectors.push(planOptionsSelect.seven);\r\n        expect(changes?.length).toBe(6);\r\n      } else {\r\n        expect(changes?.length).toBe(7);\r\n        final = true;\r\n      }\r\n\r\n      console.log(`Run: ${count}`);\r\n      count++;\r\n      if (final) {\r\n        dispatch(experimentToggleAllSeven(), {\r\n          newSelectors: selectors,\r\n          throttle: 0,\r\n          iterateStage: true\r\n        });\r\n      } else {\r\n        dispatch(experimentToggleAllSeven(), {\r\n          newSelectors: selectors,\r\n          throttle: 0\r\n        });\r\n      }\r\n    }),\r\n    createStage(() => {\r\n      console.log(`Run: ${count}`);\r\n      plan.conclude();\r\n      planNewStageSelectors.close();\r\n      setTimeout(() => {\r\n        done();\r\n      }, 50);\r\n    })\r\n  ]);\r\n});\r\n\r\n// [TESTING NOTE]\r\n// Interesting note about this test and jest, if the expect doesn't line up, the underlying implementation fowls up the processing order,\r\n// As if you set the tests to explicitly fail, the third stage will repeat over and over again despite the iterateStage...\r\n// This is a non-trivial example of an abstraction leaking an implementation detail towards the handling of expect in jest.\r\ntest('New Plan Options Priority Test', (done) => {\r\n  const planNewStagePriority = createAxium('Plan New Stage Priority Test', [\r\n    createExperimentPlanOptionsConcept()\r\n  ]);\r\n  let count = 0;\r\n  let planOneCount = 0;\r\n  const planOne = planNewStagePriority.plan('Ensure New Priority Can be set on a single stage', [\r\n    createStage((concepts, dispatch) => {\r\n      if (selectSlice(concepts, experimentPlanOptionsReadySelector)) {\r\n        console.log('Plan 1 Count: ', count, planOneCount);\r\n        if (planOneCount === 0) {\r\n          planOneCount++;\r\n          count++;\r\n          expect(count).toBe(1);\r\n          dispatch(experimentPlanOptionsAddValue({\r\n            newValue: 100,\r\n          }), {\r\n            throttle: 0,\r\n            newPriority: 2\r\n          });\r\n        } else {\r\n          planOneCount++;\r\n          count++;\r\n          expect(count).toBe(6);\r\n          dispatch(experimentPlanOptionsAddValue({\r\n            newValue: 100,\r\n          }), {\r\n            throttle: 0,\r\n            iterateStage: true,\r\n          });\r\n        }\r\n      }\r\n    }, { priority: 100 }),\r\n    createStage(() => {\r\n      planOne.conclude();\r\n      setTimeout(() => {\r\n        console.log('Test Conclude');\r\n        planNewStagePriority.close();\r\n        done();\r\n      }, 100);\r\n    })\r\n  ]);\r\n\r\n  let planTwoCount = 0;\r\n  const planTwo = planNewStagePriority.plan('Ensure New Priority Can be set on a single stage', [\r\n    createStage((concepts, dispatch) => {\r\n      if (selectSlice(concepts, experimentPlanOptionsReadySelector)) {\r\n        console.log('Plan 2 Count: ', count, planTwoCount);\r\n        if (planTwoCount === 0) {\r\n          planTwoCount++;\r\n          count++;\r\n          expect(count).toBe(2);\r\n          dispatch(experimentPlanOptionsAddValue({\r\n            newValue: 50,\r\n          }), {\r\n            throttle: 0,\r\n            newPriority: 3\r\n          });\r\n        } else {\r\n          planTwoCount++;\r\n          count++;\r\n          expect(count).toBe(5);\r\n          dispatch(experimentPlanOptionsAddValue({\r\n            newValue: 50,\r\n          }), {\r\n            throttle: 0,\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }\r\n    }, { priority: 50 }),\r\n    createStage(() => {\r\n      planTwo.conclude();\r\n    })\r\n  ]);\r\n\r\n  let planThreeCount = 0;\r\n  const planThree = planNewStagePriority.plan('Ensure New Priority Can be set on a single stage', [\r\n    createStage((concepts, dispatch) => {\r\n      if (selectSlice(concepts, experimentPlanOptionsReadySelector)) {\r\n        console.log('Plan 3 Count: ', count, planThreeCount);\r\n        if (planThreeCount === 0) {\r\n          planThreeCount++;\r\n          count++;\r\n          expect(count).toBe(3);\r\n          dispatch(experimentPlanOptionsAddValue({\r\n            newValue: 50,\r\n          }), {\r\n            throttle: 0,\r\n            newPriority: 5\r\n          });\r\n        } else {\r\n          planThreeCount++;\r\n          count++;\r\n          expect(count).toBe(4);\r\n          dispatch(experimentPlanOptionsAddValue({\r\n            newValue: 50,\r\n          }), {\r\n            throttle: 0,\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }\r\n    }, { priority: 5 }),\r\n    createStage(() => {\r\n      planThree.conclude();\r\n    })\r\n  ]);\r\n  planNewStagePriority.dispatch(experimentPlanOptionsIsReady());\r\n});"},"For the asynchronous graph programming framework Stratimux and based on the Experiment Concept, generate a quality that will Add a value property from\r\nthe incoming action's payload":{"type":"project","content":"import { Action, act } from '../../../model/action';\r\nimport { concept } from '../../../model/concept';\r\nimport { select } from '../../../model/selector';\r\nimport { ExperimentPriorityState } from '../priority.concept';\r\n\r\nexport const experimentPriorityAddValueType = 'experimentPriority Add value';\r\n\r\nexport type ExperimentPriorityAddValuePayload = {\r\n  newValue: number\r\n};\r\n\r\nexport const experimentPriorityAddValue =\r\n  act.prepareActionWithPayloadCreator<ExperimentPriorityAddValuePayload>(experimentPriorityAddValueType);\r\n\r\nfunction experimentPriorityAddValueReducer(state: ExperimentPriorityState, action: Action): ExperimentPriorityState {\r\n  const { newValue } = select.payLoad<ExperimentPriorityAddValuePayload>(action);\r\n  if (newValue) {\r\n    return {\r\n      ...state,\r\n      value: newValue + state.value\r\n    };\r\n  }\r\n  return {\r\n    ...state,\r\n  };\r\n}\r\n\r\nexport const experimentPriorityAddValueQuality = concept.createQuality(\r\n  experimentPriorityAddValueType,\r\n  experimentPriorityAddValueReducer,\r\n);"},"For the asynchronous graph programming framework Stratimux and based on the Experiment Concept, generate a quality that will set a ready property to true":{"type":"project","content":"import { Action, act } from '../../../model/action';\r\nimport { concept } from '../../../model/concept';\r\nimport { ExperimentPriorityState } from '../priority.concept';\r\n\r\nexport const experimentPriorityIsReadyType = 'experimentPriority is ready';\r\n\r\nexport const experimentPriorityIsReady = act.prepareActionCreator(experimentPriorityIsReadyType);\r\n\r\nfunction experimentPriorityIsReadyReducer(state: ExperimentPriorityState, action: Action): ExperimentPriorityState {\r\n  console.log('EXPERIMENT IS READY!!!');\r\n  return {\r\n    ...state,\r\n    ready: true\r\n  };\r\n}\r\n\r\nexport const experimentPriorityIsReadyQuality = concept.createQuality(\r\n  experimentPriorityIsReadyType,\r\n  experimentPriorityIsReadyReducer,\r\n);"},"For the asynchronous graph programming framework Stratimux and based on the Experiment Concept, generate a quality set a five property to true":{"type":"project","content":"import { Action, act } from '../../../model/action';\r\nimport { concept } from '../../../model/concept';\r\nimport { ExperimentPlanOptionsState } from '../newPlanOptions.concept';\r\n\r\nexport const experimentToggleAllSevenType = 'experimentPriority Add value';\r\n\r\nexport const experimentToggleAllSeven = act.prepareActionCreator(experimentToggleAllSevenType);\r\n\r\nfunction experimentToggleAllSevenReducer(state: ExperimentPlanOptionsState, action: Action): ExperimentPlanOptionsState {\r\n  return {\r\n    ...state,\r\n    one: !state.one,\r\n    two: !state.two,\r\n    three: !state.three,\r\n    four: !state.four,\r\n    five: !state.five,\r\n    six: !state.six,\r\n    seven: !state.seven\r\n  };\r\n}\r\n\r\nexport const experimentToggleAllSevenQuality = concept.createQuality(\r\n  experimentToggleAllSevenType,\r\n  experimentToggleAllSevenReducer,\r\n);"},"For the asynchronous graph programming framework Stratimux, generate a test that ensures that ActionStrategies are working as intended.\r\nIn addition utilize the onChange detection feature for the UnifiedSubject is working as intended.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { selectSlice, selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, countingStrategy, counterName } from '../concepts/counter/counter.concept';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { countingTopic } from '../concepts/counter/strategies/counting.strategy';\r\nimport { createStage } from '../model/stagePlanner';\r\nimport { counterSelectCount } from '../concepts/counter/counter.selector';\r\nimport { axiumSelectLastStrategy } from '../concepts/axium/axium.selector';\r\nimport { axiumKick } from '../concepts/axium/qualities/kick.quality';\r\nimport { initializeTopic } from '../concepts/axium/strategies/initialization.strategy';\r\nimport { Concepts } from '../model/concept';\r\n\r\ntest('Axium onChange Test', (done) => {\r\n  const selectorRouter = {\r\n    [axiumSelectLastStrategy.keys]: (concepts: Concepts) =>\r\n      console.log('CHECK: ', selectSlice(concepts, axiumSelectLastStrategy))\r\n  };\r\n  const axium = createAxium('axiumStrategyTest', [createCounterConcept()], true, true);\r\n  const plan = axium.plan('Counting Strategy Plan with selectors',\r\n    [\r\n      createStage((concepts, dispatch) => {\r\n        if (selectSlice(concepts, axiumSelectLastStrategy) === initializeTopic) {\r\n          dispatch(strategyBegin(countingStrategy()), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }, {selectors: [axiumSelectLastStrategy]}),\r\n      createStage((concepts, dispatch, changes) => {\r\n        console.log('Check Changes: ',  changes);\r\n        changes?.forEach(keyed => {\r\n          selectorRouter[keyed.keys] ? selectorRouter[keyed.keys](concepts) : null;\r\n        });\r\n        const axiumState = concepts[0].state as AxiumState;\r\n        const counter = selectState<CounterState>(concepts, counterName);\r\n        if (axiumState.lastStrategy === countingTopic) {\r\n          expect(counter?.count).toBe(1);\r\n          setTimeout(() => {done();}, 500);\r\n          plan.conclude();\r\n          axium.close();\r\n        } else {\r\n          dispatch(axiumKick(), {\r\n            newSelectors: [counterSelectCount, axiumSelectLastStrategy],\r\n            throttle: 0\r\n          });\r\n        }\r\n      }, {\r\n        selectors: [counterSelectCount]\r\n      })\r\n    ]);\r\n});"},"For the asynchronous graph programming framework Stratimux and Ownership Concept, devise a test that will ensure that the concept is working as intended.":{"type":"project","content":"import { createAxium  } from '../model/axium';\r\nimport { Concepts } from '../model/concept';\r\nimport { selectConcept, selectState } from '../model/selector';\r\nimport { OwnershipState, createOwnershipConcept, ownershipName } from '../concepts/ownership/ownership.concept';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { ownershipSetOwnerShipModeTopic } from '../concepts/ownership/strategies/setOwnerShipMode.strategy';\r\nimport { CounterState, counterName, createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { createExperimentState, createExperimentConcept } from '../concepts/experiment/experiment.concept';\r\nimport { experimentPuntCountingStrategy } from '../concepts/experiment/strategies/puntCounting.strategy';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport {\r\n  experimentPrimedCountingStrategy,\r\n  experimentCountingTopic,\r\n  experimentPrimedCountingTopic\r\n} from '../concepts/experiment/strategies/experimentCounting.strategy';\r\nimport { axiumLog } from '../concepts/axium/qualities/log.quality';\r\nimport { counterSetCount } from '../concepts/counter/qualities/setCount.quality';\r\nimport { experimentCheckInStrategyQuality } from '../concepts/experiment/qualities/checkInStrategy.quality';\r\nimport { experimentActionQuePrinciple } from '../concepts/experiment/experiment.principle';\r\nimport { createStage } from '../model/stagePlanner';\r\n\r\ntest('Ownership Test', (done) => {\r\n  const orderOfTopics: string[] = [];\r\n  let finalRun = true;\r\n  const axium = createAxium('ownershipTest', [\r\n    createOwnershipConcept(),\r\n    createCounterConcept(),\r\n    createExperimentConcept(createExperimentState(), [experimentCheckInStrategyQuality], [experimentActionQuePrinciple])\r\n  ], true, true);\r\n  const plan = axium.plan(\r\n    'Testing Ownership Staging', [\r\n      createStage((cpts, dispatch) => {\r\n        const axiumState = cpts[0].state as AxiumState;\r\n        if (axiumState.lastStrategy === ownershipSetOwnerShipModeTopic) {\r\n          const ownership = selectState<OwnershipState>(cpts, ownershipName);\r\n          if (ownership) {\r\n            console.log('Stage 1', ownership.ownershipLedger, ownership.pendingActions);\r\n            const counter = selectState<CounterState>(cpts, counterName);\r\n            console.log('Count: ', counter?.count);\r\n            // This will place a counting strategy in the experiment actionQue to be later dispatched.\r\n            //    Via its principle, to simulate an action moving off premise.\r\n            dispatch(strategyBegin(experimentPuntCountingStrategy()), {\r\n              iterateStage: true\r\n            });\r\n          }\r\n        }\r\n      }),\r\n      // Comment out if testing log and the halting quality of the Unified Turing Machine.\r\n      createStage((cpts, dispatch) => {\r\n        // Will be ran after both counting strategies conclude.\r\n        const ownership = selectState<OwnershipState>(cpts, ownershipName);\r\n        if (ownership) {\r\n          console.log('Stage 2', ownership.ownershipLedger, ownership.pendingActions);\r\n          dispatch(counterSetCount({newCount: 1000}, undefined, undefined, 7000), { iterateStage: true});\r\n        }\r\n      }),\r\n      createStage((cpts, dispatch) => {\r\n        const ownership = selectState<OwnershipState>(cpts, ownershipName);\r\n        if (ownership) {\r\n          console.log('Stage 3', ownership.ownershipLedger, ownership.pendingActions);\r\n          const counter = selectState<CounterState>(cpts, counterName);\r\n          console.log('Count: ', counter?.count);\r\n          dispatch(strategyBegin(experimentPrimedCountingStrategy(cpts)), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }),\r\n      createStage((cpts, dispatch) => {\r\n        const axiumState = cpts[0].state as AxiumState;\r\n        const counter = selectState<CounterState>(cpts, counterName);\r\n        if (counter) {\r\n          console.log('Stage 4', axiumState.lastStrategy, orderOfTopics, selectConcept(cpts, ownershipName)?.state);\r\n          if (orderOfTopics.length === 2 && finalRun) {\r\n            finalRun = false;\r\n            // This will be the final test to be triggered by a log action.\r\n            console.log('Stage 3, If #3 | Count: ', counter.count, orderOfTopics);\r\n            expect(orderOfTopics[0]).toBe(experimentCountingTopic);\r\n            expect(counter.count).toBe(3);\r\n            // Comment in if testing the halting ability of log and setCount stage is commented out.\r\n            // setTimeout(() => {done();}, 1000);\r\n            plan.conclude();\r\n          } else if (\r\n            (axiumState.lastStrategy === experimentCountingTopic ||\r\n            axiumState.lastStrategy === experimentPrimedCountingTopic) &&\r\n            orderOfTopics.length === 0) {\r\n            console.log('Stage 3, If #1 | Count: ', counter.count);\r\n            orderOfTopics.push(axiumState.lastStrategy);\r\n          } else if (\r\n            (axiumState.lastStrategy === experimentCountingTopic ||\r\n            axiumState.lastStrategy === experimentPrimedCountingTopic) &&\r\n            orderOfTopics.length === 1) {\r\n            if (orderOfTopics[0] !== axiumState.lastStrategy) {\r\n              console.log('Stage 3, If #2 | Count: ', counter.count);\r\n              orderOfTopics.push(axiumState.lastStrategy);\r\n              // Due to the halting behavior of a Unified Turing Machine, this will trigger before set Count at step 2.\r\n              //  If commented out, set Count will trigger the the \"If #3\" check.\r\n              //  If commenting out setCount stage, disable the test in the subscription\r\n              //    Then be sure to enabled the final done check in \"If #3\".\r\n              //    Then enabling the axiumLog dispatch will allow the test to conclude.\r\n              //    But disabling the axiumLog will never trigger the \"If #3\" check and disallow the test to conclude.\r\n              //      This proves Stratimux as a Unified Turing Machine and this configuration Halting Complete.\r\n              dispatch(axiumLog(), {\r\n                runOnce: true\r\n              });\r\n            }\r\n          }\r\n        }\r\n      })\r\n    ]);\r\n  const sub = axium.subscribe((concepts: Concepts) => {\r\n    const state = selectState<OwnershipState>(concepts, ownershipName);\r\n    if (state) {\r\n      const _axiumState = concepts[0].state as AxiumState;\r\n      if (state.initialized && _axiumState.lastStrategy === ownershipSetOwnerShipModeTopic) {\r\n        expect(state.initialized).toBe(true);\r\n      }\r\n      const counter = selectState<CounterState>(concepts, counterName);\r\n      // This will run last, despite setCount being the second staged dispatch.\r\n      if (counter && counter.count >= 1000) {\r\n        console.log('Subscription, Final Count: ', counter.count, orderOfTopics);\r\n        expect(counter.count).toBe(1000);\r\n        // Comment out if setCount stage is disabled and instead testing axiumLogs of \"If #2\" halting interaction.\r\n        setTimeout(() => {done();}, 1000);\r\n        sub.unsubscribe();\r\n        axium.close();\r\n      }\r\n    }\r\n  });\r\n});"},"For the asynchronous graph programming framework Stratimux and a Experiment Priority Concept, generate both possible selectors":{"type":"project","content":"import { experimentName } from '../../concepts/experiment/experiment.concept';\r\nimport { KeyedSelector, createConceptKeyedSelector } from '../../model/selector';\r\nimport { ExperimentPriorityState } from './priority.concept';\r\n\r\nexport const experimentPriorityReadySelector: KeyedSelector = createConceptKeyedSelector<ExperimentPriorityState>(experimentName, 'ready');\r\n\r\nexport const experimentPriorityValueSelector: KeyedSelector = createConceptKeyedSelector<ExperimentPriorityState>(experimentName, 'value');"},"For the asynchronous graph programming framework Stratimux generate a test that ensures that the priority aspect of the axium\r\nis managing plan notifications as intended.":{"type":"project","content":"import { axiumKick } from '../../concepts/axium/qualities/kick.quality';\r\nimport { experimentName } from '../../concepts/experiment/experiment.concept';\r\nimport { createAxium } from '../../model/axium';\r\nimport { select } from '../../model/selector';\r\nimport { StagePlanner, createStage } from '../../model/stagePlanner';\r\nimport { ExperimentPriorityState, createExperimentPriorityConcept } from './priority.concept';\r\nimport { experimentPriorityReadySelector, experimentPriorityValueSelector } from './priority.selector';\r\nimport { experimentPriorityIsReady } from './qualities/isReady.quality';\r\nimport { experimentPriorityAddValue } from './qualities/addValue.quality';\r\n\r\ntest('Priority Test', (done) => {\r\n  console.log('Priority Test');\r\n  let concluded = 0;\r\n  const finalize = () => {\r\n    if (concluded === 2) {\r\n      done();\r\n    } else {\r\n      concluded++;\r\n    }\r\n  };\r\n\r\n  const priorityTest = createAxium('Priority Test', [\r\n    createExperimentPriorityConcept()\r\n  ], true, true);\r\n\r\n  const firstStage = (name: string, priority: number) => createStage((concepts, dispatch, changes) => {\r\n    const priorityState = select.state<ExperimentPriorityState>(concepts, experimentName);\r\n    console.log('HIT: ', name, changes);\r\n    if (priorityState?.ready) {\r\n      console.log(`${name} Priority BEGIN`);\r\n      dispatch(axiumKick(), {\r\n        iterateStage: true\r\n      });\r\n    }\r\n  }, {selectors: [experimentPriorityReadySelector], priority});\r\n  const secondStage = (name: string, newValue: number, priority: number) => createStage((concepts, dispatch) => {\r\n    const priorityState = select.state<ExperimentPriorityState>(concepts, experimentName);\r\n    if (priorityState) {\r\n      console.log(`${name} Priority Base Value: `, priorityState.value);\r\n      dispatch(experimentPriorityAddValue({newValue}), {\r\n        iterateStage: true\r\n      });\r\n    }\r\n  }, {priority});\r\n  const thirdStage = (name: string, expected: number, priority: number) => createStage((concepts, dispatch) => {\r\n    const priorityState = select.state<ExperimentPriorityState>(concepts, experimentName);\r\n    if (priorityState) {\r\n      console.log(`${name} Incoming Value: ${priorityState.value}, expecting: ${expected}`);\r\n      expect(priorityState.value).toBe(expected);\r\n      dispatch(axiumKick(), {\r\n        iterateStage: true\r\n      });\r\n    }\r\n  }, {selectors: [experimentPriorityValueSelector], priority});\r\n  const concludePlan = (name: string, func: () => StagePlanner) => createStage(() => {\r\n    console.log(`${name} Priority END`);\r\n    func().conclude();\r\n    finalize();\r\n  });\r\n\r\n  const LOW = 'Low';\r\n  const LOW_PRIORITY = 1;\r\n  const low = priorityTest.plan(\r\n    'Low Priority Plan', [\r\n      firstStage(LOW, LOW_PRIORITY),\r\n      secondStage(LOW, 1, LOW_PRIORITY),\r\n      thirdStage(LOW, 111, LOW_PRIORITY),\r\n      concludePlan(LOW, () => low),\r\n    ]);\r\n  const HIGH = 'High';\r\n  const HIGH_PRIORITY = 100;\r\n  const high = priorityTest.plan(\r\n    'High Priority Plan', [\r\n      firstStage(HIGH, HIGH_PRIORITY),\r\n      secondStage(HIGH, 100, HIGH_PRIORITY),\r\n      thirdStage(HIGH, 100, HIGH_PRIORITY),\r\n      concludePlan(HIGH, () => high),\r\n    ]);\r\n  const MID = 'Mid';\r\n  const MID_PRIORITY = 50;\r\n  const mid = priorityTest.plan(\r\n    'Mid Priority Plan', [\r\n      firstStage(MID, MID_PRIORITY),\r\n      secondStage(MID, 10, MID_PRIORITY),\r\n      thirdStage(MID, 110, MID_PRIORITY),\r\n      concludePlan(MID, () => mid),\r\n    ]);\r\n  setTimeout(() => {\r\n    priorityTest.dispatch(experimentPriorityIsReady());\r\n  }, 1000);\r\n  priorityTest.subscribe(val => console.log('CHECK STATE: ', select.state(val, experimentName))); });"},"For the asynchronous graph programming framework Stratimux, generate a test to ensure that the axium can properly remove concepts from its current load.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { createCounterConcept, counterName } from '../concepts/counter/counter.concept';\r\nimport {\r\n  addConceptsToRemovalQueThenBlockStrategy,\r\n  removeConceptsViaQueThenUnblockTopic\r\n} from '../concepts/axium/strategies/removeConcept.strategy';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { forEachConcept } from '../model/concept';\r\nimport { createStage, stageWaitForOpenThenIterate } from '../model/stagePlanner';\r\nimport { axiumKick } from '../concepts/axium/qualities/kick.quality';\r\n\r\ntest('Axium remove Concepts Strategy Test', (done) => {\r\n  const axium = createAxium('axiumRemoveConceptsTest', [createCounterConcept()], true, true);\r\n  const plan = axium.plan('Remove Concepts Stage',[\r\n    stageWaitForOpenThenIterate(() => axiumKick()),\r\n    createStage((concepts, dispatch) => {\r\n      console.log('REMOVE');\r\n      dispatch(\r\n        strategyBegin(\r\n          addConceptsToRemovalQueThenBlockStrategy(concepts,[createCounterConcept()])\r\n        ), {\r\n          iterateStage: true\r\n        }\r\n      );\r\n    }),\r\n    createStage((concepts) => {\r\n      const axiumState = concepts[0].state as AxiumState;\r\n      console.log('VERIFY', axiumState.lastStrategy);\r\n      if (axiumState.lastStrategy === removeConceptsViaQueThenUnblockTopic) {\r\n        let exists = false;\r\n        forEachConcept(concepts, (concept => {\r\n          if (concept.name === counterName) {\r\n            exists = true;\r\n          }\r\n        }));\r\n        expect(exists).toBe(false);\r\n        setTimeout(() => {done();}, 500);\r\n        plan.conclude();\r\n        axium.close();\r\n      }\r\n    })\r\n  ]);\r\n});"},"For the asynchronous graph programming framework Stratimux,\r\ngenerate a test to that selectSlice is capable of performing shallow and deep state selections.":{"type":"project","content":"import { Concepts, createConcept } from '../model/concept';\r\nimport { KeyedSelector, assembleDynamicSelection, createUnifiedKeyedSelector, selectSlice } from '../model/selector';\r\n\r\nexport type BaseDataSet = {\r\n  prompt: string,\r\n  content: string,\r\n}\r\n\r\nexport type NamedDataSet = {\r\n  name: string,\r\n  dataSet: BaseDataSet[]\r\n}\r\n\r\nexport const generateBaseDataSetEntry = (): BaseDataSet => {\r\n  return {\r\n    prompt: '#insert prompt#',\r\n    content: '#insert chosen output#',\r\n  };\r\n};\r\n\r\nexport const generateDefaultNamedDataSet = (name: string): NamedDataSet => ({\r\n  name,\r\n  dataSet: [generateBaseDataSetEntry()]\r\n});\r\n\r\ntest('userInterfaceBindingsToString', (done) => {\r\n  const simulated = {\r\n    trainingData: [generateDefaultNamedDataSet('something')],\r\n    shallow: true,\r\n  };\r\n  const experiment = createConcept(\r\n    'experiment',\r\n    simulated\r\n  );\r\n  const concepts: Concepts = {\r\n    1: experiment\r\n  };\r\n  const entry = generateBaseDataSetEntry();\r\n  const selector = createUnifiedKeyedSelector<typeof simulated>(\r\n    concepts, 1,\r\n    assembleDynamicSelection(['trainingData', 0, 'dataSet', 0, 'prompt'])\r\n  );\r\n  const shallow = createUnifiedKeyedSelector<typeof simulated>(concepts, 1, 'shallow');\r\n\r\n  console.log('CHECK SHALLOW', shallow);\r\n  if (selector && shallow) {\r\n    expect(selectSlice(concepts, selector)).toBe(entry.prompt);\r\n    expect(selectSlice(concepts, shallow)).toBe(true);\r\n    done();\r\n  }\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test to ensure that the base selector consumer functions are working as intended.":{"type":"project","content":"import { createAxium  } from '../model/axium';\r\nimport { Concepts } from '../model/concept';\r\nimport { createUnifiedKeyedSelector, select, selectPayload, selectSlice, selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, counterName  } from '../concepts/counter/counter.concept';\r\nimport { counterSelectCount } from '../concepts/counter/counter.selector';\r\nimport { CounterSetCountPayload, counterSetCount } from '../concepts/counter/qualities/setCount.quality';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { createExperimentConcept, experimentName } from '../concepts/experiment/experiment.concept';\r\n\r\ntest('Axium Selector Test', (done) => {\r\n  const counter = createCounterConcept();\r\n  const counterState = counter.state as CounterState;\r\n  counterState.count = 10;\r\n  const axium = createAxium('axiumSelectorTest', [counter], true, true);\r\n  axium.subscribe((concepts: Concepts) => {\r\n    const state = selectState<CounterState>(concepts, counterName);\r\n    console.log('CHECK COUNT', state?.count);\r\n    expect(state?.count).toBe(10);\r\n    done();\r\n  });\r\n});\r\n\r\ntest('Axium Selector State Slice Test', (done) => {\r\n  const counter = createCounterConcept();\r\n  const counterState = counter.state as CounterState;\r\n  counterState.count = 10;\r\n  const axium = createAxium('axiumSelectorStateSlicedTest', [counter], true, true);\r\n  axium.subscribe((concepts: Concepts) => {\r\n    const count = selectSlice<number>(concepts, counterSelectCount);\r\n    expect(count).toBe(10);\r\n    setTimeout(() => {done();}, 500);\r\n  });\r\n});\r\n\r\ntest('Axium Selector Payload Test', (done) => {\r\n  const setCount = counterSetCount({newCount: 10 });\r\n  const payload = selectPayload<CounterSetCountPayload>(setCount);\r\n  expect(payload.newCount).toBe(10);\r\n  done();\r\n});\r\n\r\ntest('Axium Unified Selector Test', (done) => {\r\n  type SomeDeepObject = {\r\n    something : {\r\n      somethingElse: string,\r\n      somethingArray: string[]\r\n    },\r\n    else: boolean[]\r\n  }\r\n  type Deeper = {\r\n    anything : SomeDeepObject,\r\n    bool: boolean\r\n  }\r\n  const obj: Deeper = {\r\n    anything: {\r\n      else: [false],\r\n      something: {\r\n        somethingArray: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11'],\r\n        somethingElse: 'somethingElse'\r\n      }\r\n    },\r\n    bool: true\r\n  };\r\n  const experiment = createExperimentConcept(obj);\r\n  const concepts: Concepts = {\r\n    0: experiment\r\n  };\r\n  const selector = select.createUnifiedKeyedSelector<Deeper>(concepts, 0, 'anything.something.somethingArray', [10, 9, 8, 7]);\r\n  const conceptSelector = select.createConceptKeyedSelector<Deeper>(experimentName, 'anything.something.somethingElse');\r\n  if (selector) {\r\n    const slices = select.set<string[]>(concepts, selector);\r\n    console.log('CHECK SLICES', slices);\r\n    if (slices) {\r\n      expect(slices[0]).toBe('10');\r\n      expect(slices[1]).toBe('9');\r\n      expect(slices[2]).toBe('8');\r\n      expect(slices[3]).toBe('7');\r\n      expect(select.slice(concepts, conceptSelector)).toBe(obj.anything.something.somethingElse);\r\n      done();\r\n    }\r\n  }\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test that the setStageOption derivatives.are functioning as intended":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { selectSlice, selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, countingStrategy, counterName } from '../concepts/counter/counter.concept';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { countingTopic } from '../concepts/counter/strategies/counting.strategy';\r\nimport { createStage } from '../model/stagePlanner';\r\nimport { axiumSelectLastStrategy } from '../concepts/axium/axium.selector';\r\nimport { axiumKick } from '../concepts/axium/qualities/kick.quality';\r\nimport { initializeTopic } from '../concepts/axium/strategies/initialization.strategy';\r\n\r\ntest('Axium setStageSelectors Test', (done) => {\r\n  let tally = 0;\r\n  const axium = createAxium('axiumStrategyTest', [createCounterConcept()], true, true);\r\n  const plan = axium.plan('Counting Strategy Plan using setStageSelectors',\r\n    [\r\n      createStage((concepts, dispatch) => {\r\n        if (selectSlice(concepts, axiumSelectLastStrategy) === initializeTopic) {\r\n          dispatch(strategyBegin(countingStrategy()), {\r\n            iterateStage: true,\r\n            setStageSelectors: {\r\n              stage: 1,\r\n              selectors: [axiumSelectLastStrategy]\r\n            }\r\n          });\r\n        }\r\n      }, {selectors: [axiumSelectLastStrategy]}),\r\n      createStage((concepts, _, changes) => {\r\n        tally++;\r\n        if (tally === 1) {\r\n          expect(changes?.length).toBe(0);\r\n        }\r\n        const axiumState = concepts[0].state as AxiumState;\r\n        const counter = selectState<CounterState>(concepts, counterName);\r\n        if (axiumState.lastStrategy === countingTopic) {\r\n          expect(counter?.count).toBe(1);\r\n          expect(tally).toBe(2);\r\n          expect(changes?.length).toBe(1);\r\n          setTimeout(() => {done();}, 500);\r\n          plan.conclude();\r\n          axium.close();\r\n        }\r\n      })\r\n    ]);\r\n});\r\n\r\ntest('Axium setStageBeat Test', (done) => {\r\n  let tally = 0;\r\n  const axium = createAxium('axiumStrategyTest', [createCounterConcept()], true, true);\r\n  const plan = axium.plan('Counting Strategy Plan using setStageBeat',\r\n    [\r\n      createStage((concepts, dispatch) => {\r\n        if (selectSlice(concepts, axiumSelectLastStrategy) === initializeTopic) {\r\n          dispatch(strategyBegin(countingStrategy()), {\r\n            iterateStage: true,\r\n            setStageBeat: {\r\n              stage: 1,\r\n              beat: 300\r\n            }\r\n          });\r\n        }\r\n      }, {selectors: [axiumSelectLastStrategy]}),\r\n      createStage((concepts) => {\r\n        const axiumState = concepts[0].state as AxiumState;\r\n        tally++;\r\n        const counter = selectState<CounterState>(concepts, counterName);\r\n        if (axiumState.lastStrategy === countingTopic) {\r\n          expect(counter?.count).toBe(1);\r\n          expect(tally).toBe(2);\r\n          setTimeout(() => {done();}, 500);\r\n          plan.conclude();\r\n          axium.close();\r\n        }\r\n      })\r\n    ]);\r\n});\r\n\r\ntest('Axium setStagePriority Test', (done) => {\r\n  const axium = createAxium('axiumStrategyTest', [createCounterConcept()], true, true);\r\n  let ready = false;\r\n  let tally = 0;\r\n  const plan = axium.plan('Counting Strategy Plan using setStagePriority',\r\n    [\r\n      createStage((_, dispatch) => {\r\n        if (ready) {\r\n          dispatch(strategyBegin(countingStrategy()), {\r\n            iterateStage: true,\r\n            setStagePriority: {\r\n              stage: 1,\r\n              priority: 0\r\n            }\r\n          });\r\n        }\r\n      }, {selectors: [axiumSelectLastStrategy]}),\r\n      createStage(() => {\r\n        expect(tally).toBe(1);\r\n        tally++;\r\n        plan.conclude();\r\n      }, {\r\n        priority: Infinity\r\n      })\r\n    ]);\r\n  const planTwo = axium.plan('Counting Strategy Plan using setStagePriority Two',\r\n    [\r\n      createStage((_, dispatch) => {\r\n        if (ready) {\r\n          dispatch(strategyBegin(countingStrategy()), {\r\n            iterateStage: true,\r\n            setStagePriority: {\r\n              stage: 1,\r\n              priority: Infinity\r\n            }\r\n          });\r\n        }\r\n      }, {selectors: [axiumSelectLastStrategy]}),\r\n      createStage(() => {\r\n        expect(tally).toBe(0);\r\n        tally++;\r\n        setTimeout(() => {done();}, 500);\r\n        planTwo.conclude();\r\n        axium.close();\r\n      }, {\r\n        priority: 0\r\n      })\r\n    ]);\r\n  ready = true;\r\n  axium.dispatch(axiumKick());\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test to ensure the stage planner and its options are working as intended.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { selectSlice, selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, counterName } from '../concepts/counter/counter.concept';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { counterAdd } from '../concepts/counter/qualities/add.quality';\r\nimport { counterSubtract } from '../concepts/counter/qualities/subtract.quality';\r\nimport { counterSelectCount } from '../concepts/counter/counter.selector';\r\nimport { createStage } from '../model/stagePlanner';\r\n\r\ntest('Axium Stage Dispatch Options Test', (done) => {\r\n  let runCount = 0;\r\n  const axium = createAxium('axiumStageDispatchOptionsTest', [createCounterConcept()], true);\r\n  const sub = axium.subscribe((concepts) => {\r\n    const axiumState = concepts[0].state as AxiumState;\r\n    if (axiumState.badPlans.length > 0) {\r\n      const badPlan = axiumState.badPlans[0];\r\n      const counter = selectState<CounterState>(concepts, counterName);\r\n      console.log('Stage Ran Away, badPlans.length: ', axiumState.badPlans.length, 'Count: ', counter?.count);\r\n      plan.conclude();\r\n      sub.unsubscribe();\r\n      expect(badPlan.stageFailed).toBe(2);\r\n      expect(counter?.count).toBe(2);\r\n      setTimeout(() => {done();}, 500);\r\n    }\r\n  });\r\n  const plan = axium.plan('Stage DispatchOptions Test',\r\n    [\r\n      createStage((concepts, dispatch) => {\r\n        const counter = selectState<CounterState>(concepts, counterName);\r\n        console.log('Stage 1 ', counter, runCount);\r\n        dispatch(counterAdd(), {\r\n          iterateStage: true\r\n        });\r\n      }),\r\n      createStage((concepts, dispatch) => {\r\n        runCount++;\r\n        const counter = selectState<CounterState>(concepts, counterName);\r\n        console.log('Stage 2 ', counter, runCount);\r\n        // Sets count to 2 and only runs once per state update\r\n        dispatch(counterAdd(), {\r\n          runOnce: true\r\n        });\r\n        // Will wait until count is set to 2, then set the Stage Explicitly to the third Step counting from 0.\r\n        if (selectSlice(concepts, counterSelectCount) === 2) {\r\n          dispatch(counterAdd(), {\r\n            setStage: 2,\r\n            // Requires throttle, because the previous action is of the same type, but runs only once.\r\n            throttle: 1\r\n          });\r\n        }\r\n        // }\r\n      }),\r\n      createStage((concepts, dispatch) => {\r\n        runCount++;\r\n        const counter = selectState<CounterState>(concepts, counterName);\r\n        console.log('Should run twice, Stage 3 ', counter, runCount);\r\n        // Will cause an action overflow forcing the stage to close and add itself to badPlans\r\n        dispatch(counterSubtract(), {\r\n          // Enabling will cause this test to timeout via the subscription watching for badPlans to never be ran.\r\n          // throttle: 500\r\n          // This demonstrates the fault resistance of the Stage paradigm, despite Stratimux's recursive functionality.\r\n        });\r\n        // This dispatch will be invalidated and never dispatched due to the effect of action overflow of the above.\r\n        dispatch(counterAdd(), {});\r\n        console.log(\r\n          'Will also run twice. 1st will be before \"Stage Ran Away,\"',\r\n          'and after \"Should run twice.\" The 2nd will be final console log output.'\r\n        );\r\n      })\r\n    ]);\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test to ensure that you can create a stage planner within a concept's principle.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { selectState } from '../model/selector';\r\nimport { createExperimentConcept, experimentName } from '../concepts/experiment/experiment.concept';\r\nimport { PrincipleFunction } from '../model/principle';\r\nimport { Action, ActionType, prepareActionCreator } from '../model/action';\r\nimport { Subscriber } from 'rxjs';\r\nimport { Concepts, createQuality } from '../model/concept';\r\nimport { UnifiedSubject, createStage, stageWaitForOpenThenIterate } from '../model/stagePlanner';\r\nimport { axiumPreClose } from '../concepts/axium/qualities/preClose.quality';\r\n\r\ntype ExperimentState = {\r\n  mock: boolean;\r\n};\r\n\r\nconst createExperimentState = (): ExperimentState => ({ mock: false });\r\n\r\nconst experimentMockToTrueType: ActionType = 'Experiment set mock to True';\r\nconst experimentMockToTrue = prepareActionCreator(experimentMockToTrueType);\r\nfunction experimentMockToTrueReducer(state: ExperimentState, action: Action): ExperimentState {\r\n  return {\r\n    ...state,\r\n    mock: true\r\n  };\r\n}\r\nconst experimentMockToTrueQuality = createQuality(experimentMockToTrueType, experimentMockToTrueReducer);\r\n\r\ntest('Axium Principle Stage', (done) => {\r\n  const experimentPrinciple: PrincipleFunction = (_: Subscriber<Action>, __: Concepts, concept$: UnifiedSubject) => {\r\n    const plan = concept$.plan('Experiment Principle', [\r\n      stageWaitForOpenThenIterate(() => experimentMockToTrue()),\r\n      createStage((concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState?.mock) {\r\n          expect(experimentState.mock).toBe(true);\r\n          setTimeout(() => done(), 1000);\r\n          dispatch(axiumPreClose({exit: false}), {\r\n            iterateStage: true\r\n          });\r\n          plan.conclude();\r\n        }\r\n      }),\r\n      createStage(() => {\r\n        //\r\n      })\r\n    ]);\r\n  };\r\n  createAxium('axiumStrategyTest', [\r\n    createExperimentConcept(createExperimentState(), [experimentMockToTrueQuality], [experimentPrinciple])\r\n  ], true, true);\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test to ensure that you can create a stage planner that sets the beat parameter\r\nof the plan. The beat will ensure that within a span of time the first notification of state change will be observed.\r\nBut any new additional changes to state will be debounced for the beat duration.\r\nBut if the beat has not been notified for a period. The first notification will go through and start this process over again.\r\nThis is a combination of throttle and debounce.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { selectSlice, selectState } from '../model/selector';\r\nimport { axiumSelectOpen } from '../concepts/axium/axium.selector';\r\nimport { axiumPreClose } from '../concepts/axium/qualities/preClose.quality';\r\nimport { axiumKick } from '../concepts/axium/qualities/kick.quality';\r\nimport { CounterState, counterName, createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { counterAdd } from '../concepts/counter/qualities/add.quality';\r\nimport { createStage, stageWaitForOpenThenIterate } from '../model/stagePlanner';\r\njest.setTimeout(10000);\r\n\r\ntest('Stage Planner Beat Test', (done) => {\r\n  let timerActive = false;\r\n  const axium = createAxium('axium test stage planner beat', [\r\n    createCounterConcept()\r\n  ], true, true);\r\n  const beat = 105;\r\n  const plan = axium.plan('Stage Planner Beat Test', [\r\n    stageWaitForOpenThenIterate(() => axiumKick()),\r\n    createStage((concepts, dispatch) => {\r\n      console.log('HIT 1');\r\n      timerActive = true;\r\n      setTimeout(() => {\r\n        console.log('FIRE');\r\n        timerActive = false;\r\n      }, 1000);\r\n      if (selectSlice(concepts, axiumSelectOpen)) {\r\n        dispatch(axiumKick(), {\r\n          iterateStage: true,\r\n        });\r\n      }\r\n    }, {beat}),\r\n    createStage((___, dispatch) => {\r\n      console.log('HIT 2');\r\n      dispatch(counterAdd(), {\r\n        iterateStage: true\r\n      });\r\n    }, {beat}),\r\n    createStage((concepts, dispatch) => {\r\n      // console.log('HIT 3', timerActive, selectState<CounterState>(concepts, counterName));\r\n      if (!timerActive) {\r\n        const state = selectState<CounterState>(concepts, counterName);\r\n        if (state) {\r\n          expect(state.count).toBe(9);\r\n          setTimeout(() => done(), 1000);\r\n          dispatch(axiumPreClose({exit: false}), {\r\n            iterateStage: true\r\n          });\r\n          plan.conclude();\r\n        }\r\n      } else {\r\n        dispatch(counterAdd(), {\r\n          throttle: 1\r\n        });\r\n      }\r\n    }, {beat}),\r\n    createStage(() => {\r\n      console.log('HIT 4');\r\n      //\r\n    }, {beat})\r\n  ]);\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test that ensures that ActionStrategies are working as intended.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, countingStrategy, counterName } from '../concepts/counter/counter.concept';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { countingTopic } from '../concepts/counter/strategies/counting.strategy';\r\nimport { createStage } from '../model/stagePlanner';\r\n\r\ntest('Axium Counting Strategy Test', (done) => {\r\n  const axium = createAxium('axiumStrategyTest', [createCounterConcept()], true, true);\r\n  const plan = axium.plan('Counting Strategy Plan',\r\n    [\r\n      createStage((_, dispatch) => {\r\n        dispatch(strategyBegin(countingStrategy()), {\r\n          iterateStage: true\r\n        });\r\n      }),\r\n      createStage((concepts) => {\r\n        const axiumState = concepts[0].state as AxiumState;\r\n        if (axiumState.lastStrategy === countingTopic) {\r\n          const counter = selectState<CounterState>(concepts, counterName);\r\n          expect(counter?.count).toBe(1);\r\n          setTimeout(() => {done();}, 500);\r\n          plan.conclude();\r\n          axium.close();\r\n        }\r\n      })\r\n    ]);\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test that ensures that throttle method helper functions are working as intended.":{"type":"project","content":"import { axiumSelectLastStrategy, axiumSelectLastStrategyData } from '../concepts/axium/axium.selector';\r\nimport { axiumKick } from '../concepts/axium/qualities/kick.quality';\r\nimport { axiumLog } from '../concepts/axium/qualities/log.quality';\r\nimport { ExperimentState, createExperimentConcept, createExperimentState, experimentName } from '../concepts/experiment/experiment.concept';\r\nimport {\r\n  experimentThrottleAsyncIterateIdThenReceiveInMethodQuality\r\n} from '../concepts/experiment/qualities/throttleAsyncIterateIdThenReceiveInMethod.quality';\r\nimport {\r\n  ExperimentThrottleIterateIdThenReceiveInMethodPayload,\r\n  experimentThrottleIterateIdThenReceiveInMethodQuality\r\n} from '../concepts/experiment/qualities/throttleIterateIdThenReceiveInMethod.quality';\r\n\r\nimport {\r\n  experimentThrottleAsyncIterateIdThenAddToData,\r\n  experimentThrottleAsyncIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/throttleAsyncIterateIdThenAddToData.strategy';\r\nimport {\r\n  experimentThrottleIterateIdThenAddToData,\r\n  experimentThrottleIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/throttleIterateIdThenAddToData.strategy';\r\n\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { createAxium, getAxiumState } from '../model/axium';\r\nimport { selectSlice, selectState } from '../model/selector';\r\nimport { createStage, stageWaitForOpenThenIterate } from '../model/stagePlanner';\r\n\r\ntest('Action Throttle Method Test with Concepts id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentThrottleIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.plan('Throttle Iterate id with Concepts', [\r\n    stageWaitForOpenThenIterate(() => axiumKick()),\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        dispatch(strategyBegin(experimentThrottleIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Action Throttle: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentThrottleIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Action Throttle: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentThrottleIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState & ExperimentThrottleIterateIdThenReceiveInMethodPayload>(\r\n          concepts,\r\n          axiumSelectLastStrategyData\r\n        );\r\n        console.log('Action Throttle: ', experimentState.id, lastStrategy, data);\r\n        console.log('What case', lastStrategy === experimentThrottleIterateIdThenAddToDataTopic);\r\n        if (lastStrategy === experimentThrottleIterateIdThenAddToDataTopic) {\r\n          console.log('Huh case');\r\n          if (data) {\r\n            console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n            plan.conclude();\r\n            expect(data.id).toBe(0);\r\n            expect(data.setId).toBe(0);\r\n            expect(experimentState.id).toBe(3);\r\n            axium.close();\r\n            done();\r\n          }\r\n        }\r\n      }\r\n    })\r\n  ]);\r\n});\r\n\r\njest.setTimeout(7000);\r\ntest('Action Throttle Async Method Test with Concepts id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentThrottleAsyncIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.plan('Action Throttle Async Iterate id with Concepts', [\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        dispatch(strategyBegin(experimentThrottleAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Async Action Throttle: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentThrottleAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Async Action Throttle: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentThrottleAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    }),\r\n    createStage((concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState & ExperimentThrottleIterateIdThenReceiveInMethodPayload>(\r\n          concepts,\r\n          axiumSelectLastStrategyData\r\n        );\r\n        console.log('Last Async Action Throttle: ', experimentState.id, lastStrategy, data, concepts);\r\n        if (lastStrategy === experimentThrottleAsyncIterateIdThenAddToDataTopic) {\r\n          if (data) {\r\n            console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n            expect(data.id).toBe(0);\r\n            expect(data.setId).toBe(0);\r\n            expect(experimentState.id).toBe(3);\r\n            plan.conclude();\r\n          }\r\n        }\r\n      }\r\n    })\r\n  ]);\r\n  setTimeout(() => {\r\n    const secondPlan = axium.plan('Action Throttle Async Iterate id with Concepts', [\r\n      createStage((concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const strategy = experimentThrottleAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }),\r\n      createStage((concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('Async Action Throttle: ', experimentState.id, lastStrategy, data);\r\n          const strategy = experimentThrottleAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }),\r\n      createStage((concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('Async Action Throttle: ', experimentState.id, lastStrategy, data);\r\n          const strategy = experimentThrottleAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      }),\r\n      createStage((concepts, _) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState & ExperimentThrottleIterateIdThenReceiveInMethodPayload>(\r\n            concepts,\r\n            axiumSelectLastStrategyData\r\n          );\r\n          console.log('2 Last Async Action Throttle: ', experimentState.id, lastStrategy, data, concepts);\r\n          if (lastStrategy === experimentThrottleAsyncIterateIdThenAddToDataTopic + 2) {\r\n            if (data) {\r\n              console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n              expect(data.id).toBe(3);\r\n              expect(data.setId).toBe(3);\r\n              expect(experimentState.id).toBe(6);\r\n              secondPlan.conclude();\r\n              axium.close();\r\n              done();\r\n            }\r\n          }\r\n        }\r\n      })\r\n    ]);\r\n    axium.dispatch(axiumKick());\r\n  }, 1000);\r\n});"},"For the asynchronous graph programming framework Stratimux, generate a test that ensures that unified concepts inherit their unified names as intended.":{"type":"project","content":"import { createConcept, unifyConcepts } from '../model/concept';\r\n\r\ntest('Unified Names Test', (done) => {\r\n  const one = createConcept(\r\n    'one',\r\n    {},\r\n  );\r\n  const two = createConcept(\r\n    'two',\r\n    {},\r\n  );\r\n  const three = createConcept(\r\n    'three',\r\n    {},\r\n  );\r\n  const four = createConcept(\r\n    'four',\r\n    {},\r\n  );\r\n  const five = createConcept(\r\n    'five',\r\n    {},\r\n  );\r\n  const unified = unifyConcepts([\r\n    one, two, two, three, four, five, five\r\n  ],\r\n  createConcept('unified', {})\r\n  );\r\n  console.log('CHECK UNIFIED', unified.unified, unified);\r\n  expect(unified.unified.length).toBe([one, two, three, four, five].length);\r\n  done();\r\n});"},"For the asynchronous graph programming framework Stratimux,\r\ngenerate a test that ensures that the functionality of different state selector consumer functions.\r\nThat specifically you can utilize the incoming semaphore to create new KeyedSelectors, or update old ones.":{"type":"project","content":"import { CounterState, counterName, createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { createAxium } from '../model/axium';\r\nimport {\r\n  KeyedSelector,\r\n  createConceptKeyedSelector,\r\n  createUnifiedKeyedSelector,\r\n  select,\r\n  selectSlice,\r\n  updateUnifiedKeyedSelector\r\n} from '../model/selector';\r\nimport { createStage } from '../model/stagePlanner';\r\n\r\ntest('Unified Selector Test', (done) => {\r\n  const axium = createAxium('Selector Test via Counter', [\r\n    createCounterConcept()\r\n  ], true, true);\r\n  const plan = axium.plan('Plan: Counter Selector', [\r\n    createStage((concepts, _) => {\r\n      console.log('FIRED!!!');\r\n      const concept = createConceptKeyedSelector<CounterState>(counterName, 'count');\r\n      const updated = updateUnifiedKeyedSelector(concepts, 1, concept) as KeyedSelector;\r\n      const unified = createUnifiedKeyedSelector<CounterState>(concepts, 1, 'count') as KeyedSelector;\r\n      console.log('CHECK SELECTORS', concept, updated, unified);\r\n      expect(select.slice(concepts, updated)).toBe(0);\r\n      expect(select.slice(concepts, concept)).toBe(0);\r\n      expect(select.slice(concepts, unified)).toBe(0);\r\n      setTimeout(() => done(), 0);\r\n      plan.conclude();\r\n    }),\r\n  ]);\r\n});"}}