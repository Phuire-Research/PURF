{"For the graph programming framework Stratimux and Axium Concept, generate the two default modes required for the Axium to function.":{"type":"project","content":"import { Subject } from 'rxjs';\r\nimport { Concepts, Mode } from '../../model/concept';\r\nimport { Action, primeAction } from '../../model/action';\r\nimport { AxiumState } from './axium.concept';\r\nimport { UnifiedSubject } from '../../model/stagePlanner';\r\nimport { AxiumBadActionPayload } from './qualities/badAction.quality';\r\n\r\nexport const isActionable = (axiumState: AxiumState, action: Action): boolean => {\r\n  let actionable = true;\r\n  // We are logically determining these semaphore values by hand for now.\r\n  if (\r\n    // Logical Determination: axiumBadActionType\r\n    action.semaphore[3] === 1 ||\r\n    // Logical Determination: axiumConcludeType\r\n    action.semaphore[3] === 3) {\r\n    actionable = false;\r\n    if (axiumState.logging && action.semaphore[3] === 1) {\r\n      console.warn('Bad Action', action);\r\n    }\r\n  }\r\n  return actionable;\r\n};\r\n\r\nexport const permissiveMode: Mode = (\r\n  [action, concepts, action$, concepts$] : [Action, Concepts, Subject<Action>, UnifiedSubject]\r\n) => {\r\n  const axiumState = concepts[0].state as AxiumState;\r\n  if (isActionable(axiumState, action)) {\r\n    // Logical Determination: axiumSetBlockingModeType\r\n    if (action.semaphore[3] !== 4) {\r\n      if (action.semaphore[2] === axiumState.generation && action.expiration > Date.now()) {\r\n        let subject: Subject<Action>;\r\n        if (concepts[action.semaphore[0]].qualities[action.semaphore[1]].method) {\r\n          subject = concepts[action.semaphore[0]].qualities[action.semaphore[1]].subject as Subject<Action>;\r\n          subject.next(action);\r\n        }\r\n        const reduce = concepts[action.semaphore[0]].qualities[action.semaphore[1]].reducer;\r\n        const state = concepts[action.semaphore[0]].state;\r\n        concepts[action.semaphore[0]].state = reduce(state, action);\r\n        concepts$.next(concepts);\r\n        axiumState.subConcepts$.next(concepts);\r\n      } else {\r\n        const nextAction = primeAction(concepts, action);\r\n        // Logical Determination: axiumBadActionType\r\n        if (nextAction.semaphore[3] === 1) {\r\n          const payload: AxiumBadActionPayload = {badActions: [action]};\r\n          nextAction.payload = payload;\r\n        }\r\n        if (nextAction.semaphore[2] === axiumState.generation) {\r\n          action$.next(nextAction);\r\n        }\r\n      }\r\n    } else {\r\n      blockingMode([action, concepts, action$, concepts$]);\r\n    }\r\n  }\r\n};\r\n\r\n// Note that Methods are altered during this Mode if the Axium is created in a Synchronous Context\r\n//  Thus the Reducer needs to Run before the Method\r\nexport const blockingMode: Mode = (\r\n  [action, concepts, action$, concepts$] : [Action, Concepts, Subject<Action>, UnifiedSubject]\r\n) => {\r\n  const axiumState = concepts[0].state as AxiumState;\r\n  if (isActionable(axiumState, action)) {\r\n    if (action.semaphore[2] === axiumState.generation && action.expiration > Date.now()) {\r\n      const reduce = concepts[action.semaphore[0]].qualities[action.semaphore[1]].reducer;\r\n      const state = concepts[action.semaphore[0]].state;\r\n      concepts[action.semaphore[0]].state = reduce(state, action);\r\n      axiumState.innerConcepts$.next(concepts);\r\n      let subject: Subject<Action>;\r\n      if (concepts[action.semaphore[0]].qualities[action.semaphore[1]].method) {\r\n        subject = concepts[action.semaphore[0]].qualities[action.semaphore[1]].subject as Subject<Action>;\r\n        subject.next(action);\r\n      }\r\n    } else {\r\n      const nextAction = primeAction(concepts, action);\r\n      // Logical Determination: axiumBadActionType\r\n      if (nextAction.semaphore[3] === 1) {\r\n        const payload = {...action};\r\n        nextAction.payload = payload;\r\n      }\r\n      if (nextAction.semaphore[2] === axiumState.generation) {\r\n        blockingMode([\r\n          nextAction,\r\n          concepts,\r\n          action$,\r\n          concepts$\r\n        ]);\r\n      }\r\n    }\r\n  }\r\n};"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a principle that will allow for the modification of the Axium's loaded concepts.":{"type":"project","content":"import { Observable, Subscriber, catchError } from 'rxjs';\r\nimport { Concepts, Mode, forEachConcept } from '../../model/concept';\r\nimport { PrincipleFunction, createPrinciple$, registerPrincipleSubscription } from '../../model/principle';\r\nimport { Action, createCacheSemaphores } from '../../model/action';\r\nimport { AxiumState, axiumName } from './axium.concept';\r\nimport { strategyBegin } from '../../model/actionStrategy';\r\nimport { addConceptsFromQueThenUnblockStrategy } from './strategies/addConcept.strategy';\r\nimport { removeConceptsViaQueThenUnblockStrategy } from './strategies/removeConcept.strategy';\r\nimport { blockingMode, permissiveMode } from './axium.mode';\r\nimport { UnifiedSubject } from '../../model/stagePlanner';\r\nimport { blockingMethodSubscription } from '../../model/axium';\r\n\r\nexport const axiumPrinciple: PrincipleFunction = (\r\n  observer: Subscriber<Action>,\r\n  concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  _: number\r\n) => {\r\n  let allowAdd = true;\r\n  let allowRemove = true;\r\n  const subscription = concepts$.subscribe(_concepts => {\r\n    const axiumState = _concepts[0].state as AxiumState;\r\n    if (axiumState.addConceptQue.length === 0) {\r\n      allowAdd = true;\r\n    }\r\n    if (axiumState.addConceptQue.length !== 0 && allowAdd) {\r\n      allowAdd = false;\r\n      axiumState.generation += 1;\r\n      const newConcepts: Concepts = {};\r\n      forEachConcept(concepts, (concept, s) => {\r\n        newConcepts[Number(s)] = concept;\r\n      });\r\n\r\n      axiumState.addConceptQue.forEach((concept, _index) => {\r\n        concept.semaphore = axiumState.conceptCounter;\r\n        if (concept.mode !== undefined) {\r\n          const names = axiumState.modeNames;\r\n          const modes = concepts[0].mode as Mode[];\r\n          concept.mode.forEach((mode: Mode) => {\r\n            modes.push(mode);\r\n            names.push(concept.name);\r\n          });\r\n        }\r\n        if (concept.principles !== undefined) {\r\n          concept.principles.forEach(principle => {\r\n            const observable = createPrinciple$(principle, concepts, axiumState.concepts$, concept.semaphore);\r\n            axiumState.principleSubscribers.push({\r\n              name: concept.name,\r\n              subscription: observable.subscribe((action: Action) => axiumState.action$.next(action)) as Subscriber<Action>\r\n            });\r\n          });\r\n        }\r\n        newConcepts[concept.semaphore] = concept;\r\n        axiumState.conceptCounter += 1;\r\n      });\r\n\r\n      const newAxiumState = newConcepts[0].state as AxiumState;\r\n      newAxiumState.cachedSemaphores = createCacheSemaphores(newConcepts);\r\n\r\n      axiumState.concepts$?.next(newConcepts);\r\n\r\n      observer.next(strategyBegin(\r\n        addConceptsFromQueThenUnblockStrategy(newConcepts)\r\n      ));\r\n    }\r\n    if (axiumState.removeConceptQue.length === 0) {\r\n      allowRemove = true;\r\n    }\r\n    if (axiumState.removeConceptQue.length > 0 && allowRemove) {\r\n      allowRemove = false;\r\n      const newConcepts: Concepts = {};\r\n      axiumState.generation += 1;\r\n      const newModes: Mode[] = [blockingMode, permissiveMode];\r\n      const newModeNames: string[] = [axiumName, axiumName];\r\n      forEachConcept(concepts, ((concept, s) => {\r\n        axiumState.removeConceptQue.forEach(target => {\r\n          if (concept.name !== target.name) {\r\n            newConcepts[s as number] = (concept);\r\n          }\r\n        });\r\n      }));\r\n      const newAxiumState = newConcepts[0].state as AxiumState;\r\n      newAxiumState.modeNames.forEach((modeName, modeIndex) => {\r\n        let shouldAdd = false;\r\n        axiumState.removeConceptQue.forEach(removeTarget => {\r\n          if (modeName !== axiumName) {\r\n            if (modeName !== removeTarget.name) {\r\n              shouldAdd = true;\r\n            } else if (modeName === removeTarget.name && modeIndex === newAxiumState.defaultModeIndex) {\r\n              newAxiumState.defaultModeIndex = 1;\r\n            }\r\n          }\r\n        });\r\n        if (shouldAdd) {\r\n          newModeNames.push(modeName);\r\n          newModes.push((concepts[0].mode as Mode[])[modeIndex]);\r\n        }\r\n        shouldAdd = false;\r\n      });\r\n      newConcepts[0].mode = newModes;\r\n      newAxiumState.modeNames = newModeNames;\r\n\r\n      newAxiumState.cachedSemaphores = createCacheSemaphores(newConcepts);\r\n      newAxiumState.methodSubscribers.forEach(named => {\r\n        named.subscription.unsubscribe();\r\n      });\r\n      newAxiumState.methodSubscribers = [];\r\n\r\n      forEachConcept(newConcepts, (concept, s) => {\r\n        concept.qualities.forEach(quality => {\r\n          if (quality.methodCreator) {\r\n            const [method, subject] = quality.methodCreator(axiumState.concepts$, s);\r\n            quality.method = method;\r\n            quality.subject = subject;\r\n            quality.method.pipe(\r\n              catchError((err: unknown, caught: Observable<Action>) => {\r\n                if (axiumState.logging) {\r\n                  console.error('METHOD ERROR', err);\r\n                }\r\n                return caught;\r\n              }));\r\n            const methodSub = quality.method.subscribe((action: Action) => {\r\n              console.log('HIT');\r\n              blockingMethodSubscription(axiumState.action$, action);\r\n            }) as Subscriber<Action>;\r\n            const _axiumState = newConcepts[0].state as AxiumState;\r\n            _axiumState.methodSubscribers.push({\r\n              name: concept.name,\r\n              subscription: methodSub,\r\n            });\r\n          }\r\n        });\r\n      });\r\n      axiumState.concepts$.next(newConcepts);\r\n\r\n      observer.next(strategyBegin(\r\n        removeConceptsViaQueThenUnblockStrategy(newConcepts)\r\n      ));\r\n    }\r\n  });\r\n  registerPrincipleSubscription(observer, concepts, axiumName, subscription);\r\n};"},"For the graph programming framework Stratimux and Axium Concept, generate a series of KeyedSelectors for the AxiumState.":{"type":"project","content":"import { KeyedSelector } from '../../model/selector';\r\n\r\nexport const axiumSelectOpen: KeyedSelector = {\r\n  conceptName: 'axium',\r\n  stateKeys: 'open',\r\n};\r\n\r\nexport const axiumSelectLastStrategy: KeyedSelector = {\r\n  conceptName: 'axium',\r\n  stateKeys: 'lastStrategy',\r\n};\r\n\r\nexport const axiumSelectLastStrategyData: KeyedSelector = {\r\n  conceptName: 'axium',\r\n  stateKeys: 'lastStrategyData',\r\n};\r\n\r\nexport const axiumSelectLastStrategyDialog: KeyedSelector = {\r\n  conceptName: 'axium',\r\n  stateKeys: 'lastStrategyDialog',\r\n};\r\n\r\nexport const axiumSelectBadPlans: KeyedSelector = {\r\n  conceptName: 'axium',\r\n  stateKeys: 'badPlans',\r\n};\r\n\r\nexport const axiumSelectBadActions: KeyedSelector = {\r\n  conceptName: 'axium',\r\n  stateKeys: 'badActions',\r\n};"},"For the graph programming framework Stratimux and Axium Concept, generate a model file that specifies the gather action node concept.\r\nThis concept allows for action nodes to be linked into a sequence based on a provided actions parameter.\r\nNote this should be limited to actions that provably do not require error correction.\r\nOtherwise you would want to use a Strategy Stitch instead.":{"type":"project","content":"import { Action } from '../../../model/action';\r\nimport { ActionNode, ActionNodeOptions, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { axiumLog } from '../qualities/log.quality';\r\n\r\nexport type AxiumGatherNode = {\r\n  actions: Action[],\r\n  last?: ActionNode,\r\n}\r\n/**\r\n * Must used to create a uniform sequence of actions, note that these actions can be primed with a payload.\r\n * @param actions Sequence of actions to be gathered.\r\n * @param options `optional` Must be a union of paired options correlated in order to the provided actions.\r\n * Noting that success nodes will be overridden if passed.\r\n * @param last `optional` This will be set as the gathered actions final step.\r\n * You may use this to continue a strategy after the gathered actions have concluded.\r\n * @returns ActionNode of axiumStitch\r\n */\r\nexport const axium_createGatherNode = (props: AxiumGatherNode, options?: ActionNodeOptions[]) => {\r\n  const {\r\n    actions,\r\n    last,\r\n  } = props;\r\n  let first;\r\n  let previous;\r\n  const defaultOptions = {\r\n    successNode: null,\r\n    failureNode: null\r\n  };\r\n  for (const [i, act] of actions.entries()) {\r\n    const opt = options ? options[i] : undefined;\r\n    if (first === undefined) {\r\n      first = createActionNode(act, opt ? opt : {...defaultOptions});\r\n      previous = first;\r\n    } else if (previous !== undefined) {\r\n      const next = createActionNode(act, opt ? opt : {...defaultOptions});\r\n      previous.successNode = next;\r\n      previous = next;\r\n    }\r\n  }\r\n  if (previous !== undefined && last !== undefined) {\r\n    previous.successNode = last;\r\n  }\r\n  if (first) {\r\n    return first;\r\n  } else {\r\n    const log = axiumLog();\r\n    log.payload = {message: 'NO ACTIONS WERE GATHERED VIA AXIUM_CREATE_GATHER_NODE'};\r\n    return createActionNode(log, {\r\n      successNode: null,\r\n      failureNode: null\r\n    });\r\n  }\r\n};\r\n\r\nexport type AxiumGatherStrategy = {\r\n  actions: Action[],\r\n  last?: ActionNode,\r\n  topic?: string\r\n}\r\n/**\r\n * Creates a strategy that will execute a sequence of actions that can be primed with a payload.\r\n * @param actions Sequence of actions to be gathered.\r\n * @param last `optional` This will be set as the gathered actions final step.\r\n * @param topic `optional` Will set the topic of the returned strategy.\r\n * You may use this to continue a strategy after the gathered actions have concluded.\r\n * @param options `optional` Must be a union of paired options correlated in order to the provided actions.\r\n * Noting that success nodes will be overridden if passed.\r\n\r\n * @returns ActionStrategy of the provided actions to be executed in a sequence.\r\n */\r\nexport const axium_createGatherStrategy = (props: AxiumGatherStrategy, options?: ActionNodeOptions[]) => {\r\n  const stepFirst = axium_createGatherNode(props, options);\r\n  return createStrategy({\r\n    topic: props.topic ? props.topic : 'Axium Gather Strategy for: ' + props.actions.map(act => act.type).join(', '),\r\n    initialNode: stepFirst\r\n  });\r\n};"},"For the graph programming framework Stratimux and Axium Concept, generate a model file that includes a create stitch node helper function.\r\nThis function allows for Strategy Stitches to be composed of only one action node.\r\nWhile calling the axium's stitch quality to silently move to the next node assigned to the end of that stitch.":{"type":"project","content":"import { ActionNodeOptions, createActionNode } from '../../../model/actionStrategy';\r\nimport { axiumStitch } from '../qualities/stitch.quality';\r\n\r\n/**\r\n * Must be used within an ActionStrategyStitch with only one ActionNode provided.\r\n * @param options `optional` will set return ActionNode's options if provided.\r\n * @returns ActionNode of axiumStitch\r\n */\r\nexport const axium_createStitchNode = (options?: ActionNodeOptions) =>\r\n  (createActionNode(axiumStitch(), options ? options : {\r\n    successNode: null,\r\n    failureNode: null,\r\n  }));"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will add concepts within the addConceptQue into the Axium's Concepts.":{"type":"project","content":"import { Observable, Subject, Subscriber, catchError } from 'rxjs';\r\nimport { defaultMethodCreator, qualityToString } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { Action, ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { blockingMethodSubscription } from '../../../model/axium';\r\n\r\nexport const axiumAddConceptFromQueType: ActionType = 'Add Concepts from Axium Concept Que';\r\nexport const axiumAddConceptFromQue = prepareActionCreator(axiumAddConceptFromQueType);\r\n\r\nfunction axiumAddConceptsFromQueReducer(state: AxiumState, action: Action) {\r\n  const methodSubscribers = state.methodSubscribers;\r\n  const addConceptsQue = state.addConceptQue;\r\n  addConceptsQue.forEach((concept) => {\r\n    concept.qualities.forEach(quality => {\r\n      if (quality.methodCreator) {\r\n        [quality.method, quality.subject] = quality.methodCreator(state.concepts$, concept.semaphore);\r\n        quality.method.pipe(\r\n          catchError((err: unknown, caught: Observable<Action>) => {\r\n            if (state.logging) {\r\n              console.error('METHOD ERROR', err);\r\n            }\r\n            return caught;\r\n          }));\r\n        quality.toString = qualityToString(quality);\r\n        const methodSub = quality.method.subscribe((act: Action) => {\r\n          const action$ = state.action$ as Subject<Action>;\r\n          blockingMethodSubscription(action$, act);\r\n        }) as Subscriber<Action>;\r\n        methodSubscribers.push({name: concept.name, subscription: methodSub});\r\n      }\r\n    });\r\n  });\r\n\r\n  return {\r\n    ...state,\r\n    methodSubscribers,\r\n    addConceptQue: []\r\n  };\r\n}\r\n\r\nexport const axiumAddConceptsFromQueQuality = createQuality(\r\n  axiumAddConceptFromQueType,\r\n  axiumAddConceptsFromQueReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept, generate a quality that appends a complete strategies action list\r\ninto the dialog state property.":{"type":"project","content":"import { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type AppendActionListToDialogPayload = {\r\n  actionList: Array<string>;\r\n  strategyTopic: string;\r\n  strategyData: unknown;\r\n}\r\nexport const axiumAppendActionListToDialogType: ActionType = 'append Action List to Axium\\'s Dialog';\r\nexport const axiumAppendActionListToDialog =\r\n  prepareActionWithPayloadCreator<AppendActionListToDialogPayload>(axiumAppendActionListToDialogType);\r\n\r\nexport function axiumAppendActionListToDialogReducer(state: AxiumState, action: Action): AxiumState {\r\n  const payload = selectPayload<AppendActionListToDialogPayload>(action);\r\n  let newDialog = '';\r\n  if (state.storeDialog) {\r\n    payload.actionList.forEach(str => {newDialog += str + ' ';});\r\n    if (state.logging) {\r\n      console.log(newDialog);\r\n    }\r\n    return {\r\n      ...state,\r\n      dialog: state.dialog + newDialog,\r\n      lastStrategy: payload.strategyTopic,\r\n      lastStrategyData: payload.strategyData,\r\n      lastStrategyDialog: newDialog\r\n    };\r\n  }\r\n  return {\r\n    ...state,\r\n    lastStrategy: payload.strategyTopic,\r\n    lastStrategyData: payload.strategyData,\r\n  };\r\n}\r\n\r\nexport const axiumAppendActionListToDialogQuality = createQuality(\r\n  axiumAppendActionListToDialogType,\r\n  axiumAppendActionListToDialogReducer,\r\n);"},"For the graph programming framework Stratimux and Axium Concept, generate a quality that will append a series of concepts to the Axium's\r\naddConceptQue. This will then be observed via the Axium's principle.":{"type":"project","content":"import { Concept, defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type AxiumAppendConceptsToAddQuePayload = {\r\n  concepts: Concept[]\r\n}\r\nexport const axiumAppendConceptsToAddQueType: ActionType = 'append Concepts to Axium\\'s Add Concept Que';\r\nexport const axiumAppendConceptsToAddQue =\r\n  prepareActionWithPayloadCreator<AxiumAppendConceptsToAddQuePayload>(axiumAppendConceptsToAddQueType);\r\n\r\nexport function axiumAppendConceptsToAddQueReducer(state: AxiumState, action: Action) {\r\n  const payload = selectPayload<AxiumAppendConceptsToAddQuePayload>(action);\r\n  const addConceptQue = [\r\n    ...payload.concepts\r\n  ];\r\n  return {\r\n    ...state,\r\n    addConceptQue,\r\n  };\r\n}\r\n\r\nexport const axiumAppendConceptsToAddQueQuality = createQuality(\r\n  axiumAppendConceptsToAddQueType,\r\n  axiumAppendConceptsToAddQueReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept, generate a quality that will append a sequence of concepts to the Axium's\r\nremoveConceptQue. The main axium principle will then initialize a removal strategy based on this que.":{"type":"project","content":"import { Concept, defaultMethodCreator } from '../../../model/concept';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type AxiumAppendConceptsToRemoveQuePayload = {\r\n  concepts: Concept[]\r\n}\r\nexport const axiumAppendConceptsToRemoveQueType: ActionType = 'append Concepts to Axium\\'s Remove Concept Que';\r\nexport const axiumAppendConceptsToRemoveQue =\r\n  prepareActionWithPayloadCreator<AxiumAppendConceptsToRemoveQuePayload>(axiumAppendConceptsToRemoveQueType);\r\n\r\nexport function axiumAppendConceptsToRemoveQueReducer(state: AxiumState, action: Action) {\r\n  const payload = selectPayload<AxiumAppendConceptsToRemoveQuePayload>(action);\r\n  let removeQue = state.removeConceptQue;\r\n  removeQue = [\r\n    ...removeQue,\r\n    ...payload.concepts\r\n  ];\r\n  return {\r\n    ...state,\r\n    removeConceptQue: removeQue\r\n  };\r\n}\r\n\r\nexport const axiumAppendConceptsToRemoveQueQuality = createQuality(\r\n  axiumAppendConceptsToRemoveQueType,\r\n  axiumAppendConceptsToRemoveQueReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that signifies if the Axium has received a bad action that\r\nis currently not loaded, part of the wrong generation, expired, etc... If state logging is true, the developer will be notified\r\nof the bad action that was received.":{"type":"project","content":"import { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { AxiumState } from '../axium.concept';\r\n\r\nexport type AxiumBadActionPayload = {\r\n  badActions: Action[],\r\n}\r\nexport const axiumBadActionType: ActionType = 'Axium received a Bad Action';\r\nexport const axiumBadAction = prepareActionWithPayloadCreator<AxiumBadActionPayload>(axiumBadActionType);\r\n\r\nexport function axiumBadActionReducer(state: AxiumState, action: Action) {\r\n  const payload = selectPayload<AxiumBadActionPayload>(action).badActions;\r\n  if (state.logging) {\r\n    console.log('Axium Received a Bad Action: ', action);\r\n  }\r\n  return {\r\n    ...state,\r\n    badActions: [\r\n      ...state.badActions, ...payload\r\n    ]\r\n  };\r\n}\r\n\r\nexport const axiumBadActionQuality = createQuality(\r\n  axiumBadActionType,\r\n  axiumBadActionReducer\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will clear a specified action type from the state's badAction list.\r\nThis list is utilized by future on the fly error correction for handling generated qualities for an embodied artificial intelligence.":{"type":"project","content":"import { defaultMethodCreator, createQuality } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type AxiumClearBadActionTypeFromBadActionListPayload = {\r\n  actionType: ActionType\r\n};\r\nexport const axiumClearBadActionTypeFromBadActionListType: ActionType = 'clear ActionType from Axium\\'s badAction list';\r\nexport const axiumClearBadActionTypeFromBadActionList =\r\n  prepareActionWithPayloadCreator<AxiumClearBadActionTypeFromBadActionListPayload>(axiumClearBadActionTypeFromBadActionListType);\r\n\r\nfunction axiumClearBadActionTypeFromBadActionListReducer(state: AxiumState, action: Action): AxiumState {\r\n  const actionType = selectPayload<AxiumClearBadActionTypeFromBadActionListPayload>(action).actionType;\r\n  return {\r\n    ...state,\r\n    badActions: state.badActions.filter(act => act.type !== actionType),\r\n  };\r\n}\r\n\r\nexport const axiumClearBadActionTypeFromBadActionListQuality = createQuality(\r\n  axiumClearBadActionTypeFromBadActionListType,\r\n  axiumClearBadActionTypeFromBadActionListReducer,\r\n  defaultMethodCreator,\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will clear a specified plan from the badPlan list on state.\r\nThis allows for generated plans via an embodied artificial intelligence to error correct on the fly for any poorly generated plans.":{"type":"project","content":"import { defaultMethodCreator, createQuality } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type AxiumClearBadPlanFromBadPlanListPayload = {\r\n  title: string\r\n};\r\nexport const axiumClearBadPlanFromBadPlanListType: ActionType = 'clear Plan Topic from Axium\\'s badPlan list';\r\nexport const axiumClearBadPlanFromBadPlanList =\r\n  prepareActionWithPayloadCreator<AxiumClearBadPlanFromBadPlanListPayload>(axiumClearBadPlanFromBadPlanListType);\r\n\r\nfunction axiumClearBadPlanFromBadPlanListReducer(state: AxiumState, action: Action): AxiumState {\r\n  const title = selectPayload<AxiumClearBadPlanFromBadPlanListPayload>(action).title;\r\n  return {\r\n    ...state,\r\n    badPlans: state.badPlans.filter(act => act.title !== title),\r\n  };\r\n}\r\n\r\nexport const axiumClearBadPlanFromBadPlanListQuality = createQuality(\r\n  axiumClearBadPlanFromBadPlanListType,\r\n  axiumClearBadPlanFromBadPlanListReducer,\r\n  defaultMethodCreator,\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will remove a strategies topic from state's badAction list.\r\nThis allows for an Artificial Intelligence that is embodying Stratimux to correct generated strategies on the fly.":{"type":"project","content":"import { defaultMethodCreator, createQuality } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type AxiumClearBadStrategyTopicFromBadActionListPayload = {\r\n  topic: string\r\n};\r\nexport const axiumClearBadStrategyTopicFromBadActionListType: ActionType = 'clear Strategy Topic from Axium\\'s badAction list';\r\nexport const axiumClearBadStrategyTopicFromBadActionList =\r\n  prepareActionWithPayloadCreator<AxiumClearBadStrategyTopicFromBadActionListPayload>(axiumClearBadStrategyTopicFromBadActionListType);\r\n\r\nfunction axiumClearBadStrategyTopicFromBadActionListReducer(state: AxiumState, action: Action): AxiumState {\r\n  const strategyTopic = selectPayload<AxiumClearBadStrategyTopicFromBadActionListPayload>(action).topic;\r\n  const badActions = state.badActions.filter(act => {\r\n    if (act.strategy && act.strategy.topic !== strategyTopic) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  });\r\n  return {\r\n    ...state,\r\n    badActions,\r\n  };\r\n}\r\n\r\nexport const axiumClearBadStrategyTopicFromBadActionListQuality = createQuality(\r\n  axiumClearBadStrategyTopicFromBadActionListType,\r\n  axiumClearBadStrategyTopicFromBadActionListReducer,\r\n  defaultMethodCreator,\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will clear the state's dialog.":{"type":"project","content":"import { defaultMethodCreator, createQuality } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\n\r\nexport const axiumClearDialogType: ActionType = 'clear Axium Dialog';\r\nexport const axiumClearDialog = prepareActionCreator(axiumClearDialogType);\r\n\r\nexport function axiumClearDialogReducer(state: AxiumState, action: Action) {\r\n  return {\r\n    ...state,\r\n    dialog: '',\r\n  };\r\n}\r\n\r\nexport const axiumClearDialogQuality = createQuality(\r\n  axiumClearDialogType,\r\n  axiumClearDialogReducer,\r\n  defaultMethodCreator,\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will close the axium, if exit is set to true.\r\nThis will also exit the current process.":{"type":"project","content":"import { createQuality } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\n/**\r\n * @parm exit - If set to true, will exit the current process.\r\n */\r\nexport type AxiumClosePayload = {\r\n  exit: boolean\r\n};\r\nexport const axiumCloseType: ActionType = 'Close Axium';\r\nexport const axiumClose = prepareActionWithPayloadCreator<AxiumClosePayload>(axiumCloseType);\r\n\r\nexport function axiumCloseReducer(state: AxiumState, _action: Action): AxiumState {\r\n  const {exit} = selectPayload<AxiumClosePayload>(_action);\r\n  state.generalSubscribers.forEach(named => named.subscription.unsubscribe());\r\n  state.methodSubscribers.forEach(named => named.subscription.unsubscribe());\r\n  state.stagePlanners.forEach(named => named.conclude());\r\n  state.action$.complete();\r\n  state.concepts$.complete();\r\n  state.innerConcepts$.complete();\r\n  state.subConcepts$.complete();\r\n  if (exit) {\r\n    process.exit();\r\n  }\r\n  return {\r\n    ...state,\r\n    methodSubscribers: [],\r\n    generalSubscribers: [],\r\n    stagePlanners: [],\r\n  };\r\n}\r\n\r\nexport const axiumCloseQuality = createQuality(\r\n  axiumCloseType,\r\n  axiumCloseReducer\r\n);"},"For the graph programming framework Stratimux and Axium Concept, generate a quality that will conclude a strategy.\r\nThis is the primary quality that allows for Stratimux to be provably terminating and/or halting complete.\r\nFunctionally. This is a pure action with no method or reducer. That will instead activate its functionality\r\nwithin each qualities method if specified. As well as ownership if loaded in the Axium's concept set.":{"type":"project","content":"import { ActionType, prepareActionCreator } from '../../../model/action';\r\n\r\n/**\r\n * axiumConcludeType\r\n * This is a special Quality that does not have a Reducer or Method\r\n * Instead what this allows for is special functionality within the Axium and Ownership Concepts\r\n * Is used for appending ActionList to Dialog\r\n * And used to clear Ownership of its Previous ActionNode and is handled by ActionStrategy\r\n * This should not be used Directly\r\n */\r\nexport const axiumConcludeType: ActionType = 'Conclude';\r\nexport const axiumConclude = prepareActionCreator(axiumConcludeType);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will initialize principles loaded into the Axium's conceptual set.":{"type":"project","content":"import { Subject, Subscriber } from 'rxjs';\r\nimport { Concept, Concepts, defaultMethodCreator, forEachConcept  } from '../../../model/concept';\r\nimport { createPrinciple$ } from '../../../model/principle';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState, axiumName } from '../axium.concept';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type AxiumInitializePrinciplesPayload = {\r\n    concepts: Concepts;\r\n}\r\nexport const axiumInitializePrinciplesType: ActionType = 'initialize Principles and set new Subscribers to General Subscribers list';\r\nexport const axiumInitializePrinciples =\r\n  prepareActionWithPayloadCreator<AxiumInitializePrinciplesPayload>(axiumInitializePrinciplesType);\r\n\r\nexport function axiumInitializePrinciplesReducer(state: AxiumState, _action: Action): AxiumState {\r\n  const payload = selectPayload<AxiumInitializePrinciplesPayload>(_action);\r\n  const concepts = payload.concepts;\r\n  let conceptCounter = state.conceptCounter;\r\n  const action$ = state.action$ as Subject<Action>;\r\n  const concepts$ = state.concepts$ as UnifiedSubject;\r\n  const principleSubscribers = state.generalSubscribers;\r\n  forEachConcept(concepts ,((concept: Concept, semaphore) => {\r\n    if (concept.name === axiumName && concept.principles) {\r\n      concept.principles.forEach(principle => {\r\n        const observable = createPrinciple$(principle, concepts, state.innerConcepts$, semaphore as number);\r\n        principleSubscribers.push({\r\n          name: concept.name,\r\n          subscription: observable.subscribe((action: Action) => action$.next(action)) as Subscriber<Action>,\r\n        });\r\n      });\r\n      conceptCounter += 1;\r\n    } else if (concept.principles) {\r\n      concept.principles.forEach(principle => {\r\n        const observable = createPrinciple$(principle, concepts, concepts$, semaphore as number);\r\n        principleSubscribers.push({\r\n          name: concept.name,\r\n          subscription: observable.subscribe((action: Action) => action$.next(action)) as Subscriber<Action>,\r\n        });\r\n      });\r\n      conceptCounter += 1;\r\n    }\r\n  }));\r\n  return {\r\n    ...state,\r\n    principleSubscribers,\r\n    conceptCounter,\r\n  };\r\n}\r\n\r\nexport const axiumInitializePrinciplesQuality = createQuality(\r\n  axiumInitializePrinciplesType,\r\n  axiumInitializePrinciplesReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept, generate a quality with the default method and reducer.\r\nThis quality is used to signify the next step within a plan if no state change is required.\r\nLikewise this quality is used to kick the axium into gear if currently resting due to its own halting behavior.":{"type":"project","content":"import { defaultMethodCreator, defaultReducer } from '../../../model/concept';\r\nimport { ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\n\r\nexport const axiumKickType: ActionType = 'Kick Axium';\r\nexport const axiumKick = prepareActionCreator(axiumKickType);\r\n\r\nexport const axiumKickQuality = createQuality(\r\n  axiumKickType,\r\n  defaultReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept, generate a quality that will console log the action itself.\r\nThis is used to trouble shoot strategies or simply notify the log of different states.":{"type":"project","content":"import { MethodCreator, defaultReducer } from '../../../model/concept';\r\nimport { ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { createMethod } from '../../../model/method';\r\n\r\nexport const axiumLogType: ActionType = 'logged a message passed to Axium';\r\nexport const axiumLog = prepareActionCreator(axiumLogType);\r\n\r\nexport const axiumLogMethodCreator: MethodCreator = () => createMethod((action) => {\r\n  console.log('Logging: ', action);\r\n  if (action.strategy) {\r\n    return strategySuccess(action.strategy);\r\n  } else {\r\n    return action;\r\n  }\r\n});\r\n\r\nexport const axiumLogQuality = createQuality(\r\n  axiumLogType,\r\n  defaultReducer,\r\n  axiumLogMethodCreator,\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality similar to axium kick, except this is used when the Axium is\r\ncurrently in blocking mode. This allows for subscribers to be notified of any new configurations if set.\r\nOr simply that the axium is ready to receive actions.":{"type":"project","content":"import { defaultMethodCreator, createQuality } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type OpenPayload = {\r\n  open: boolean\r\n};\r\n\r\nexport const axiumOpenType: ActionType = 'Open Axium';\r\nexport const axiumOpen = prepareActionWithPayloadCreator<OpenPayload>(axiumOpenType);\r\n\r\nexport function axiumOpenReducer(state: AxiumState, action: Action): AxiumState {\r\n  const open = selectPayload<OpenPayload>(action).open;\r\n  return {\r\n    ...state,\r\n    open,\r\n  };\r\n}\r\nexport const axiumOpenQuality = createQuality(\r\n  axiumOpenType,\r\n  axiumOpenReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept, generate a quality that will trigger the axium's closing process via\r\nits close principle that is observing the prepareClose state property.":{"type":"project","content":"import { createQuality } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\n/**\r\n * @parm exit - If set to true, will exit the current process.\r\n */\r\nexport type AxiumPreClosePayload = {\r\n  exit: boolean\r\n};\r\nexport const axiumPreCloseType: ActionType = 'Prepare Close Axium';\r\nexport const axiumPreClose = prepareActionWithPayloadCreator<AxiumPreClosePayload>(axiumPreCloseType);\r\n\r\nexport function axiumCloseReducer(state: AxiumState, _action: Action): AxiumState {\r\n  return {\r\n    ...state,\r\n    prepareClose: true,\r\n    exit: selectPayload<AxiumPreClosePayload>(_action).exit\r\n  };\r\n}\r\n\r\nexport const axiumPreCloseQuality = createQuality(\r\n  axiumPreCloseType,\r\n  axiumCloseReducer\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will append a stage planner to the stagePlanners state property.\r\nThis allows for the closing of hot observables if the concept they are associated with is removed, or the axium itself is closed.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { StagePlanner } from '../../../model/stagePlanner';\r\n\r\nexport type AxiumRegisterStagePlannerPayload = {\r\n    stagePlanner: StagePlanner;\r\n    conceptName: string;\r\n}\r\nexport const axiumRegisterStagePlannerType: ActionType = 'register Stage Planner to Axium\\'s Named Stage Planner list';\r\nexport const axiumRegisterStagePlanner =\r\n  prepareActionWithPayloadCreator<AxiumRegisterStagePlannerPayload>(axiumRegisterStagePlannerType);\r\n\r\nfunction axiumRegisterSubscriberReducer(state: AxiumState, action: Action): AxiumState {\r\n  const payload = selectPayload<AxiumRegisterStagePlannerPayload>(action);\r\n  const stagePlanners = state.stagePlanners;\r\n  const stagePlanner = payload.stagePlanner;\r\n  const name = payload.conceptName;\r\n  stagePlanners.push({name, ...stagePlanner});\r\n  return {\r\n    ...state,\r\n    stagePlanners,\r\n  };\r\n}\r\n\r\nexport const axiumRegisterStagePlannerQuality = createQuality(\r\n  axiumRegisterStagePlannerType,\r\n  axiumRegisterSubscriberReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will register a subscription to the concepts$ stream.\r\nThis allows for the clean closure of concepts that are removed or when the axium itself exits.":{"type":"project","content":"import { Subscription } from 'rxjs';\r\nimport { defaultMethodCreator } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type AxiumRegisterSubscriberPayload = {\r\n    subscription: Subscription;\r\n    name: string;\r\n}\r\nexport const axiumRegisterSubscriberType: ActionType = 'register Subscriber to Axium\\'s General Subscriber list';\r\nexport const axiumRegisterSubscriber =\r\n  prepareActionWithPayloadCreator<AxiumRegisterSubscriberPayload>(axiumRegisterSubscriberType);\r\n\r\nfunction axiumRegisterSubscriberReducer(state: AxiumState, action: Action) {\r\n  const payload = selectPayload<AxiumRegisterSubscriberPayload>(action);\r\n  const generalSubscribers = state.generalSubscribers;\r\n  const subscription = payload.subscription;\r\n  const name = payload.name;\r\n  generalSubscribers.push({name, subscription});\r\n  return {\r\n    ...state,\r\n    generalSubscribers,\r\n  };\r\n}\r\n\r\nexport const axiumRegisterSubscriberQuality = createQuality(\r\n  axiumRegisterSubscriberType,\r\n  axiumRegisterSubscriberReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will remove concepts that are currently loaded in the Axium.\r\nWill concluding plans and closing active subscriptions associated with the removed concepts.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { NamedSubscription } from '../axium.concept';\r\nimport { Action, ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { NamedStagePlanner } from '../../../model/stagePlanner';\r\n\r\nexport const axiumRemoveConceptsViaQueType: ActionType = 'remove Concepts via Axium\\'s Removal Concept Que';\r\nexport const axiumRemoveConceptsViaQue = prepareActionCreator(axiumRemoveConceptsViaQueType);\r\n\r\nfunction axiumRemoveConceptsViaQueReducer(state: AxiumState, _action: Action) {\r\n  const principleSubscribers = state.methodSubscribers;\r\n  const newPrincipleSubscribers = [] as NamedSubscription[];\r\n  const generalSubscribers = state.methodSubscribers;\r\n  const newGeneralSubscribers = [] as NamedSubscription[];\r\n  const stagePlanners = state.stagePlanners;\r\n  const newStagePlanners = [] as NamedStagePlanner[];\r\n  const removeConceptQue = state.removeConceptQue;\r\n\r\n  principleSubscribers.forEach(named => {\r\n    let exists = false;\r\n    removeConceptQue.forEach(concept => {\r\n      if (concept.name === named.name) {\r\n        exists = true;\r\n      }\r\n    });\r\n    if (!exists) {\r\n      newPrincipleSubscribers.push(named);\r\n    } else {\r\n      named.subscription.unsubscribe();\r\n    }\r\n  });\r\n\r\n  generalSubscribers.forEach(named => {\r\n    let exists = false;\r\n    removeConceptQue.forEach(concept => {\r\n      if (concept.name === named.name) {\r\n        exists = true;\r\n      }\r\n    });\r\n    if (!exists) {\r\n      newGeneralSubscribers.push(named);\r\n    } else {\r\n      named.subscription.unsubscribe();\r\n    }\r\n  });\r\n\r\n  stagePlanners.forEach(named => {\r\n    let exists = false;\r\n    removeConceptQue.forEach(concept => {\r\n      if (concept.name === named.name) {\r\n        exists = true;\r\n      }\r\n    });\r\n    if (!exists) {\r\n      newStagePlanners.push(named);\r\n    } else {\r\n      named.conclude();\r\n    }\r\n  });\r\n\r\n  return {\r\n    ...state,\r\n    generalSubscribers: newGeneralSubscribers,\r\n    stagePlanners: newStagePlanners,\r\n    removeConceptQue: []\r\n  };\r\n}\r\n\r\nexport const axiumRemoveConceptsViaQueQuality = createQuality(\r\n  axiumRemoveConceptsViaQueType,\r\n  axiumRemoveConceptsViaQueReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will set the Axium's mode to blocking. While in this mode\r\nthe Axium operates in a synchronous behavior to quickly modify the Axium's conceptual set.":{"type":"project","content":"import { Subject, Subscriber } from 'rxjs';\r\nimport { Concepts, defaultMethodCreator, forEachConcept } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { blockingMethodSubscription } from '../../../model/axium';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type AxiumSetBlockingModePayload = {\r\n    concepts: Concepts\r\n}\r\nexport const axiumSetBlockingModeType: ActionType = 'set Axium to Blocking Mode';\r\nexport const axiumSetBlockingMode = prepareActionWithPayloadCreator<AxiumSetBlockingModePayload>(axiumSetBlockingModeType);\r\n\r\nfunction axiumSetBlockingModeReducer(state: AxiumState, _action: Action): AxiumState {\r\n  let methodSubscribers = state.methodSubscribers;\r\n  methodSubscribers.forEach(named => named.subscription.unsubscribe());\r\n  methodSubscribers = [];\r\n\r\n  const payload = selectPayload<AxiumSetBlockingModePayload>(_action);\r\n  const concepts = payload.concepts;\r\n  forEachConcept(concepts, (concept => {\r\n    concept.qualities.forEach(quality => {\r\n      if (quality.method) {\r\n        const sub = quality.method.subscribe(action => {\r\n          const action$ = state.action$ as Subject<Action>;\r\n          blockingMethodSubscription(action$, action);\r\n        });\r\n        methodSubscribers.push({\r\n          name: concept.name,\r\n          subscription: sub as Subscriber<Action>\r\n        });\r\n      }\r\n    });\r\n  }));\r\n\r\n  return {\r\n    ...state,\r\n    modeIndex: 0,\r\n    methodSubscribers,\r\n    open: false,\r\n  };\r\n}\r\n\r\nexport const axiumSetBlockingModeQuality = createQuality(\r\n  axiumSetBlockingModeType,\r\n  axiumSetBlockingModeReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept, generate a quality that will set the Axium to its default mode.\r\nThis mode likewise can be specified by changing the defaultModeIndex state property.":{"type":"project","content":"import { Subject, Subscriber } from 'rxjs';\r\nimport { Concepts, defaultMethodCreator, forEachConcept } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { defaultMethodSubscription } from '../../../model/axium';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type AxiumSetDefaultModePayload = {\r\n    concepts: Concepts\r\n}\r\nexport const axiumSetDefaultModeType: ActionType = 'set Axium to its current Default Mode Index';\r\nexport const axiumSetDefaultMode = prepareActionWithPayloadCreator<AxiumSetDefaultModePayload>(axiumSetDefaultModeType);\r\n\r\nfunction axiumSetDefaultModeReducer(state: AxiumState, _action: Action): AxiumState {\r\n  let methodSubscribers = state.methodSubscribers;\r\n  methodSubscribers.forEach(named => named.subscription.unsubscribe());\r\n  methodSubscribers = [];\r\n  const payload = selectPayload<AxiumSetDefaultModePayload>(_action);\r\n  const concepts = payload.concepts;\r\n  forEachConcept(concepts, (concept => {\r\n    concept.qualities.forEach(quality => {\r\n      if (quality.method) {\r\n        const sub = quality.method.subscribe(action => {\r\n          const action$ = state.action$ as Subject<Action>;\r\n          defaultMethodSubscription(action$, action);\r\n        });\r\n        methodSubscribers.push({\r\n          name: concept.name,\r\n          subscription: sub as Subscriber<Action>\r\n        });\r\n      }\r\n    });\r\n  }));\r\n\r\n  return {\r\n    ...state,\r\n    modeIndex: state.defaultModeIndex,\r\n    methodSubscribers,\r\n  };\r\n}\r\n\r\nexport const axiumSetDefaultModeQuality = createQuality(\r\n  axiumSetDefaultModeType,\r\n  axiumSetDefaultModeReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will set the default mode index to what is specified by\r\nthe action's payload.":{"type":"project","content":"import { defaultMethodCreator, createQuality } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { AxiumState } from '../axium.concept';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type AxiumSetDefaultModeIndexPayload = {\r\n  index: number;\r\n};\r\nexport const axiumSetDefaultModeIndexType: ActionType = 'set Axium\\'s Default Mode Index';\r\nexport const axiumSetDefaultModeIndex = prepareActionWithPayloadCreator<AxiumSetDefaultModeIndexPayload>(axiumSetDefaultModeIndexType);\r\n\r\nexport function axiumSetDefaultModeIndexReducer(state: AxiumState, action: Action) {\r\n  const payload = selectPayload<AxiumSetDefaultModeIndexPayload>(action);\r\n  return {\r\n    ...state,\r\n    defaultModeIndex: payload.index,\r\n  } as AxiumState;\r\n}\r\nexport const axiumSetDefaultModeIndexQuality = createQuality(\r\n  axiumSetDefaultModeIndexType,\r\n  axiumSetDefaultModeIndexReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept, generate a quality that will set the mode explicitly via the payload.":{"type":"project","content":"import { AxiumState } from '../axium.concept';\r\nimport { Action, prepareActionWithPayloadCreator} from '../../../model/action';\r\nimport { createQuality, MethodCreator, Method } from '../../../model/concept';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { createMethod } from '../../../model/method';\r\n\r\nexport type AxiumSetModePayload = {\r\n  modeIndex: number;\r\n  modeName: string;\r\n}\r\n\r\nexport const axiumSetModeType = 'set Axium Mode';\r\nexport const axiumSetMode = prepareActionWithPayloadCreator<AxiumSetModePayload>(axiumSetModeType);\r\n\r\nconst axiumSetModeMethodCreator: MethodCreator = () => createMethod((action) => {\r\n  const payload = action.payload as AxiumSetModePayload;\r\n  if (action.strategy) {\r\n    action.strategy.currentNode.successNotes = {\r\n      denoter: `to ${payload.modeName}.`\r\n    };\r\n    return strategySuccess(action.strategy);\r\n  }\r\n  return action;\r\n});\r\n\r\nfunction axiumSetModeReducer(state: AxiumState, _action: Action) {\r\n  const payload = selectPayload<AxiumSetModePayload>(_action);\r\n  return {\r\n    ...state,\r\n    modeIndex: [payload.modeIndex],\r\n  };\r\n}\r\n\r\nexport const axiumSetModeQuality = createQuality(\r\n  axiumSetModeType,\r\n  axiumSetModeReducer,\r\n  axiumSetModeMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a quality that will silently start the next step in the strategy graph.":{"type":"project","content":"import { prepareActionCreator } from '../../../model/action';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { createQuality, defaultReducer } from '../../../model/concept';\r\nimport { ActionType, createMethod } from '../../../model/method';\r\n\r\nexport const axiumStitchType: ActionType = 'Axium Stitch';\r\nexport const axiumStitch = prepareActionCreator(axiumStitchType);\r\n\r\nconst axiumStitchMethodCreator = () => createMethod((action) => {\r\n  if (action.strategy) {\r\n    const nextStrategy = strategySuccess(action.strategy);\r\n    if (nextStrategy.strategy) {\r\n      const actionList = nextStrategy.strategy.actionList;\r\n      const newList = [];\r\n      for (let i = 0; i < actionList.length - 1; i++) {\r\n        newList.push(actionList[i]);\r\n      }\r\n      nextStrategy.strategy.actionList = newList;\r\n    }\r\n    return nextStrategy;\r\n  } else {\r\n    return action;\r\n  }\r\n});\r\n\r\nexport const axiumStitchQuality = createQuality(\r\n  axiumStitchType,\r\n  defaultReducer,\r\n  axiumStitchMethodCreator\r\n);"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate an ActionStrategy that will add new concepts into the Axium's conceptual set.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concept, Concepts } from '../../../model/concept';\r\nimport { getSemaphore} from '../../../model/action';\r\nimport { axiumAddConceptFromQue, axiumAddConceptFromQueType } from '../qualities/addConceptsFromQue.quality';\r\nimport { axiumAppendConceptsToAddQue, axiumAppendConceptsToAddQueType } from '../qualities/appendConceptsToAddQue.quality';\r\nimport { axiumOpen, axiumOpenType } from '../qualities/open.quality';\r\nimport { axiumSetBlockingMode, axiumSetBlockingModeType } from '../qualities/setBlockingMode.quality';\r\nimport { axiumSetDefaultMode, axiumSetDefaultModeType } from '../qualities/setDefaultMode.quality';\r\nimport { axiumName } from '../axium.concept';\r\n\r\n// Step One to Add Concepts to Axium\r\nexport const addConceptsToAddQueThenBlockTopic = 'Add Concepts to add que then set Axium Mode to Blocking';\r\nexport function addConceptsToAddQueThenBlockStrategy(concepts: Concepts, newConcepts: Concept[]) {\r\n  const stepTwo = createActionNode(axiumAppendConceptsToAddQue({concepts: newConcepts}),{\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'Then Safely'\r\n    },\r\n    failureNode: null,\r\n    semaphore: getSemaphore(concepts, axiumName, axiumAppendConceptsToAddQueType),\r\n  });\r\n  const stepOne = createActionNode(axiumSetBlockingMode({concepts}), {\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: 'Immediately'\r\n    },\r\n    failureNode: null,\r\n    semaphore: getSemaphore(concepts, axiumName, axiumSetBlockingModeType),\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: addConceptsToAddQueThenBlockTopic,\r\n    initialNode: stepOne\r\n  };\r\n  return createStrategy(params);\r\n}\r\n// Step Two\r\nexport const addConceptsFromQueThenUnblockTopic = 'Add Concepts from Que then set Axium Mode to Default';\r\nexport function addConceptsFromQueThenUnblockStrategy(conceptualSet: Concepts): ActionStrategy {\r\n  const addConceptsFromQueSemaphore = getSemaphore(conceptualSet, axiumName, axiumAddConceptFromQueType);\r\n  const setDefaultModeSemaphore = getSemaphore(conceptualSet, axiumName, axiumSetDefaultModeType);\r\n  const openSemaphore = getSemaphore(conceptualSet, axiumName, axiumOpenType);\r\n\r\n  const stepThree = createActionNode(axiumOpen({open: true}), {\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'Reinstate',\r\n      denoter: 'State.'\r\n    },\r\n    failureNode: null,\r\n    semaphore: openSemaphore,\r\n  });\r\n  const stepTwo = createActionNode(axiumSetDefaultMode({concepts: conceptualSet}), {\r\n    semaphore: setDefaultModeSemaphore,\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: 'Then'\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepOne = createActionNode(axiumAddConceptFromQue(),{\r\n    semaphore: addConceptsFromQueSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: 'First'\r\n    },\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: addConceptsFromQueThenUnblockTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Axium Concept,\r\ngenerate a strategy that will initialize the axium of its base functionality.\r\nWithin the Stratimux paradigm. Principles act as the start up script, or main function.":{"type":"project","content":"import { createStrategy, ActionNode, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concepts } from '../../../model/concept';\r\nimport { getSemaphore } from '../../../model/action';\r\nimport { axiumOpen, axiumOpenType } from '../qualities/open.quality';\r\nimport { axiumInitializePrinciples, axiumInitializePrinciplesType } from '../qualities/initializePrinciples.quality';\r\nimport { axiumSetDefaultMode, axiumSetDefaultModeType } from '../qualities/setDefaultMode.quality';\r\nimport { axiumName } from '../axium.concept';\r\n\r\nexport const initializeTopic = 'Axium Initialization Strategy';\r\nexport function initializationStrategy(concepts: Concepts): ActionStrategy {\r\n  const initSemaphore = getSemaphore(concepts, axiumName, axiumInitializePrinciplesType);\r\n  const setDefaultModeSemaphore = getSemaphore(concepts, axiumName, axiumSetDefaultModeType);\r\n  const openSemaphore = getSemaphore(concepts, axiumName, axiumOpenType);\r\n\r\n  const stepThree: ActionNode = createActionNode(axiumOpen({open: true}), {\r\n    semaphore: openSemaphore,\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'Finally',\r\n      denoter: 'to Notify Subscribers of State changes.'\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepTwo: ActionNode = createActionNode(axiumSetDefaultMode({concepts}), {\r\n    semaphore: setDefaultModeSemaphore,\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: 'Then'\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepOne: ActionNode = createActionNode(axiumInitializePrinciples({concepts}),{\r\n    semaphore: initSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: 'Begin with'\r\n    },\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: initializeTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Axium Concept, generate a strategy that will safely remove concepts\r\nfrom the Axium's concepts state property.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concept, Concepts } from '../../../model/concept';\r\nimport { getSemaphore } from '../../../model/action';\r\nimport { axiumRemoveConceptsViaQue, axiumRemoveConceptsViaQueType } from '../qualities/removeConceptsViaQue.quality';\r\nimport { axiumAppendConceptsToRemoveQue, axiumAppendConceptsToRemoveQueType } from '../qualities/appendConceptsToRemoveQue.quality';\r\nimport { axiumSetBlockingMode, axiumSetBlockingModeType } from '../qualities/setBlockingMode.quality';\r\nimport { axiumOpen, axiumOpenType } from '../qualities/open.quality';\r\nimport { axiumSetDefaultMode, axiumSetDefaultModeType } from '../qualities/setDefaultMode.quality';\r\nimport { axiumName } from '../axium.concept';\r\n\r\nexport const addConceptsToRemovalQueThenBlockTopic = 'Add Concepts to removal Que then set Axium Mode to Blocking';\r\nexport function addConceptsToRemovalQueThenBlockStrategy(concepts: Concepts, targetConcepts: Concept[]) {\r\n  const setBlockingModeSemaphore = getSemaphore(concepts, axiumName, axiumSetBlockingModeType);\r\n  const appendConceptsToRemoveQueSemaphore = getSemaphore(concepts, axiumName, axiumAppendConceptsToRemoveQueType);\r\n\r\n  const stepTwo = createActionNode(axiumAppendConceptsToRemoveQue({concepts: targetConcepts}), {\r\n    semaphore: appendConceptsToRemoveQueSemaphore,\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n  const stepOne = createActionNode(axiumSetBlockingMode({concepts}), {\r\n    semaphore: setBlockingModeSemaphore,\r\n    successNode: stepTwo,\r\n    failureNode: null,\r\n  });\r\n  const params: ActionStrategyParameters = {\r\n    topic: addConceptsToRemovalQueThenBlockTopic,\r\n    initialNode: stepOne\r\n  };\r\n  return createStrategy(params);\r\n}\r\n// Step Two\r\nexport const removeConceptsViaQueThenUnblockTopic = 'Remove Concepts via Que then set Axium Mode to Default';\r\nexport function removeConceptsViaQueThenUnblockStrategy(concepts: Concepts): ActionStrategy {\r\n  const removeConceptsViaQueSemaphore = getSemaphore(concepts, axiumName, axiumRemoveConceptsViaQueType);\r\n  const setDefaultModeSemaphore = getSemaphore(concepts, axiumName, axiumSetDefaultModeType);\r\n  const openSemaphore = getSemaphore(concepts, axiumName, axiumOpenType);\r\n\r\n  const stepThree = createActionNode(axiumOpen({open: true}), {\r\n    semaphore: openSemaphore,\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'Reinstate',\r\n      denoter: 'State.'\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepTwo = createActionNode(axiumSetDefaultMode({concepts}), {\r\n    semaphore: setDefaultModeSemaphore,\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: 'Then'\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepOne = createActionNode(axiumRemoveConceptsViaQue(), {\r\n    semaphore: removeConceptsViaQueSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: 'To Begin'\r\n    },\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: removeConceptsViaQueThenUnblockTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux,\r\ngenerate the Chain Concept that will dispatch any actions in sequence assigned to its actionQue.\r\nThis concept merely exists by example. As the issue with this concept is that it does not afford for error correction.\r\nAnd would be considered a precursor to ActionStrategy.":{"type":"project","content":"import { Action } from '../../index';\r\nimport { createConcept } from '../../model/concept';\r\nimport { chainPrinciple } from './chain.principle';\r\nimport { chainPrepareChainQuality } from './qualities/prepareChain.quality';\r\n\r\nexport type ChainState = {\r\n    actionQue: Action[];\r\n};\r\n\r\nexport const chainName = 'chain';\r\n\r\nconst initialChainState: ChainState = {\r\n  actionQue: [],\r\n};\r\n\r\nexport const createChainConcept = () => {\r\n  return createConcept(\r\n    chainName,\r\n    initialChainState,\r\n    [chainPrepareChainQuality],\r\n    [chainPrinciple],\r\n  );\r\n};"},"For the graph programming framework Stratimux and Chain Concept,\r\ngenerate a principle that observes the chain's actionQue and dispatches\r\nthose actions in order upon each state notification.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport { Concepts } from '../../model/concept';\r\nimport { Action } from '../../model/action';\r\nimport { PrincipleFunction, registerPrincipleSubscription } from '../../model/principle';\r\nimport { ChainState, chainName } from './chain.concept';\r\nimport { selectUnifiedState } from '../../model/selector';\r\nimport { AxiumState } from '../axium/axium.concept';\r\nimport { UnifiedSubject } from '../../model/stagePlanner';\r\n\r\nexport const chainPrinciple: PrincipleFunction = (\r\n  observer: Subscriber<Action>,\r\n  _concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  const subscription = concepts$.subscribe((concepts: Concepts) => {\r\n    const chainState = selectUnifiedState<ChainState>(concepts, semaphore);\r\n    if (chainState && chainState.actionQue.length > 0) {\r\n      const newActionQue = [...chainState.actionQue];\r\n      const nextAction = newActionQue.pop() as Action;\r\n      chainState.actionQue = newActionQue;\r\n      concepts$.next(concepts);\r\n      const axiumState = concepts[0].state as AxiumState;\r\n      axiumState.action$?.next(nextAction);\r\n    }\r\n  });\r\n  registerPrincipleSubscription(observer, _concepts, chainName, subscription);\r\n};"},"For the graph programming framework Stratimux and Chain Concept,\r\ngenerate a quality will add actions into the Chain's actionQue state property.":{"type":"project","content":"import { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { ChainState } from '../chain.concept';\r\n\r\nexport type ChainDispatchActionsPayload = {\r\n    actions: Action[]\r\n}\r\nexport const chainDispatchActionsType: ActionType = 'dispatch Actions from Action Que via Payload to be Chained';\r\nexport const chainDispatchActions = prepareActionWithPayloadCreator<ChainDispatchActionsPayload>(chainDispatchActionsType);\r\n\r\nfunction chainPrepareChainReducer(state: ChainState, action: Action) {\r\n  const payload = selectPayload<ChainDispatchActionsPayload>(action);\r\n  return {\r\n    ...state,\r\n    actionQue: [\r\n      ...state.actionQue,\r\n      ...payload.actions\r\n    ]\r\n  };\r\n}\r\n\r\nexport const chainPrepareChainQuality = createQuality(\r\n  chainDispatchActionsType,\r\n  chainPrepareChainReducer,\r\n);"},"For the graph programming framework Stratimux generate a Counter Concept that will keep track of a count in its state.":{"type":"project","content":"import { counterAddQuality } from './qualities/add.quality';\r\nimport { counterSubtractQuality } from './qualities/subtract.quality';\r\nimport { counterSetCountQuality } from './qualities/setCount.quality';\r\nimport { createConcept } from '../../model/concept';\r\nexport { countingStrategy, primedCountingStrategy } from './strategies/counting.strategy';\r\n\r\nexport type CounterState = {\r\n    count: number\r\n}\r\n\r\nexport const counterName = 'counter';\r\n\r\nconst initialCounterState: CounterState = {\r\n  count: 0\r\n};\r\n\r\nexport const createCounterConcept = () => {\r\n  return createConcept(\r\n    counterName,\r\n    initialCounterState,\r\n    [\r\n      counterAddQuality,\r\n      counterSubtractQuality,\r\n      counterSetCountQuality\r\n    ]\r\n  );\r\n};"},"For the graph programming framework Stratimux and Counter Concept, generate a KeyedSelector for the Counter's count state property.":{"type":"project","content":"import { KeyedSelector } from '../../model/selector';\r\n\r\nexport const counterSelectCount: KeyedSelector = {\r\n  conceptName: 'counter',\r\n  stateKeys: 'count',\r\n};"},"For the graph programming framework Stratimux and Counter Concept, generate a quality that will increment the state's count by one.":{"type":"project","content":"import { Action, ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { defaultMethodCreator } from '../../../model/concept';\r\nimport { CounterState } from '../counter.concept';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { counterSelectCount } from '../counter.selector';\r\n\r\nexport const counterAddType: ActionType = 'Counter Add';\r\n\r\nexport const counterAdd = prepareActionCreator(counterAddType);\r\nfunction counterAddReducer(state: CounterState, _: Action) {\r\n  return {\r\n    ...state,\r\n    count: state.count + 1\r\n  };\r\n}\r\n\r\nexport const counterAddQuality = createQuality(\r\n  counterAddType,\r\n  counterAddReducer,\r\n  defaultMethodCreator,\r\n  [counterSelectCount]\r\n);"},"For the graph programming framework Stratimux and Counter Concept,\r\ngenerate a quality that set the state property count to the new count provided\r\nby the action's payload.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { Action, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { CounterState } from '../counter.concept';\r\nimport { counterSelectCount } from '../counter.selector';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport const counterSetCountType = 'Counter set Count';\r\n\r\nexport type CounterSetCountPayload = {\r\n  newCount: number\r\n}\r\nexport const counterSetCount = prepareActionWithPayloadCreator<CounterSetCountPayload>(counterSetCountType);\r\n\r\nfunction counterSetCountReducer(state: CounterState, action: Action) {\r\n  const payload = selectPayload<CounterSetCountPayload>(action);\r\n  return {\r\n    ...state,\r\n    count: payload.newCount\r\n  };\r\n}\r\n\r\nexport const counterSetCountQuality = createQuality(\r\n  counterSetCountType,\r\n  counterSetCountReducer,\r\n  defaultMethodCreator,\r\n  [counterSelectCount]\r\n);"},"For the graph programming framework Stratimux and Counter Concept, generate a quality that will decrement the state count by one.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { CounterState } from '../counter.concept';\r\nimport { ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { counterSelectCount } from '../counter.selector';\r\n\r\nexport const counterSubtractType: ActionType = 'Counter Subtract';\r\n\r\nexport const counterSubtract = prepareActionCreator(counterSubtractType);\r\n\r\nfunction counterSubtractReducer(state: CounterState) {\r\n  return {\r\n    ...state,\r\n    count: state.count - 1\r\n  };\r\n}\r\n\r\nexport const counterSubtractQuality = createQuality(\r\n  counterSubtractType,\r\n  counterSubtractReducer,\r\n  defaultMethodCreator,\r\n  [counterSelectCount]\r\n);"},"For the graph programming framework Stratimux and Counter Concept,\r\ngenerate an ActionStrategy that will perform a series of counter actions that will\r\nultimately just increment the count by one.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concepts} from '../../../model/concept';\r\nimport { getSemaphore } from '../../../model/action';\r\nimport { counterAdd, counterAddType } from '../qualities/add.quality';\r\nimport { counterSubtract, counterSubtractType } from '../qualities/subtract.quality';\r\nimport { counterName } from '../counter.concept';\r\n\r\nexport const countingTopic = 'Counting Strategy';\r\nexport function countingStrategy(): ActionStrategy {\r\n  const stepFive = createActionNode(counterSubtract(), {\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'and finally',\r\n      denoter: 'One.',\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepFour = createActionNode(counterAdd(), {\r\n    successNode: stepFive,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepThree = createActionNode(counterAdd(), {\r\n    successNode: stepFour,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepTwo = createActionNode(counterSubtract(), {\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepOne = createActionNode(counterAdd(), {\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: countingTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Counter Concept,\r\ngenerate a strategy that will ultimately increment the Counter's count by one.\r\nThis strategy should likewise accept concepts to allow for a base Counter Concept to prime its action's semaphore.":{"type":"project","content":"export const primedCountingTopic = 'Counting Strategy with Primed Actions';\r\nexport function primedCountingStrategy(concepts: Concepts): ActionStrategy {\r\n  const addSemaphore = getSemaphore(concepts, counterName, counterAddType);\r\n  const subtractSemaphore = getSemaphore(concepts, counterName, counterSubtractType);\r\n  const stepFour = createActionNode(counterAdd(), {\r\n    semaphore: addSemaphore,\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'and finally',\r\n      denoter: 'One.',\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepThree = createActionNode(counterAdd(), {\r\n    semaphore: addSemaphore,\r\n    successNode: stepFour,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepTwo = createActionNode(counterSubtract(), {\r\n    semaphore: subtractSemaphore,\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepOne = createActionNode(counterAdd(), {\r\n    semaphore: subtractSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: primedCountingTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux generate the Experiment Concept that will be used in testing to confirm\r\ndifferent configurations of Stratimux to be provably terminating.":{"type":"project","content":"import { Mode, Quality, createConcept } from '../../model/concept';\r\nimport { Action } from '../../model/action';\r\nimport { PrincipleFunction } from '../../model/principle';\r\n\r\nexport type ExperimentState = {\r\n  actionQue: Action[],\r\n  mock: boolean,\r\n  id: number\r\n}\r\n\r\nexport const experimentName = 'experiment';\r\n\r\nexport const createExperimentState = (): ExperimentState => {\r\n  return {\r\n    actionQue: [],\r\n    mock: false,\r\n    id: 0,\r\n  };\r\n};\r\n\r\nexport const createExperimentConcept = (\r\n  state: Record<string, unknown>,\r\n  qualities?: Quality[],\r\n  principles?: PrincipleFunction[],\r\n  mode?: Mode[]) => {\r\n  return createConcept(\r\n    experimentName,\r\n    state,\r\n    qualities,\r\n    principles,\r\n    mode\r\n  );\r\n};"},"For the graph programming framework Stratimux and Experiment Concept,\r\ngenerate a principle that observes the experiment's actionQue and dispatches\r\nin sequence upon each observation of state.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport { Action, primeAction } from '../../model/action';\r\nimport { PrincipleFunction } from '../../model/principle';\r\nimport { Concepts } from '../../model/concept';\r\nimport { UnifiedSubject } from '../../model/stagePlanner';\r\nimport { selectUnifiedState } from '../../model/selector';\r\nimport { ExperimentState, experimentName } from './experiment.concept';\r\nimport { axiumRegisterStagePlanner } from '../axium/qualities/registerStagePlanner.quality';\r\nimport { axiumSelectOpen } from '../axium/axium.selector';\r\n\r\nexport const experimentActionQuePrinciple: PrincipleFunction = (\r\n  observer: Subscriber<Action>,\r\n  _concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  let readyToGo = false;\r\n  const plan = concepts$.stage('Experiment Principle Plan', [\r\n    (concepts, dispatch) => {\r\n      dispatch(primeAction(concepts, axiumRegisterStagePlanner({conceptName: experimentName, stagePlanner: plan})), {\r\n        on: {\r\n          selector: axiumSelectOpen,\r\n          expected: true,\r\n        },\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (cpts, _) => {\r\n      const concepts = cpts;\r\n      const experimentState = selectUnifiedState<ExperimentState>(concepts, semaphore);\r\n      if (experimentState && experimentState.actionQue.length > 0) {\r\n        if (!readyToGo) {\r\n          readyToGo = true;\r\n          setTimeout(() => {\r\n            readyToGo = false;\r\n            const nextAction = experimentState.actionQue.shift();\r\n            if (nextAction) {\r\n              experimentState.actionQue = [... experimentState.actionQue];\r\n              concepts$.next(concepts);\r\n              observer.next(nextAction);\r\n            } else {\r\n              experimentState.actionQue = [];\r\n              concepts$.next(concepts);\r\n            }\r\n          }, 400);\r\n        }\r\n      }\r\n    }\r\n  ]);\r\n};"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will increment state by one.\r\nThen its method will asynchronously unify the state's id value onto the strategy.":{"type":"project","content":"import { MethodCreator } from '../../../model/concept';\r\nimport { Action, prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createAsyncMethodWithState } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\n\r\nexport const experimentAsyncIterateIdThenReceiveInMethodType\r\n  = 'Experiment asynchronously iterate ID then receive in Method via State';\r\n\r\nexport const experimentAsyncIterateIdThenReceiveInMethod = prepareActionCreator(experimentAsyncIterateIdThenReceiveInMethodType);\r\n\r\nconst experimentAsyncIterateIdThenReceiveInMethodCreator: MethodCreator = (concepts$?: UnifiedSubject, semaphore?: number) =>\r\n  createAsyncMethodWithState<ExperimentState>((controller, action, state) => {\r\n    setTimeout(() => {\r\n      if (action.strategy) {\r\n        const data = strategyData_unifyData<ExperimentState>(action.strategy, {id: state.id});\r\n        const strategy = strategySuccess(action.strategy, data);\r\n        controller.fire(strategy);\r\n      }\r\n      controller.fire(action);\r\n    }, 50);\r\n  }, concepts$ as UnifiedSubject, semaphore as number);\r\n\r\nfunction experimentAsyncIterateIdThenReceiveInMethodReducer(state: ExperimentState, _: Action): ExperimentState {\r\n  return {\r\n    ...state,\r\n    id: state.id + 1\r\n  };\r\n}\r\n\r\nexport const experimentAsyncIterateIdThenReceiveInMethodQuality = createQuality(\r\n  experimentAsyncIterateIdThenReceiveInMethodType,\r\n  experimentAsyncIterateIdThenReceiveInMethodReducer,\r\n  experimentAsyncIterateIdThenReceiveInMethodCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will check in the next action\r\nin the current strategy to the state's actionQue.":{"type":"project","content":"import { Action, prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { axiumConcludeType } from '../../axium/qualities/conclude.quality';\r\nimport { ExperimentState } from '../experiment.concept';\r\n\r\nexport const experimentCheckInStrategyType = 'Experiment Check in Action';\r\n\r\nexport const experimentCheckInStrategy = prepareActionCreator(experimentCheckInStrategyType);\r\n\r\nfunction experimentCheckInStrategyReducer(state: ExperimentState, action: Action): ExperimentState {\r\n  if (action.strategy) {\r\n    const nextAction = strategySuccess(action.strategy);\r\n    if (nextAction.type !== axiumConcludeType) {\r\n      return {\r\n        ...state,\r\n        actionQue: [... state.actionQue, nextAction]\r\n      };\r\n    }\r\n  }\r\n  return {\r\n    ...state\r\n  };\r\n}\r\n\r\nexport const checkInStrategyQuality = createQuality(\r\n  experimentCheckInStrategyType,\r\n  experimentCheckInStrategyReducer,\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will increment the state's ID.\r\nThen debounce the action via the qualities method that will then unify the state's id into the strategy's data.":{"type":"project","content":"import { MethodCreator } from '../../../model/concept';\r\nimport { Action, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createAsyncMethodDebounceWithState } from '../../../model/method';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\n\r\nexport type ExperimentDebounceAsyncIterateIdThenReceiveInMethodPayload = {\r\n  setId: number;\r\n}\r\nexport const experimentDebounceAsyncIterateIdThenReceiveInMethodType\r\n  = 'Debounce Experiment asynchronously iterate ID then receive in Method via State';\r\nexport const experimentDebounceAsyncIterateIdThenReceiveInMethod\r\n  = prepareActionWithPayloadCreator<ExperimentDebounceAsyncIterateIdThenReceiveInMethodPayload>(\r\n    experimentDebounceAsyncIterateIdThenReceiveInMethodType\r\n  );\r\n\r\nconst experimentDebounceAsyncIterateIdThenReceiveInMethodCreator: MethodCreator = (concepts$?: UnifiedSubject, semaphore?: number) =>\r\n  createAsyncMethodDebounceWithState<ExperimentState>((controller, action, state) => {\r\n    setTimeout(() => {\r\n      const payload = selectPayload<ExperimentDebounceAsyncIterateIdThenReceiveInMethodPayload>(action);\r\n      if (action.strategy) {\r\n        const data = strategyData_unifyData<ExperimentState & ExperimentDebounceAsyncIterateIdThenReceiveInMethodPayload>(\r\n          action.strategy,\r\n          {\r\n            id: state.id,\r\n            setId: payload.setId\r\n          }\r\n        );\r\n        const strategy = strategySuccess(action.strategy, data);\r\n        controller.fire(strategy);\r\n      }\r\n      controller.fire(action);\r\n    }, 50);\r\n  }, concepts$ as UnifiedSubject, semaphore as number, 500);\r\n\r\nfunction experimentDebounceAsyncIterateIdThenReceiveInMethodReducer(state: ExperimentState, _: Action): ExperimentState {\r\n  return {\r\n    ...state,\r\n    id: state.id + 1\r\n  };\r\n}\r\n\r\nexport const experimentDebounceAsyncIterateIdThenReceiveInMethodQuality = createQuality(\r\n  experimentDebounceAsyncIterateIdThenReceiveInMethodType,\r\n  experimentDebounceAsyncIterateIdThenReceiveInMethodReducer,\r\n  experimentDebounceAsyncIterateIdThenReceiveInMethodCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will asynchronously debounce the next action\r\nin the ongoing strategy.":{"type":"project","content":"import { MethodCreator, defaultReducer } from '../../../model/concept';\r\nimport { prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { createAsyncMethodDebounce } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\n\r\nexport const experimentAsyncDebounceNextActionNodeType = 'Experiment will debounce incoming actions within set duration asynchronously';\r\nexport const experimentAsyncDebounceNextActionNode = prepareActionCreator(experimentAsyncDebounceNextActionNodeType);\r\n\r\nexport const experimentDebounceNextActionNodeMethodCreator: MethodCreator = () => createAsyncMethodDebounce((controller, action) => {\r\n  setTimeout(() => {\r\n    if (action.strategy) {\r\n      controller.fire(strategySuccess(action.strategy));\r\n    } else {\r\n      controller.fire(action);\r\n    }\r\n  }, 50);\r\n}, 500);\r\n\r\nexport const asyncDebounceNextActionNodeQuality = createQuality(\r\n  experimentAsyncDebounceNextActionNodeType,\r\n  defaultReducer,\r\n  experimentDebounceNextActionNodeMethodCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will iterate the state ID.\r\nThen debounce the quality of actions within a range. To dispatch the most recent action after the specified time elapses.\r\nThat will finally unify the state id and setId from the payload into the most recent strategies data field.":{"type":"project","content":"import { MethodCreator } from '../../../model/concept';\r\nimport { Action, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createMethodDebounceWithState } from '../../../model/method';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\n\r\nexport type ExperimentDebounceIterateIdThenReceiveInMethodPayload = {\r\n  setId: number;\r\n}\r\nexport const experimentDebounceIterateIdThenReceiveInMethodType =\r\n  'Experiment debounce iterate ID then receive in Method via State';\r\n\r\nexport const experimentDebounceIterateIdThenReceiveInMethod =\r\n  prepareActionWithPayloadCreator<ExperimentDebounceIterateIdThenReceiveInMethodPayload>(\r\n    experimentDebounceIterateIdThenReceiveInMethodType\r\n  );\r\n\r\nconst experimentDebounceIterateIdThenReceiveInMethodCreator: MethodCreator = (concepts$?: UnifiedSubject, semaphore?: number) =>\r\n  createMethodDebounceWithState<ExperimentState>((action, state) => {\r\n    const payload = selectPayload<ExperimentDebounceIterateIdThenReceiveInMethodPayload>(action);\r\n    if (action.strategy) {\r\n      const data = strategyData_unifyData<ExperimentState & ExperimentDebounceIterateIdThenReceiveInMethodPayload>(action.strategy, {\r\n        id: state.id,\r\n        setId: payload.setId\r\n      });\r\n      const strategy = strategySuccess(action.strategy, data);\r\n      return strategy;\r\n    }\r\n    return action;\r\n  }, concepts$ as UnifiedSubject, semaphore as number, 500);\r\n\r\nfunction experimentDebounceIterateIdThenReceiveInMethodReducer(state: ExperimentState, _: Action): ExperimentState {\r\n  return {\r\n    ...state,\r\n    id: state.id + 1\r\n  };\r\n}\r\n\r\nexport const experimentDebounceIterateIdThenReceiveInMethodQuality = createQuality(\r\n  experimentDebounceIterateIdThenReceiveInMethodType,\r\n  experimentDebounceIterateIdThenReceiveInMethodReducer,\r\n  experimentDebounceIterateIdThenReceiveInMethodCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will simply debounce actions till the most\r\nrecent. Then dispatch the most recent's next action via the supplied action strategy.":{"type":"project","content":"import { MethodCreator, defaultReducer } from '../../../model/concept';\r\nimport { prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { createMethodDebounce } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\n\r\nexport const experimentDebounceNextActionNodeType = 'Experiment will debounce incoming actions within set duration';\r\nexport const experimentDebounceNextActionNode = prepareActionCreator(experimentDebounceNextActionNodeType);\r\n\r\nexport const experimentDebounceNextActionNodeMethodCreator: MethodCreator = () => createMethodDebounce((action) => {\r\n  if (action.strategy) {\r\n    return strategySuccess(action.strategy);\r\n  } else {\r\n    return action;\r\n  }\r\n}, 500);\r\n\r\nexport const debounceNextActionNodeQuality = createQuality(\r\n  experimentDebounceNextActionNodeType,\r\n  defaultReducer,\r\n  experimentDebounceNextActionNodeMethodCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will iterate the ID and then\r\nset the id supplied to the method into the strategy's data field.":{"type":"project","content":"import { MethodCreator } from '../../../model/concept';\r\nimport { Action, prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createMethodWithState } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\n\r\nexport const experimentIterateIdThenReceiveInMethodType = 'Experiment iterate ID then receive in Method via State';\r\n\r\nexport const experimentIterateIdThenReceiveInMethod = prepareActionCreator(experimentIterateIdThenReceiveInMethodType);\r\n\r\nconst experimentIterateIdThenReceiveInMethodCreator: MethodCreator = (concepts$?: UnifiedSubject, semaphore?: number) =>\r\n  createMethodWithState<ExperimentState>((action, state) => {\r\n    if (action.strategy) {\r\n      const data = strategyData_unifyData<ExperimentState>(action.strategy, {id: state.id});\r\n      const strategy = strategySuccess(action.strategy, data);\r\n      return strategy;\r\n    }\r\n    return action;\r\n  }, concepts$ as UnifiedSubject, semaphore as number);\r\n\r\nfunction experimentIterateIdThenReceiveInMethodReducer(state: ExperimentState, _: Action): ExperimentState {\r\n  return {\r\n    ...state,\r\n    id: state.id + 1\r\n  };\r\n}\r\n\r\nexport const experimentIterateIdThenReceiveInMethodQuality = createQuality(\r\n  experimentIterateIdThenReceiveInMethodType,\r\n  experimentIterateIdThenReceiveInMethodReducer,\r\n  experimentIterateIdThenReceiveInMethodCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will set mock to true.":{"type":"project","content":"import { defaultMethodCreator } from '../../../model/concept';\r\nimport { Action, prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\n\r\nexport const experimentMockTrueType = 'Experiment mock set to True';\r\n\r\nexport const experimentMockTrue = prepareActionCreator(experimentMockTrueType);\r\n\r\nexport function checkInStrategyReducer(state: ExperimentState, action: Action): ExperimentState {\r\n  return {\r\n    ...state,\r\n    mock: true\r\n  };\r\n}\r\n\r\nexport const mockToTrueQuality = createQuality(\r\n  experimentMockTrueType,\r\n  checkInStrategyReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will recursively dispatch the incoming action,\r\nlimited via a control variable that is an arbitrary string array that is shifted until depleted.":{"type":"project","content":"import { MethodCreator } from '../../../model/concept';\r\nimport { Action, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createAsyncMethodWithState } from '../../../model/method';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { strategyRecurse, strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\n\r\nexport type ExperimentRecurseIterateId = {controlling: string[]};\r\nexport const experimentRecurseIterateIdType\r\n  = 'Asynchronous experiment, recursively iterate ID and receive in Method via State';\r\n\r\nexport const experimentRecurseIterateId = prepareActionWithPayloadCreator<ExperimentRecurseIterateId>(experimentRecurseIterateIdType);\r\n\r\nconst experimentRecurseIterateIdCreator: MethodCreator = (concepts$?: UnifiedSubject, semaphore?: number) =>\r\n  createAsyncMethodWithState<ExperimentState>((controller, action, state) => {\r\n    setTimeout(() => {\r\n      const payload = selectPayload<ExperimentRecurseIterateId>(action);\r\n      payload.controlling.shift();\r\n      if (action.strategy) {\r\n        const data = strategyData_unifyData<ExperimentState>(action.strategy, {id: state.id});\r\n        if (payload.controlling.length > 0) {\r\n          const strategy = strategyRecurse(action.strategy, {payload});\r\n          controller.fire(strategy);\r\n        } else {\r\n          const strategy = strategySuccess(action.strategy, data);\r\n          controller.fire(strategy);\r\n        }\r\n      }\r\n      controller.fire(action);\r\n    }, 50);\r\n  }, concepts$ as UnifiedSubject, semaphore as number);\r\n\r\nfunction experimentRecurseIterateIdReducer(state: ExperimentState, _: Action): ExperimentState {\r\n  return {\r\n    ...state,\r\n    id: state.id + 1\r\n  };\r\n}\r\n\r\nexport const experimentRecurseIterateIdQuality = createQuality(\r\n  experimentRecurseIterateIdType,\r\n  experimentRecurseIterateIdReducer,\r\n  experimentRecurseIterateIdCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will iterate the id then\r\nasynchronously dispatch the next action in the incoming strategy, then throttle the quality for a period of time.":{"type":"project","content":"import { MethodCreator } from '../../../model/concept';\r\nimport { Action, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createAsyncMethodThrottleWithState } from '../../../model/method';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\n\r\nexport type ExperimentThrottleAsyncIterateIdThenReceiveInMethodPayload = {\r\n  setId: number;\r\n}\r\nexport const experimentThrottleAsyncIterateIdThenReceiveInMethodType\r\n  = 'Action Debounce Experiment asynchronously iterate ID then receive in Method via State';\r\nexport const experimentThrottleAsyncIterateIdThenReceiveInMethod\r\n  = prepareActionWithPayloadCreator<ExperimentThrottleAsyncIterateIdThenReceiveInMethodPayload>(\r\n    experimentThrottleAsyncIterateIdThenReceiveInMethodType\r\n  );\r\n\r\nconst experimentThrottleAsyncIterateIdThenReceiveInMethodCreator: MethodCreator = (concepts$?: UnifiedSubject, semaphore?: number) =>\r\n  createAsyncMethodThrottleWithState<ExperimentState>((controller, action, state) => {\r\n    setTimeout(() => {\r\n      const payload = selectPayload<ExperimentThrottleAsyncIterateIdThenReceiveInMethodPayload>(action);\r\n      if (action.strategy) {\r\n        const data = strategyData_unifyData<ExperimentState & ExperimentThrottleAsyncIterateIdThenReceiveInMethodPayload>(\r\n          action.strategy,\r\n          {\r\n            id: state.id,\r\n            setId: payload.setId\r\n          }\r\n        );\r\n        const strategy = strategySuccess(action.strategy, data);\r\n        controller.fire(strategy);\r\n      }\r\n      controller.fire(action);\r\n    }, 50);\r\n  }, concepts$ as UnifiedSubject, semaphore as number, 500);\r\n\r\nfunction experimentThrottleAsyncIterateIdThenReceiveInMethodReducer(state: ExperimentState, _: Action): ExperimentState {\r\n  return {\r\n    ...state,\r\n    id: state.id + 1\r\n  };\r\n}\r\n\r\nexport const experimentThrottleAsyncIterateIdThenReceiveInMethodQuality = createQuality(\r\n  experimentThrottleAsyncIterateIdThenReceiveInMethodType,\r\n  experimentThrottleAsyncIterateIdThenReceiveInMethodReducer,\r\n  experimentThrottleAsyncIterateIdThenReceiveInMethodCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will iterate the id, then\r\ndispatch the next action in the incoming strategy, then throttle the quality for a period of time.":{"type":"project","content":"import { MethodCreator } from '../../../model/concept';\r\nimport { Action, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { ExperimentState } from '../experiment.concept';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { createMethodThrottleWithState } from '../../../model/method';\r\nimport { selectPayload } from '../../../model/selector';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\n\r\nexport type ExperimentThrottleIterateIdThenReceiveInMethodPayload = {\r\n  setId: number;\r\n}\r\nexport const experimentThrottleIterateIdThenReceiveInMethodType =\r\n  'Experiment throttle iterate ID then receive in Method via State';\r\n\r\nexport const experimentThrottleIterateIdThenReceiveInMethod =\r\n  prepareActionWithPayloadCreator<ExperimentThrottleIterateIdThenReceiveInMethodPayload>(\r\n    experimentThrottleIterateIdThenReceiveInMethodType\r\n  );\r\n\r\nconst experimentThrottleIterateIdThenReceiveInMethodCreator: MethodCreator = (concepts$?: UnifiedSubject, semaphore?: number) =>\r\n  createMethodThrottleWithState<ExperimentState>((action, state) => {\r\n    const payload = selectPayload<ExperimentThrottleIterateIdThenReceiveInMethodPayload>(action);\r\n    if (action.strategy) {\r\n      const data = strategyData_unifyData<ExperimentState & ExperimentThrottleIterateIdThenReceiveInMethodPayload>(action.strategy, {\r\n        id: state.id,\r\n        setId: payload.setId\r\n      });\r\n      const strategy = strategySuccess(action.strategy, data);\r\n      return strategy;\r\n    }\r\n    return action;\r\n  }, concepts$ as UnifiedSubject, semaphore as number, 500);\r\n\r\nfunction experimentThrottleIterateIdThenReceiveInMethodReducer(state: ExperimentState, _: Action): ExperimentState {\r\n  return {\r\n    ...state,\r\n    id: state.id + 1\r\n  };\r\n}\r\n\r\nexport const experimentThrottleIterateIdThenReceiveInMethodQuality = createQuality(\r\n  experimentThrottleIterateIdThenReceiveInMethodType,\r\n  experimentThrottleIterateIdThenReceiveInMethodReducer,\r\n  experimentThrottleIterateIdThenReceiveInMethodCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will asynchronously dispatch the next\r\naction in the incoming strategy via an inner timer.":{"type":"project","content":"import { MethodCreator, defaultReducer } from '../../../model/concept';\r\nimport { prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { createAsyncMethod } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { axiumConclude } from '../../axium/qualities/conclude.quality';\r\n\r\nexport const experimentTimerEmitActionType = 'Experiment create async method with timer, to return action';\r\nexport const experimentTimerEmitAction = prepareActionCreator(experimentTimerEmitActionType);\r\n\r\nexport const experimentTimerEmitActionMethodCreator: MethodCreator = () => createAsyncMethod((controller, action) => {\r\n  setTimeout(() => {\r\n    if (action.strategy) {\r\n      controller.fire(strategySuccess(action.strategy));\r\n    } else {\r\n      controller.fire(axiumConclude());\r\n    }\r\n  }, 50);\r\n});\r\n\r\nexport const timerEmitActionQuality = createQuality(\r\n  experimentTimerEmitActionType,\r\n  defaultReducer,\r\n  experimentTimerEmitActionMethodCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a quality that will asynchronously dispatch the\r\nnext action in the ActionStrategy via a timeout. While appending to the strategy's data field the current mock value from state.":{"type":"project","content":"import { MethodCreator, defaultReducer } from '../../../model/concept';\r\nimport { prepareActionCreator } from '../../../model/action';\r\nimport { createQuality } from '../../../model/concept';\r\nimport { createAsyncMethodWithState } from '../../../model/method';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { axiumConclude } from '../../axium/qualities/conclude.quality';\r\nimport { UnifiedSubject } from '../../../model/stagePlanner';\r\nimport { strategyData_unifyData } from '../../../model/actionStrategyData';\r\nimport { ExperimentState } from '../experiment.concept';\r\n\r\nexport const experimentTimerEmitActionWithStateType = 'Experiment create async method with timer and state, to return action';\r\nexport const experimentTimerEmitActionWithState = prepareActionCreator(experimentTimerEmitActionWithStateType);\r\n\r\nexport const experimentTimerEmitActionWithStateMethodCreator: MethodCreator = (concepts$?: UnifiedSubject, semaphore?: number) =>\r\n  createAsyncMethodWithState<ExperimentState>((controller, action, state) => {\r\n    setTimeout(() => {\r\n      if (action.strategy) {\r\n        const data = strategyData_unifyData(action.strategy, { mock: state.mock });\r\n        controller.fire(strategySuccess(action.strategy, data));\r\n      } else {\r\n        controller.fire(axiumConclude());\r\n      }\r\n    }, 50);\r\n  }, concepts$ as UnifiedSubject, semaphore as number);\r\n\r\nexport const timerEmitActionWithStateQuality = createQuality(\r\n  experimentTimerEmitActionWithStateType,\r\n  defaultReducer,\r\n  experimentTimerEmitActionWithStateMethodCreator\r\n);"},"For the graph programming framework Stratimux and Experiment Concept, generate a strategy that will debounce next action to be dispatched.\r\nThen when the debounce time expires enacts the counter add one quality.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { counterAdd } from '../../counter/qualities/add.quality';\r\nimport { experimentAsyncDebounceNextActionNode } from '../qualities/debounceAsyncNextActionNode.quality';\r\n\r\nexport const experimentAsyncDebounceAddOneTopic = 'Async debounce add one';\r\nexport function experimentAsyncDebounceAddOneStrategy(): ActionStrategy {\r\n  const stepTwo = createActionNode(counterAdd(), {\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n    agreement: 1000,\r\n  });\r\n  const stepOne = createActionNode(experimentAsyncDebounceNextActionNode(), {\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n    agreement: 1000,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentAsyncDebounceAddOneTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept, generate an ActionStrategy that will dispatch the\r\nasync iterate id that will later notify the Axium of its conclusion.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentAsyncIterateIdThenReceiveInMethod } from '../qualities/asyncIterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentAsyncIterateIdThenAddToDataTopic = 'Async iterate experiment ID then add to strategy data';\r\nexport function experimentAsyncIterateIdThenAddToData(): ActionStrategy {\r\n  const stepOne = createActionNode(experimentAsyncIterateIdThenReceiveInMethod(), {\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentAsyncIterateIdThenAddToDataTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept, generate a strategy that will debounce the step in the strategy.\r\nThe final step of the strategy will increment the Counter's count by one.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { counterAdd } from '../../counter/qualities/add.quality';\r\nimport { experimentDebounceNextActionNode } from '../qualities/debounceNextActionNode.quality';\r\n\r\nexport const experimentDebounceAddOneTopic = 'Debounce add one';\r\nexport function experimentDebounceAddOneStrategy(): ActionStrategy {\r\n  const stepTwo = createActionNode(counterAdd(), {\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n    agreement: 1000,\r\n  });\r\n  const stepOne = createActionNode(experimentDebounceNextActionNode(), {\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: null,\r\n    agreement: 1000,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentDebounceAddOneTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept,\r\ngenerate a single step strategy that will iterate the Experiment state ID,\r\nthen debounce and asynchronously notify the Axium of the strategy's conclusion.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentDebounceAsyncIterateIdThenReceiveInMethod } from '../qualities/debounceAsyncIterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentDebounceAsyncIterateIdThenAddToDataTopic = 'Debounce async iterate experiment ID then add to strategy data';\r\nexport function experimentDebounceAsyncIterateIdThenAddToData(setId: number): ActionStrategy {\r\n  const stepOne = createActionNode(experimentDebounceAsyncIterateIdThenReceiveInMethod({setId}), {\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentDebounceAsyncIterateIdThenAddToDataTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept, generate an ActionStrategy that will iterate the Experiment ID,\r\nthen debounce notify the Axium of its conclusion while appending the ID to its data field.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentDebounceIterateIdThenReceiveInMethod } from '../qualities/debounceIterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentDebounceIterateIdThenAddToDataTopic = 'Debounce iterate experiment ID then add to strategy data';\r\nexport function experimentDebounceIterateIdThenAddToData(setId: number): ActionStrategy {\r\n  const stepOne = createActionNode(experimentDebounceIterateIdThenReceiveInMethod({setId}), {\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentDebounceIterateIdThenAddToDataTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will take ownership of the Counter's count state property.\r\nThen proceed to increment and decrement the count over a sequence that in total only increments to count by one.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concepts} from '../../../model/concept';\r\nimport { getSemaphore } from '../../../model/action';\r\nimport { counterAdd, counterAddType } from '../../counter/qualities/add.quality';\r\nimport { counterSubtract, counterSubtractType } from '../../counter/qualities/subtract.quality';\r\nimport { counterName } from '../../counter/counter.concept';\r\nimport { counterSelectCount } from '../../counter/counter.selector';\r\nimport { ownershipBackTrack, ownershipBackTrackType } from '../../ownership/qualities/backTrack.quality';\r\nimport { ownershipName } from '../../ownership/ownership.concept';\r\n\r\nexport const experimentCountingTopic = 'Counting Strategy';\r\nexport function experimentCountingStrategy(): ActionStrategy {\r\n  const backTrack = createActionNode(ownershipBackTrack(), {\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n  const stepFive = createActionNode(counterSubtract(),{\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'and finally',\r\n      denoter: 'One.',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepFour = createActionNode(counterAdd(), {\r\n    successNode: stepFive,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepThree = createActionNode(counterAdd(), {\r\n    successNode: stepFour,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepTwo = createActionNode(counterSubtract(), {\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepOne = createActionNode(counterAdd(), {\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentCountingTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will take ownership of the Counter's count state property.\r\nThen prime each step to avoid a semaphore look up at run time. That will then increment and decrement the count over a sequence that\r\nin total only increments to count by one. But only if it has ownership of the Counter's count state property.\r\nIf the count is owned by another strategy. The strategy will enact a back tracking action.\r\nSo that the original action may be dispatched into the Axium once ownership has been relieved from the other strategies.":{"type":"project","content":"export const experimentPrimedCountingTopic = 'Counting Strategy with Primed Actions';\r\nexport function experimentPrimedCountingStrategy(concepts: Concepts): ActionStrategy {\r\n  const addSemaphore = getSemaphore(concepts, counterName, counterAddType);\r\n  const subtractSemaphore = getSemaphore(concepts, counterName, counterSubtractType);\r\n  const backTrackSemaphore = getSemaphore(concepts, ownershipName, ownershipBackTrackType);\r\n  const backTrack = createActionNode(ownershipBackTrack(), {\r\n    semaphore: backTrackSemaphore,\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n  const stepFour = createActionNode(counterAdd(), {\r\n    semaphore: addSemaphore,\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'and finally',\r\n      denoter: 'One.',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepThree = createActionNode(counterAdd(), {\r\n    semaphore: addSemaphore,\r\n    successNode: stepFour,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepTwo = createActionNode(counterSubtract(), {\r\n    semaphore: subtractSemaphore,\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n  const stepOne = createActionNode(counterAdd(), {\r\n    semaphore: subtractSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: '',\r\n      denoter: 'One;',\r\n    },\r\n    failureNode: backTrack,\r\n    agreement: 1000,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentPrimedCountingTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept,\r\ngenerate an ActionStrategy that will iterate the Experiment's state ID.\r\nThen notify the Axium of its conclusion while appending the ID to the strategy's data field.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentIterateIdThenReceiveInMethod } from '../qualities/iterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentIterateIdThenAddToDataTopic = 'Iterate experiment ID then add to strategy data';\r\nexport function iterateIdThenAddToData(): ActionStrategy {\r\n  const stepOne = createActionNode(experimentIterateIdThenReceiveInMethod(), {\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentIterateIdThenAddToDataTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will punt a counting strategy in favor of a new\r\nstrategy that will check in the punted strategy into an actionQue. That will later be dispatched via a principle.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy, strategyPunt } from '../../../model/actionStrategy';\r\nimport { counterSelectCount } from '../../counter/counter.selector';\r\nimport { experimentCheckInStrategy } from '../qualities/checkInStrategy.quality';\r\nimport { experimentCountingStrategy } from './experimentCounting.strategy';\r\n\r\nexport const experimentPuntCountingStrategyTopic = 'This will Punt the Counting Strategy into the Experiment\\'s Action Que';\r\nexport function experimentPuntCountingStrategy(): ActionStrategy {\r\n  const stepOne = createActionNode(experimentCheckInStrategy(), {\r\n    successNode: null,\r\n    failureNode: null,\r\n    keyedSelectors: [counterSelectCount]\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentPuntCountingStrategyTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return strategyPunt(experimentCountingStrategy(), createStrategy(params));\r\n}"},"For the graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will cursively iterate the Experiment's state ID,\r\nthat is limited by an incoming array of strings.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentRecurseIterateId } from '../qualities/recurseIncrementId.quality';\r\n\r\nexport const experimentRecursivelyIterateIdTopic = 'Recursively iterate experiment ID then add to strategy data';\r\nexport function experimentRecursivelyIterateId(controlling: string[]): ActionStrategy {\r\n  const stepOne = createActionNode(experimentRecurseIterateId({controlling}), {\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentRecursivelyIterateIdTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept,\r\ngenerate an ActionStrategy that will iterate the Experiment's ID property,\r\nthen throttle the next action to be asynchronously dispatched from the quality's method. That will then set the current ID it has received\r\nto the strategy's data field.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport {\r\n  experimentThrottleAsyncIterateIdThenReceiveInMethod\r\n} from '../qualities/throttleAsyncIterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentThrottleAsyncIterateIdThenAddToDataTopic = 'Throttle Async iterate experiment ID then add to strategy data';\r\nexport function experimentThrottleAsyncIterateIdThenAddToData(setId: number): ActionStrategy {\r\n  const stepOne = createActionNode(experimentThrottleAsyncIterateIdThenReceiveInMethod({setId}), {\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentThrottleAsyncIterateIdThenAddToDataTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will iterate an ID state property for the Concept\r\nExperiment. Then dispatch the first action for a period that is received in the action's method. That will then\r\nunify the the ID the method has received onto the strategy's state field. Then finally notify the Axium of the\r\nstrategy's conclusion.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentThrottleIterateIdThenReceiveInMethod } from '../qualities/throttleIterateIdThenReceiveInMethod.quality';\r\n\r\nexport const experimentThrottleIterateIdThenAddToDataTopic = 'Throttle iterate experiment ID then add to strategy data';\r\nexport function experimentThrottleIterateIdThenAddToData(setId: number): ActionStrategy {\r\n  const stepOne = createActionNode(experimentThrottleIterateIdThenReceiveInMethod({setId}), {\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentThrottleIterateIdThenAddToDataTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept,\r\ngenerate a strategy that will eventually set the Experiment's mock property\r\nto true. This is accomplished via a timer emit action quality. That will then finally dispatch the setting action.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentMockTrue } from '../qualities/mockTrue.quality';\r\nimport { experimentTimerEmitAction } from '../qualities/timerEmitAction.quality';\r\n\r\nexport const experimentTimedMockToTrueTopic = 'This will use a async method to eventually set mock to True';\r\nexport function experimentTimedMockToTrue(): ActionStrategy {\r\n  const stepTwo = createActionNode(experimentMockTrue(), {\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n  const stepOne = createActionNode(experimentTimerEmitAction(), {\r\n    successNode: stepTwo,\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentTimedMockToTrueTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux and Experiment Concept,\r\ngenerate an ActionStrategy that will in the final step the Experiment's mock value to\r\ntrue. While attaching the original mock value to the strategy's data field. Then once its timer expires, dispatch the next\r\nstep that will finally set the value to true. Then notify the axium of the strategy's successful conclusion.":{"type":"project","content":"import { ActionStrategy, ActionStrategyParameters, createActionNode, createStrategy } from '../../../model/actionStrategy';\r\nimport { experimentMockTrue } from '../qualities/mockTrue.quality';\r\nimport { experimentTimerEmitActionWithState } from '../qualities/timerEmitActionWithState.quality';\r\n\r\nexport const experimentTimedMockToTrueWithStateTopic =\r\n  'This will use a async method to eventually set mock to True via State and append mock to strategy data.';\r\nexport function timedMockToTrueWithState(): ActionStrategy {\r\n  const stepTwo = createActionNode(experimentMockTrue(), {\r\n    successNode: null,\r\n    failureNode: null,\r\n  });\r\n  const stepOne = createActionNode(experimentTimerEmitActionWithState(), {\r\n    successNode: stepTwo,\r\n    failureNode: null,\r\n  });\r\n\r\n  const params: ActionStrategyParameters = {\r\n    topic: experimentTimedMockToTrueWithStateTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux generate the Ownership Concept,\r\nthat will manage Stratimux's locking functionality if loaded into the Axium.\r\nThis is accomplished via a ticketing system that will set actions to pending if their associated property is currently owned via strategy\r\nthat is currently performing operations within the Axium.":{"type":"project","content":"import { createConcept } from '../../model/concept';\r\nimport { Action } from '../../model/action';\r\nimport { ownershipMode } from './ownership.mode';\r\nimport { initializeOwnershipQuality } from './qualities/initializeOwnership.quality';\r\nimport { ownershipExpirationPrinciple, ownershipPrinciple } from './ownership.principle';\r\nimport { OwnershipLedger, createOwnershipLedger } from '../../model/ownership';\r\nimport { backTrackQuality } from './qualities/backTrack.quality';\r\nimport { clearPayloadStubsQuality } from './qualities/clearPayloadStubs.quality';\r\nimport { clearStrategyStubsFromLedgerAndSelfQuality } from './qualities/clearStrategyStubsFromLedgerAndSelf.quality';\r\nimport { clearPendingActionsQuality } from './qualities/clearPendingActions.quality';\r\nimport { clearPendingActionsOfStrategyQuality } from './qualities/clearPendingActionsOfStrategy.quality';\r\nimport { resetOwnershipLedgerQuality } from './qualities/resetOwnershipLedger.quality';\r\n\r\nexport type OwnershipState = {\r\n  initialized: boolean;\r\n  ownershipLedger: OwnershipLedger;\r\n  pendingActions: Action[],\r\n  isResponsibleForMode: boolean;\r\n}\r\n\r\nexport const ownershipName = 'ownership';\r\n/**\r\n * @param isResponsibleForMode If not set, ownership assumes responsibility.\r\n */\r\nconst createOwnershipState = (isResponsibleForMode?: boolean): OwnershipState => {\r\n  return {\r\n    initialized: false,\r\n    ownershipLedger: createOwnershipLedger(),\r\n    pendingActions: [],\r\n    isResponsibleForMode: isResponsibleForMode ? isResponsibleForMode : true\r\n  };\r\n};\r\n\r\nexport const createOwnershipConcept = (isResponsibleForMode?: boolean) => {\r\n  return createConcept(\r\n    ownershipName,\r\n    createOwnershipState(isResponsibleForMode ? isResponsibleForMode : true),\r\n    [\r\n      initializeOwnershipQuality,\r\n      backTrackQuality,\r\n      clearPayloadStubsQuality,\r\n      clearStrategyStubsFromLedgerAndSelfQuality,\r\n      clearPendingActionsQuality,\r\n      clearPendingActionsOfStrategyQuality,\r\n      resetOwnershipLedgerQuality\r\n    ],\r\n    [\r\n      ownershipPrinciple,\r\n      ownershipExpirationPrinciple\r\n    ],\r\n    [ownershipMode]\r\n  );\r\n};"},"For the graph programming framework Stratimux and Ownership Concept,\r\ngenerate mode that will govern the ownership system.\r\nThis mode will pay attention to an ActionStrategy's assigned KeyedSelector and if it currently does not have\r\nownership of the value that the selector would return via the selectSlice helper function.\r\nOwnership will add that action to its actionList. That will then be monitored via an ownership principle.\r\nThis mode will also relieve ownership upon receiving concluding parts of a strategy, such as conclusion, or even\r\na bad action that signifies that the associated action was invalidated.":{"type":"project","content":"import { Subject } from 'rxjs';\r\nimport { Action } from '../../model/action';\r\nimport { Concepts } from '../../model/concept';\r\nimport { Mode } from '../../model/concept';\r\nimport { permissiveMode, blockingMode } from '../axium/axium.mode';\r\nimport { checkIn, clearStubs, ownershipShouldBlock, updateAddToPendingActions } from '../../model/ownership';\r\nimport { ActionStrategy, strategyFailed } from '../../model/actionStrategy';\r\nimport { UnifiedSubject } from '../../model/stagePlanner';\r\nimport { axiumAppendActionListToDialog } from '../axium/qualities/appendActionListToDialog.quality';\r\nimport { AxiumState } from '../axium/axium.concept';\r\nimport { failureConditions, strategyData_appendFailure } from '../../model/actionStrategyData';\r\n\r\nexport const ownershipMode: Mode = (\r\n  [_action, _concepts, action$, concepts$] : [Action, Concepts, Subject<Action>, UnifiedSubject]\r\n) => {\r\n  let action = _action;\r\n  let concepts = _concepts;\r\n  const conceptsSize = Object.keys(concepts).length;\r\n  let finalMode: Mode = permissiveMode;\r\n  const axiumState = concepts[0].state as AxiumState;\r\n  // Logical Determination: setBlockingModeType\r\n  if (action.semaphore[3] === 4) {\r\n    finalMode = blockingMode;\r\n  } else {\r\n    // This assumes that ownership will be treated as the new default mode.\r\n    finalMode = (concepts[0].mode as Mode[])[1];\r\n  }\r\n  // Logical Determination: axiumConcludeType\r\n  // If generation is set to -1, then the action is not primed.\r\n  //  Therefore we pass straight to finalMode which will recall this Mode after priming the action.\r\n  //  This guarantees that action beyond this function will have a semaphore not set to [0, 0, -1, 0]\r\n  if (conceptsSize > 1) {\r\n    if (action.semaphore[3] !== 3 && action.semaphore[3] !== 1 && action.semaphore[2] !== axiumState.generation) {\r\n    // Check In Logic\r\n      const shouldBlock = ownershipShouldBlock(concepts, action);\r\n      if (shouldBlock) {\r\n        if (action.strategy) {\r\n          const strategy = action.strategy;\r\n          if (action.strategy.currentNode.failureNode === null) {\r\n          // This assumes that the Strategy does not account for the Block\r\n            let nextAction = strategyFailed(\r\n              strategy,\r\n              strategyData_appendFailure(strategy, failureConditions.ownershipBlocked)\r\n            );\r\n            // Logical Determination: axiumConcludeType\r\n            // eslint-disable-next-line max-depth\r\n            if (nextAction.semaphore[3] === 3) {\r\n              concepts = clearStubs(concepts, nextAction.strategy as ActionStrategy);\r\n              nextAction = axiumAppendActionListToDialog({\r\n                actionList: action.strategy.actionList,\r\n                strategyTopic: action.strategy.topic,\r\n                strategyData: action.strategy.data\r\n              });\r\n            }\r\n            finalMode([nextAction, concepts, action$, concepts$]);\r\n          } else {\r\n          // This assumes that the Strategy is accounting for the Block\r\n            // console.log('Check Action Failed1', action);\r\n            [concepts, action] = checkIn(concepts, action);\r\n            const nextAction = strategyFailed(\r\n              strategy,\r\n              strategyData_appendFailure(strategy, failureConditions.ownershipBlocked)\r\n            );\r\n            concepts = updateAddToPendingActions(concepts, nextAction);\r\n            concepts$.next(concepts);\r\n          }\r\n        }  else {\r\n        // Principle is then responsible to dispatch these actions;\r\n          concepts = updateAddToPendingActions(concepts, action);\r\n          concepts$.next(concepts);\r\n        }\r\n      // } else if (action.keyedSelectors) {\r\n      } else if (action.strategy) {\r\n        [concepts, action] = checkIn(concepts, action);\r\n        finalMode([action, concepts, action$, concepts$]);\r\n      } else {\r\n      // Free to Run\r\n        finalMode([action, concepts, action$, concepts$]);\r\n      }\r\n    // Logical Determination: axiumConcludeType\r\n    } else if (action.semaphore[3] !== 3 && action.semaphore[1] !== 1) {\r\n      finalMode([action, concepts, action$, concepts$]);\r\n\r\n    // Logical Determination: axiumConcludeType, axiumBadActionType\r\n    } else if (action.strategy?.stubs && (action.semaphore[3] === 3 || action.semaphore[3] === 1)) {\r\n      concepts = clearStubs(concepts, action.strategy);\r\n      concepts$.next(concepts);\r\n      if (action.semaphore[3] === 1) {\r\n        finalMode([action, concepts, action$, concepts$]);\r\n      }\r\n    } else if (action.semaphore[3] === 1) {\r\n      finalMode([action, concepts, action$, concepts$]);\r\n    }\r\n  } else {\r\n    finalMode([action, concepts, action$, concepts$]);\r\n  }\r\n};"},"For the graph programming framework Stratimux and Ownership Concept,\r\ngenerate a principle will manage the ownership's pendingActions based upon the current\r\nownershipLedger's contents. Only actions that are first in all lines of their tickets set the the strategy's KeyedSelectors,\r\nmay be dispatched into the Axium. This principle will also clear duplicate strategies, and handle actions if their agreement has expired.":{"type":"project","content":"import { Subscriber } from 'rxjs';\r\nimport { Concepts } from '../../model/concept';\r\nimport { PrincipleFunction } from '../../model/principle';\r\nimport { OwnershipState, ownershipName} from '../ownership/ownership.concept';\r\nimport { ownershipSetOwnershipModeStrategy } from './strategies/setOwnerShipMode.strategy';\r\nimport { Action, areSemaphoresEqual, createAction, primeAction } from '../../model/action';\r\nimport { selectUnifiedState } from '../../model/selector';\r\nimport { strategyBegin } from '../../model/actionStrategy';\r\nimport { OwnershipTicket, createOwnershipLedger, isActionReady } from '../../model/ownership';\r\nimport { UnifiedSubject  } from '../../model/stagePlanner';\r\nimport { AxiumBadActionPayload, axiumBadActionType } from '../axium/qualities/badAction.quality';\r\nimport { axiumRegisterStagePlanner } from '../axium/qualities/registerStagePlanner.quality';\r\nimport { axiumSelectOpen } from '../axium/axium.selector';\r\nimport { failureConditions, strategyData_appendFailure } from '../../model/actionStrategyData';\r\n\r\nfunction denoteExpiredPending(action: Action): Action {\r\n  if (action.strategy) {\r\n    const strategy = action.strategy;\r\n    action.strategy.data = strategyData_appendFailure(strategy, failureConditions.ownershipExpired);\r\n  }\r\n  return action;\r\n}\r\n\r\nexport const ownershipPrinciple: PrincipleFunction = (\r\n  observer: Subscriber<Action>,\r\n  _concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  let initDispatch = false;\r\n  let finalCheck = true;\r\n  const plan = concepts$.stage('ownership Principle Plan', [\r\n    (concepts, dispatch) => {\r\n      dispatch(primeAction(concepts, axiumRegisterStagePlanner({conceptName: ownershipName, stagePlanner: plan})), {\r\n        on: {\r\n          selector: axiumSelectOpen,\r\n          expected: true,\r\n        },\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (cpts, _) => {\r\n      let concepts = cpts;\r\n      let ownershipState = selectUnifiedState<OwnershipState>(concepts, semaphore);\r\n      if (ownershipState?.initialized) {\r\n        // This will be the point of dispatch of Qued Actions\r\n        let newAction;\r\n        if (ownershipState.pendingActions.length > 0) {\r\n          // One Action at a Time\r\n          for (const action of ownershipState.pendingActions) {\r\n            let readyToGo = false;\r\n            [concepts, readyToGo] = isActionReady(concepts, action);\r\n            if (readyToGo) {\r\n              newAction = action;\r\n              break;\r\n            }\r\n          }\r\n          if (newAction) {\r\n            ownershipState = selectUnifiedState(concepts, semaphore) as OwnershipState;\r\n            const newPendingActions = [];\r\n            for (const pending of ownershipState.pendingActions) {\r\n              if (!areSemaphoresEqual(pending, newAction) && pending.expiration !== newAction.expiration) {\r\n                newPendingActions.push(pending);\r\n              } else if (areSemaphoresEqual(pending, newAction) && pending.expiration !== newAction.expiration) {\r\n                newPendingActions.push(pending);\r\n              }\r\n            }\r\n            ownershipState.pendingActions = [...newPendingActions];\r\n            concepts$.next(concepts);\r\n            observer.next(newAction);\r\n          } else if (!newAction && ownershipState.pendingActions.length !== 0) {\r\n            const payload: AxiumBadActionPayload = {\r\n              badActions: []\r\n            };\r\n            const newPending: Action[] = [];\r\n            for (const pending of ownershipState.pendingActions) {\r\n              if (pending.expiration < Date.now()) {\r\n                payload.badActions.push(denoteExpiredPending(pending));\r\n              } else {\r\n                newPending.push(pending);\r\n              }\r\n            }\r\n            if (payload.badActions.length > 0) {\r\n              newAction = createAction(axiumBadActionType, payload);\r\n              ownershipState.pendingActions = newPending;\r\n              concepts$.next(concepts);\r\n              observer.next(newAction);\r\n            } else if (finalCheck) {\r\n              finalCheck = false;\r\n              setTimeout(() => {\r\n                finalCheck = true;\r\n                concepts$.next(concepts);\r\n              }, 200);\r\n            }\r\n          }\r\n        }\r\n      } else if (!initDispatch && !ownershipState?.initialized && ownershipState?.isResponsibleForMode) {\r\n        initDispatch = true;\r\n        observer.next(\r\n          strategyBegin(\r\n            ownershipSetOwnershipModeStrategy(concepts, 'Ownership')\r\n          )\r\n        );\r\n      }\r\n    }\r\n  ]);\r\n};"},"For the graph programming framework Stratimux and Ownership Concept, generate a principle that manage clear lines of expired tickets.\r\nThis functionality is chiefly important for Actions that have moved off the current process, but will return after completing\r\ntheir strategies in outside Axiums.":{"type":"project","content":"export const ownershipExpirationPrinciple: PrincipleFunction = (\r\n  _: Subscriber<Action>,\r\n  _concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number\r\n) => {\r\n  const plan = concepts$.stage('ownership Principle Plan', [\r\n    (concepts, dispatch) => {\r\n      dispatch(primeAction(concepts, axiumRegisterStagePlanner({conceptName: ownershipName, stagePlanner: plan})), {\r\n        on: {\r\n          selector: axiumSelectOpen,\r\n          expected: true,\r\n        },\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (cpts, __) => {\r\n      const concepts = cpts;\r\n      const ownershipState = selectUnifiedState<OwnershipState>(concepts, semaphore);\r\n      if (ownershipState?.initialized) {\r\n        let modified = false;\r\n        const newLedger = createOwnershipLedger();\r\n        for (const [key, line] of ownershipState.ownershipLedger.entries()) {\r\n          const expiredTickets: OwnershipTicket[] = [];\r\n          const newLine: OwnershipTicket[] = [];\r\n          for (const ticket of line) {\r\n            if (ticket.expiration > Date.now()) {\r\n              expiredTickets.push(ticket);\r\n            } else {\r\n              newLine.push(ticket);\r\n            }\r\n          }\r\n          if (expiredTickets.length > 0 && newLine.length > 0) {\r\n            modified = true;\r\n            newLedger.set(key, newLine);\r\n          }\r\n        }\r\n        if (modified) {\r\n          ownershipState.ownershipLedger = newLedger;\r\n          concepts$.next(concepts);\r\n        }\r\n      }\r\n    }\r\n  ]);\r\n};"},"For the graph programming framework Stratimux and Ownership Concept, generate a series of KeyedSelectors for the ownership state.":{"type":"project","content":"import { KeyedSelector } from '../../model/selector';\r\n\r\nexport const ownershipSelectLedger: KeyedSelector = {\r\n  conceptName: 'ownership',\r\n  stateKeys: 'ownershipLedger'\r\n};\r\n\r\nexport const ownershipSelectInitialized: KeyedSelector = {\r\n  conceptName: 'ownership',\r\n  stateKeys: 'initialized'\r\n};"},"For the graph programming framework Stratimux and Ownership Concept, generate a quality that will back track the provided strategy.":{"type":"project","content":"import { MethodCreator, createQuality, defaultReducer } from '../../../model/concept';\r\nimport { ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { strategyBackTrack } from '../../../model/actionStrategy';\r\nimport { createMethod } from '../../../model/method';\r\n\r\nexport const ownershipBackTrackType: ActionType = 'backtracking to previous ActionNode';\r\nexport const ownershipBackTrack = prepareActionCreator(ownershipBackTrackType);\r\n\r\nconst ownershipCreateBackTrackMethodCreator: MethodCreator = () => createMethod((action) => {\r\n  if (action.strategy) {\r\n    const newAction = strategyBackTrack(action.strategy);\r\n    return newAction;\r\n  } else {\r\n    return action;\r\n  }\r\n});\r\n\r\nexport const backTrackQuality = createQuality(\r\n  ownershipBackTrackType,\r\n  defaultReducer,\r\n  ownershipCreateBackTrackMethodCreator,\r\n);"},"For the graph programming framework Stratimux and Ownership Concept,\r\ngenerate a quality that will clear the provided stubs from the current Ownership Ledger.\r\nIf no tickets exist within a line, delete that line from the ledger.":{"type":"project","content":"import { createQuality, defaultMethodCreator } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { OwnershipState } from '../ownership.concept';\r\nimport { OwnershipTicket, OwnershipTicketStub } from '../../../model/ownership';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type OwnershipClearPayloadStubsPayload = {\r\n  stubs: OwnershipTicketStub[]\r\n};\r\nexport const ownershipClearPayloadStubsType: ActionType = 'clear payload Stubs from Ownership Ledger';\r\nexport const ownershipClearPayloadStubs =\r\n  prepareActionWithPayloadCreator<OwnershipClearPayloadStubsPayload>(ownershipClearPayloadStubsType);\r\n\r\nfunction ownershipClearPayloadStubsReducer(state: OwnershipState, action: Action): OwnershipState {\r\n  const stubs = selectPayload<OwnershipClearPayloadStubsPayload>(action).stubs;\r\n  const ownershipLedger = state.ownershipLedger;\r\n  stubs.forEach(ticketStub => {\r\n    const line = ownershipLedger.get(ticketStub.key);\r\n    if (line) {\r\n      const newLine = [] as OwnershipTicket[];\r\n      for (const stub of line) {\r\n        if (stub.ticket !== ticketStub.ticket) {\r\n          newLine.push(stub);\r\n        }\r\n      }\r\n      if (newLine.length === 0) {\r\n        ownershipLedger.delete(ticketStub.key);\r\n      } else {\r\n        ownershipLedger.set(ticketStub.key, newLine);\r\n      }\r\n    }\r\n  });\r\n  return {\r\n    ...state,\r\n    ownershipLedger: ownershipLedger\r\n  };\r\n}\r\nexport const clearPayloadStubsQuality = createQuality(\r\n  ownershipClearPayloadStubsType,\r\n  ownershipClearPayloadStubsReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Ownership Concept,\r\ngenerate a quality that will clear the current pending actions list on state.":{"type":"project","content":"import { createQuality, defaultMethodCreator } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { OwnershipState } from '../ownership.concept';\r\n\r\nexport const ownershipClearPendingActionsType: ActionType = 'clear Ownership\\'s Pending Actions';\r\nexport const ownershipClearPendingActions = prepareActionCreator(ownershipClearPendingActionsType);\r\n\r\nfunction ownershipClearPendingActionsReducer(state: OwnershipState, _: Action): OwnershipState {\r\n  return {\r\n    ...state,\r\n    pendingActions: []\r\n  };\r\n}\r\nexport const clearPendingActionsQuality = createQuality(\r\n  ownershipClearPendingActionsType,\r\n  ownershipClearPendingActionsReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Ownership Concept,\r\ngenerate a quality clear pending actions of the provided ActionStrategy topic.":{"type":"project","content":"import { createQuality, defaultMethodCreator } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionWithPayloadCreator } from '../../../model/action';\r\nimport { OwnershipState } from '../ownership.concept';\r\nimport { ActionStrategyTopic } from '../../../model/actionStrategy';\r\nimport { selectPayload } from '../../../model/selector';\r\n\r\nexport type OwnershipClearPendingActionsOfStrategyPayload = {\r\n  topic: ActionStrategyTopic\r\n};\r\nexport const ownershipClearPendingActionsOfStrategyType: ActionType = 'clear Ownership\\'s Pending Actions of Strategy Topic';\r\nexport const ownershipClearPendingActionsOfStrategy =\r\n  prepareActionWithPayloadCreator<OwnershipClearPendingActionsOfStrategyPayload>(ownershipClearPendingActionsOfStrategyType);\r\n\r\nfunction ownershipClearPendingActionsOfStrategyReducer(state: OwnershipState, action: Action): OwnershipState {\r\n  const topic = selectPayload<OwnershipClearPendingActionsOfStrategyPayload>(action).topic;\r\n  const newPendingActions: Action[] = [];\r\n  for (const act of state.pendingActions) {\r\n    if (act.strategy?.topic) {\r\n      if (act.strategy.topic !== topic) {\r\n        newPendingActions.push(act);\r\n      }\r\n    }\r\n  }\r\n  return {\r\n    ...state,\r\n    pendingActions: newPendingActions\r\n  };\r\n}\r\nexport const clearPendingActionsOfStrategyQuality = createQuality(\r\n  ownershipClearPendingActionsOfStrategyType,\r\n  ownershipClearPendingActionsOfStrategyReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Ownership Concept,\r\ngenerate a quality that will clear the current strategies stubs from the\r\nownership ledger. This is to afford for strategies to relieve their ownership prior to their conclusion.":{"type":"project","content":"import { MethodCreator, createQuality } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { OwnershipState } from '../ownership.concept';\r\nimport { OwnershipTicket } from '../../../model/ownership';\r\nimport { strategySuccess } from '../../../model/actionStrategy';\r\nimport { createMethod } from '../../../model/method';\r\n\r\nexport const ownershipClearStrategyStubsFromLedgerAndSelfType: ActionType = 'clear current Strategy Stubs from Ownership Ledger and Itself';\r\nexport const ownershipClearStrategyStubsFromLedgerAndSelf = prepareActionCreator(ownershipClearStrategyStubsFromLedgerAndSelfType);\r\n\r\nconst ownershipClearStrategyStubsFromLedgerAndSelfMethodCreator: MethodCreator = () => createMethod((action) => {\r\n  if (action.strategy) {\r\n    action.strategy.stubs = undefined;\r\n    return strategySuccess(action.strategy);\r\n  }\r\n  return action;\r\n});\r\n\r\nfunction ownershipClearStrategyStubsFromLedgerAndSelfReducer(state: OwnershipState, action: Action): OwnershipState {\r\n  const stubs = action?.strategy?.stubs;\r\n  const ownershipLedger = state.ownershipLedger;\r\n  if (action.strategy && stubs) {\r\n    stubs.forEach(ticketStub => {\r\n      const line = ownershipLedger.get(ticketStub.key);\r\n      if (line) {\r\n        const newLine = [] as OwnershipTicket[];\r\n        for (const stub of line) {\r\n          if (stub.ticket !== ticketStub.ticket) {\r\n            newLine.push(stub);\r\n          }\r\n        }\r\n        if (newLine.length === 0) {\r\n          ownershipLedger.delete(ticketStub.key);\r\n        } else {\r\n          ownershipLedger.set(ticketStub.key, newLine);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  return {\r\n    ...state,\r\n    ownershipLedger: ownershipLedger\r\n  };\r\n}\r\nexport const clearStrategyStubsFromLedgerAndSelfQuality = createQuality(\r\n  ownershipClearStrategyStubsFromLedgerAndSelfType,\r\n  ownershipClearStrategyStubsFromLedgerAndSelfReducer,\r\n  ownershipClearStrategyStubsFromLedgerAndSelfMethodCreator\r\n);"},"For the graph programming framework Stratimux and Ownership Concept,\r\ngenerate a quality that will simply set ownership's initialized property to true.":{"type":"project","content":"import { createQuality, defaultMethodCreator } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { OwnershipState } from '../ownership.concept';\r\n\r\nexport const ownershipInitializeOwnershipType: ActionType = 'Ownership Initialize to True to enable Ownership Principle';\r\nexport const ownershipInitializeOwnership = prepareActionCreator(ownershipInitializeOwnershipType);\r\n\r\nexport function ownershipInitializeOwnershipReducer(state: OwnershipState, _: Action) {\r\n  return {\r\n    ...state,\r\n    initialized: true\r\n  };\r\n}\r\nexport const initializeOwnershipQuality = createQuality(\r\n  ownershipInitializeOwnershipType,\r\n  ownershipInitializeOwnershipReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Ownership Concept, generate a quality that hard resets the current ownership ledger.":{"type":"project","content":"import { createQuality, defaultMethodCreator } from '../../../model/concept';\r\nimport { Action, ActionType, prepareActionCreator } from '../../../model/action';\r\nimport { OwnershipState } from '../ownership.concept';\r\nimport { createOwnershipLedger } from '../../../model/ownership';\r\n\r\nexport const ownershipResetOwnershipLedgerType: ActionType = 'reset Ownership Ledger';\r\nexport const ownershipResetOwnershipLedger = prepareActionCreator(ownershipResetOwnershipLedgerType);\r\n\r\nfunction ownershipResetOwnershipLedgerReducer(state: OwnershipState, _: Action): OwnershipState {\r\n  return {\r\n    ...state,\r\n    ownershipLedger: createOwnershipLedger()\r\n  };\r\n}\r\nexport const resetOwnershipLedgerQuality = createQuality(\r\n  ownershipResetOwnershipLedgerType,\r\n  ownershipResetOwnershipLedgerReducer,\r\n  defaultMethodCreator\r\n);"},"For the graph programming framework Stratimux and Ownership Concept, generate a strategy that will set the Axium's mode to Ownership.":{"type":"project","content":"import { createStrategy, ActionStrategy, ActionStrategyParameters, createActionNode } from '../../../model/actionStrategy';\r\nimport { Concepts } from '../../../model/concept';\r\nimport { getSemaphore } from '../../../model/action';\r\nimport { ownershipInitializeOwnership, ownershipInitializeOwnershipType } from '../qualities/initializeOwnership.quality';\r\nimport { axiumSetMode, axiumSetModeType } from '../../axium/qualities/setMode.quality';\r\nimport { ownershipName } from '../ownership.concept';\r\nimport { AxiumState } from '../../axium/axium.concept';\r\nimport { axiumSetDefaultModeIndex } from '../../axium/qualities/setDefaultModeIndex.quality';\r\n\r\nexport const ownershipSetOwnerShipModeTopic = 'Axium set Mode to Ownership then Initialize Ownership Principle';\r\nexport function ownershipSetOwnershipModeStrategy(concepts: Concepts, modeName: string): ActionStrategy {\r\n  const initializeOwnershipSemaphore = getSemaphore(concepts, ownershipName, ownershipInitializeOwnershipType);\r\n  const setModeSemaphore = getSemaphore(concepts, ownershipName, axiumSetModeType);\r\n  let ownershipModeIndex = 2;\r\n  (concepts[0].state as AxiumState).modeNames.forEach((key, i) => {\r\n    if (key === ownershipName) {\r\n      ownershipModeIndex = i;\r\n    }\r\n  });\r\n\r\n  const stepThree = createActionNode(ownershipInitializeOwnership(), {\r\n    semaphore: initializeOwnershipSemaphore,\r\n    successNode: null,\r\n    successNotes: {\r\n      preposition: 'Set',\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const stepTwo = createActionNode(axiumSetDefaultModeIndex({\r\n    index: ownershipModeIndex\r\n  }), {\r\n    successNode: stepThree,\r\n    successNotes: {\r\n      preposition: 'Then'\r\n    },\r\n    failureNode: null\r\n  });\r\n  const stepOne = createActionNode(axiumSetMode({ modeIndex: ownershipModeIndex, modeName }), {\r\n    semaphore: setModeSemaphore,\r\n    successNode: stepTwo,\r\n    successNotes: {\r\n      preposition: 'Successfully'\r\n    },\r\n    failureNode: null,\r\n  });\r\n  const params: ActionStrategyParameters = {\r\n    topic: ownershipSetOwnerShipModeTopic,\r\n    initialNode: stepOne,\r\n  };\r\n\r\n  return createStrategy(params);\r\n}"},"For the graph programming framework Stratimux,\r\ndefine the current index file that exports all public functionality for the framework as a module.":{"type":"project","content":"export { createAxium, getAxiumState } from './model/axium';\r\nexport type {\r\n  ActionNode,\r\n  ActionNotes,\r\n  ActionNodeOptions,\r\n  ActionStrategy,\r\n  ActionStrategyParameters,\r\n  ActionStrategyStitch,\r\n  ActionStrategyCreator\r\n} from './model/actionStrategy';\r\nexport {\r\n  createStrategy,\r\n  createActionNode,\r\n  createActionNodeFromStrategy,\r\n  strategyBegin,\r\n  strategySuccess,\r\n  strategyFailed,\r\n  strategyDecide,\r\n  strategyPunt,\r\n  strategySequence,\r\n  strategyBackTrack,\r\n  strategyRecurse\r\n} from './model/actionStrategy';\r\nexport {\r\n  failureConditions,\r\n  strategyData_appendFailure,\r\n  strategyData_selectFailureCondition,\r\n  strategyData_clearFailureCondition,\r\n  strategyData_select,\r\n  strategyData_unifyData\r\n} from './model/actionStrategyData';\r\nexport {\r\n  createMethod,\r\n  createAsyncMethod,\r\n  createMethodWithState,\r\n  createAsyncMethodWithState,\r\n  createMethodDebounce,\r\n  createAsyncMethodDebounce,\r\n  createMethodDebounceWithState,\r\n  createAsyncMethodDebounceWithState,\r\n  createMethodThrottle,\r\n  createMethodThrottleWithState,\r\n  createAsyncMethodThrottle,\r\n  createAsyncMethodThrottleWithState,\r\n  createMethodWithConcepts,\r\n  createAsyncMethodWithConcepts,\r\n  createMethodThrottleWithConcepts,\r\n  createMethodDebounceWithConcepts,\r\n  createAsyncMethodThrottleWithConcepts,\r\n  createAsyncMethodDebounceWithConcepts\r\n} from './model/method';\r\nexport {\r\n  debounceAction,\r\n  throttleAction\r\n} from './model/actionOperators';\r\nexport type { Action, ActionType } from './model/action';\r\nexport {\r\n  primeAction,\r\n  createAction,\r\n  getSemaphore,\r\n  prepareActionCreator,\r\n  prepareActionWithPayloadCreator,\r\n  refreshAction\r\n} from './model/action';\r\nexport {\r\n  createConcept,\r\n  createQuality,\r\n  defaultReducer,\r\n  defaultMethodCreator,\r\n  isConceptLoaded,\r\n  areConceptsLoaded,\r\n  unifyConcepts,\r\n  forEachConcept,\r\n  conceptToString,\r\n  conceptsToString,\r\n  getConceptSemaphore,\r\n  getUnifiedName\r\n} from './model/concept';\r\nexport type {\r\n  Concept,\r\n  Concepts,\r\n  Quality,\r\n  Reducer,\r\n  Method,\r\n  Principle,\r\n  Mode,\r\n  MethodCreator,\r\n} from './model/concept';\r\nexport type { KeyedSelector } from './model/selector';\r\nexport {\r\n  selectState,\r\n  selectConcept,\r\n  selectSlice,\r\n  selectPayload,\r\n  selectUnifiedState,\r\n  updateUnifiedKeyedSelector,\r\n  createConceptKeyedSelector,\r\n  createUnifiedKeyedSelector\r\n} from './model/selector';\r\nexport { PrincipleFunction } from './model/principle';\r\nexport type { dispatchOptions, Staging, UnifiedSubject, StagePlanner, NamedStagePlanner } from './model/stagePlanner';\r\nexport { createActionController$ } from './model/actionController';\r\nexport { stageWaitForOpenThenIterate, stageWaitForOwnershipThenIterate } from './model/stagePlanner';\r\nexport type { OwnershipTicket, OwnershipTicketStub, OwnershipLedger } from './model/ownership';\r\n\r\n//** Concept Exports */\r\n// Axium\r\nexport { AxiumState, axiumName, createAxiumConcept } from './concepts/axium/axium.concept';\r\nexport { blockingMode, permissiveMode } from './concepts/axium/axium.mode';\r\nexport { axiumSelectOpen, axiumSelectLastStrategy, axiumSelectBadActions, axiumSelectBadPlans } from './concepts/axium/axium.selector';\r\n// Models\r\nexport {\r\n  AxiumGatherNode,\r\n  AxiumGatherStrategy,\r\n  axium_createGatherNode,\r\n  axium_createGatherStrategy\r\n} from './concepts/axium/model/gather.model';\r\nexport {\r\n  axium_createStitchNode\r\n} from './concepts/axium/model/stitch.model';\r\n// Qualities\r\nexport { axiumKick, axiumKickType } from './concepts/axium/qualities/kick.quality';\r\nexport { axiumConclude, axiumConcludeType } from './concepts/axium/qualities/conclude.quality';\r\nexport { axiumOpen, axiumOpenType } from './concepts/axium/qualities/open.quality';\r\nexport { axiumLog, axiumLogType } from './concepts/axium/qualities/log.quality';\r\nexport { axiumStitch, axiumStitchType } from './concepts/axium/qualities/stitch.quality';\r\nexport { axiumPreClose, axiumPreCloseType, AxiumPreClosePayload } from './concepts/axium/qualities/preClose.quality';\r\nexport { axiumBadAction, axiumBadActionType } from './concepts/axium/qualities/badAction.quality';\r\nexport { axiumSetMode, axiumSetModeType, AxiumSetModePayload } from './concepts/axium/qualities/setMode.quality';\r\nexport {\r\n  axiumSetDefaultModeIndex,\r\n  axiumSetDefaultModeIndexType,\r\n  AxiumSetDefaultModeIndexPayload\r\n} from './concepts/axium/qualities/setDefaultModeIndex.quality';\r\nexport {\r\n  axiumRegisterSubscriber,\r\n  AxiumRegisterSubscriberPayload,\r\n  axiumRegisterSubscriberType\r\n} from './concepts/axium/qualities/registerSubscription.quality';\r\nexport {\r\n  axiumRegisterStagePlanner,\r\n  AxiumRegisterStagePlannerPayload,\r\n  axiumRegisterStagePlannerType\r\n} from './concepts/axium/qualities/registerStagePlanner.quality';\r\nexport { axiumClearDialog, axiumClearDialogType } from './concepts/axium/qualities/clearDialog.quality';\r\nexport { axiumSetDefaultMode,\r\n  axiumSetDefaultModeType,\r\n  AxiumSetDefaultModePayload\r\n} from './concepts/axium/qualities/setDefaultMode.quality';\r\nexport { axiumSetBlockingMode,\r\n  axiumSetBlockingModeType,\r\n  AxiumSetBlockingModePayload\r\n} from './concepts/axium/qualities/setBlockingMode.quality';\r\n// Strategies\r\nexport {\r\n  addConceptsToAddQueThenBlockStrategy,\r\n  addConceptsToAddQueThenBlockTopic\r\n} from './concepts/axium/strategies/addConcept.strategy';\r\nexport {\r\n  addConceptsToRemovalQueThenBlockStrategy,\r\n  addConceptsToRemovalQueThenBlockTopic\r\n} from './concepts/axium/strategies/removeConcept.strategy';\r\n\r\n// Counter\r\nexport { CounterState, counterName, createCounterConcept } from './concepts/counter/counter.concept';\r\nexport { counterSelectCount } from './concepts/counter/counter.selector';\r\n// Qualities\r\nexport { counterAdd, counterAddType } from './concepts/counter/qualities/add.quality';\r\nexport { counterSubtract, counterSubtractType } from './concepts/counter/qualities/subtract.quality';\r\nexport { counterSetCount, counterSetCountType, CounterSetCountPayload } from './concepts/counter/qualities/setCount.quality';\r\n// Strategies\r\nexport {\r\n  countingStrategy,\r\n  countingTopic,\r\n  primedCountingStrategy,\r\n  primedCountingTopic\r\n} from './concepts/counter/strategies/counting.strategy';\r\n\r\n// Chain\r\nexport { ChainState, chainName, createChainConcept } from './concepts/chain/chain.concept';\r\n// Qualities\r\nexport {\r\n  chainDispatchActions,\r\n  chainDispatchActionsType,\r\n  ChainDispatchActionsPayload\r\n} from './concepts/chain/qualities/prepareChain.quality';\r\n\r\n// Ownership\r\nexport { OwnershipState, ownershipName, createOwnershipConcept } from './concepts/ownership/ownership.concept';\r\nexport { ownershipMode } from './concepts/ownership/ownership.mode';\r\nexport { ownershipSelectInitialized, ownershipSelectLedger } from './concepts/ownership/ownership.selector';\r\n// Qualities\r\nexport { ownershipBackTrack, ownershipBackTrackType } from './concepts/ownership/qualities/backTrack.quality';\r\nexport {\r\n  ownershipClearPayloadStubs,\r\n  OwnershipClearPayloadStubsPayload,\r\n  ownershipClearPayloadStubsType\r\n} from './concepts/ownership/qualities/clearPayloadStubs.quality';\r\nexport { ownershipClearPendingActions, ownershipClearPendingActionsType } from './concepts/ownership/qualities/clearPendingActions.quality';\r\nexport {\r\n  ownershipClearPendingActionsOfStrategy,\r\n  OwnershipClearPendingActionsOfStrategyPayload,\r\n  ownershipClearPendingActionsOfStrategyType\r\n} from './concepts/ownership/qualities/clearPendingActionsOfStrategy.quality';\r\nexport {\r\n  ownershipClearStrategyStubsFromLedgerAndSelf,\r\n  ownershipClearStrategyStubsFromLedgerAndSelfType\r\n} from './concepts/ownership/qualities/clearStrategyStubsFromLedgerAndSelf.quality';\r\nexport {\r\n  ownershipResetOwnershipLedger,\r\n  ownershipResetOwnershipLedgerType\r\n} from './concepts/ownership/qualities/resetOwnershipLedger.quality';\r\n\r\n// Experiment\r\nexport {\r\n  ExperimentState,\r\n  createExperimentState,\r\n  createExperimentConcept,\r\n  experimentName\r\n} from './concepts/experiment/experiment.concept';\r\nexport {\r\n  checkInStrategyQuality,\r\n  experimentCheckInStrategy,\r\n  experimentCheckInStrategyType\r\n} from './concepts/experiment/qualities/checkInStrategy.quality';\r\nexport {\r\n  experimentCountingStrategy,\r\n  experimentCountingTopic,\r\n  experimentPrimedCountingStrategy,\r\n  experimentPrimedCountingTopic\r\n} from './concepts/experiment/strategies/experimentCounting.strategy';\r\nexport {experimentActionQuePrinciple} from './concepts/experiment/experiment.principle';"},"For the graph programming framework Stratimux, define the Action model file.\r\nThis file dictates the functionality of Actions within Stratimux.":{"type":"project","content":"import { Concept, Concepts } from './concept';\r\nimport { ActionStrategy } from './actionStrategy';\r\nimport { KeyedSelector } from './selector';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { AxiumBadActionPayload } from '../concepts/axium/qualities/badAction.quality';\r\nimport { failureConditions, strategyData_appendFailure } from './actionStrategyData';\r\n\r\nexport const nullActionType: ActionType = 'null';\r\n// These need to be logical determined ahead of time.\r\n//   Logical determinations such as these will be determined in the future via generation over hand placement.\r\nconst axiumConcludeType: ActionType = 'Conclude';\r\nconst axiumBadActionType: ActionType = 'Axium received a Bad Action';\r\nconst axiumSetBlockingModeType: ActionType = 'set Axium to Blocking Mode';\r\n\r\nexport type ActionType = string;\r\nexport type Action = {\r\n    type: ActionType;\r\n    semaphore: [number, number, number, number];\r\n    conceptSemaphore?: number;\r\n    payload?: Record<string, unknown>;\r\n    strategy?: ActionStrategy;\r\n    keyedSelectors?: KeyedSelector[];\r\n    agreement?: number;\r\n    expiration: number;\r\n    axium?: string;\r\n};\r\n\r\nconst createPayload = <T extends Record<string, unknown>>(payload: T) => payload;\r\n\r\nexport function primeAction(concepts: Concepts, action: Action): Action {\r\n  const expired = action.expiration < Date.now();\r\n  let semaphore: [number, number, number, number] = [-1, -1, -1, -1];\r\n  if (!expired) {\r\n    if (action.conceptSemaphore) {\r\n      semaphore = getSemaphore(concepts, concepts[action.conceptSemaphore].name, action.type);\r\n    } else {\r\n      const conceptKeys = Object.keys(concepts);\r\n      for (const i of conceptKeys) {\r\n        const index = Number(i);\r\n        semaphore = getSemaphore(concepts, concepts[index].name, action.type);\r\n        if (semaphore[2] !== -1 && action.expiration) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (semaphore[2] !== -1 && action.expiration) {\r\n    let axium;\r\n    if (action.axium) {\r\n      axium = action.axium;\r\n    } else {\r\n      axium = (concepts[0].state as AxiumState).name;\r\n    }\r\n    const newAction = {\r\n      ...action,\r\n      semaphore: semaphore,\r\n      axium,\r\n    };\r\n    if (newAction.strategy) {\r\n      newAction.strategy.currentNode.action = newAction;\r\n    }\r\n    return newAction;\r\n  }\r\n  const badAction: Action = {\r\n    type: axiumBadActionType,\r\n    payload: createPayload<AxiumBadActionPayload>({badActions: [action]}),\r\n    expiration: Date.now() + 5000,\r\n    semaphore: getSemaphore(concepts, concepts[0].name, axiumBadActionType)\r\n  };\r\n  if (action.strategy) {\r\n    badAction.strategy = action.strategy;\r\n    badAction.strategy.currentNode.action = badAction;\r\n    if (expired) {\r\n      badAction.strategy.data = strategyData_appendFailure(badAction.strategy, failureConditions.axiumExpired);\r\n    } else {\r\n      badAction.strategy.data = strategyData_appendFailure(badAction.strategy, failureConditions.axiumBadGeneration);\r\n    }\r\n  }\r\n  return badAction;\r\n}\r\n\r\n/**\r\n * @param action A previously created action.\r\n * @returns Returns a newly recomposed Action with a updated expiration, takes into account agreement if present.\r\n */\r\nexport const refreshAction = (action: Action): Action => {\r\n  const newAction = {\r\n    ...action,\r\n  };\r\n  if (newAction.agreement) {\r\n    newAction.expiration = Date.now() + newAction.agreement;\r\n  } else {\r\n    newAction.expiration = Date.now() + 5000;\r\n  }\r\n  return newAction;\r\n};\r\n\r\nexport function getSemaphore(concepts: Concepts, conceptName: string, actionType: ActionType): [number, number, number, number] {\r\n  const axiumState = concepts[0].state as AxiumState;\r\n  const cachedSemaphores = axiumState.cachedSemaphores;\r\n  const conceptMap = cachedSemaphores.get(conceptName);\r\n  const special = getSpecialSemaphore(actionType);\r\n  if (conceptMap) {\r\n    const qualitySemaphore = conceptMap.get(actionType);\r\n    if (qualitySemaphore) {\r\n      qualitySemaphore[3] = special;\r\n      return qualitySemaphore;\r\n    }\r\n  }\r\n  return [0, 0, -1, special];\r\n}\r\n\r\n// For proper compilation\r\nconst forEachConcept = (concepts: Concepts, each: (concept: Concept, semaphore?: number) => void) => {\r\n  const conceptKeys = Object.keys(concepts);\r\n  for (const i of conceptKeys) {\r\n    const index = Number(i);\r\n    each(concepts[index], concepts[index].semaphore);\r\n  }\r\n};\r\n\r\nexport function createCacheSemaphores(concepts: Concepts): Map<string, Map<string, [number, number, number, number]>> {\r\n  const generation = (concepts[0].state as AxiumState).generation;\r\n  const newCachedSemaphores = new Map<string, Map<string, [number, number, number, number]>>();\r\n\r\n  forEachConcept(concepts, ((concept, ci) => {\r\n    const qualityMap = new Map<string, [number, number, number, number]>();\r\n    concept.qualities.forEach((quality, qi) => {\r\n      qualityMap.set(quality.actionType, [ci as number, qi, generation, 0]);\r\n    });\r\n    newCachedSemaphores.set(concept.name, qualityMap);\r\n  }));\r\n  return newCachedSemaphores;\r\n}\r\n\r\n/**\r\n * This allows us to logically determine these values in code.\r\n * @returns The final value for the semaphore tuple.\r\n */\r\nfunction getSpecialSemaphore(type: ActionType) {\r\n  switch (type) {\r\n  case axiumBadActionType: {\r\n    return 1;\r\n  }\r\n  case nullActionType: {\r\n    return 2;\r\n  }\r\n  case axiumConcludeType: {\r\n    return 3;\r\n  }\r\n  case axiumSetBlockingModeType: {\r\n    return 4;\r\n  }\r\n  default: {\r\n    return 0;\r\n  }\r\n  }\r\n}\r\n\r\nexport function createAction<T extends Record<string, unknown>>(\r\n  type: ActionType,\r\n  payload?: T,\r\n  keyedSelectors?: KeyedSelector[],\r\n  agreement?: number,\r\n  _semaphore?: [number, number, number, number],\r\n  conceptSemaphore?: number\r\n): Action {\r\n  const special = getSpecialSemaphore(type);\r\n  const semaphore = _semaphore !== undefined ? _semaphore : [0, 0, -1, special] as [number, number, number, number];\r\n  return {\r\n    type,\r\n    semaphore,\r\n    payload,\r\n    keyedSelectors,\r\n    agreement,\r\n    expiration: Date.now() + (agreement !== undefined ? agreement : 5000),\r\n    conceptSemaphore\r\n  };\r\n}\r\n\r\nexport function prepareActionCreator(actionType: ActionType) {\r\n  return (\r\n    conceptSemaphore?: number,\r\n    keyedSelectors?: KeyedSelector[],\r\n    agreement?: number,\r\n    qualitySemaphore?: [number, number, number, number]\r\n  ) => {\r\n    return createAction(actionType, undefined, keyedSelectors, agreement, qualitySemaphore, conceptSemaphore);\r\n  };\r\n}\r\nexport function prepareActionWithPayloadCreator<T extends Record<string, unknown>>(actionType: ActionType) {\r\n  return (\r\n    payload: T,\r\n    conceptSemaphore?: number,\r\n    keyedSelectors?: KeyedSelector[],\r\n    agreement?: number,\r\n    semaphore?: [number, number, number, number]\r\n  ) => {\r\n    return createAction(actionType, payload, keyedSelectors, agreement, semaphore, conceptSemaphore);\r\n  };\r\n}\r\n\r\n/**\r\n * Should only be used after if you can logically determine that the semaphores have been primed.\r\n * @returns boolean\r\n */\r\nexport function areSemaphoresEqual(first: Action, second: Action) {\r\n  return first.semaphore[0] === second.semaphore[0] && first.semaphore[1] === second.semaphore[1];\r\n}"},"For the graph programming framework Stratimux, define the Action Controller model file.\r\nThis file defines the asynchronous functionality for Methods.\r\nThat will utilize an Action's expiration as a means to invalidate an Action if the asynchronous functionality has\r\nreached its expiration. Emitting a Strategy Failed if the Action was a Strategy, or bad action if the strategy was\r\nnot provided.":{"type":"project","content":"import { Action, axiumBadAction, strategyFailed } from '../index';\r\nimport { Subject } from 'rxjs';\r\nimport { failureConditions, strategyData_appendFailure } from './actionStrategyData';\r\n\r\nexport class ActionController extends Subject<Action> {\r\n  expiration: number;\r\n  expired: boolean;\r\n  timer: NodeJS.Timeout | undefined;\r\n  action: Action;\r\n  constructor(action: Action) {\r\n    super();\r\n    this.expiration = action.expiration;\r\n    this.expired = false;\r\n    this.action = action;\r\n    if (this.expiration < Date.now()) {\r\n      if (this.action.strategy) {\r\n        this.fire(strategyFailed(\r\n          this.action.strategy,\r\n          strategyData_appendFailure(this.action.strategy, failureConditions.controllerExpired)\r\n        ));\r\n      } else {\r\n        this.next(axiumBadAction({badActions: [this.action]}));\r\n      }\r\n    } else {\r\n      this.timer = setTimeout(() => {\r\n        this.expired = true;\r\n        if (this.action.strategy) {\r\n          this.next(strategyFailed(\r\n            this.action.strategy,\r\n            strategyData_appendFailure(this.action.strategy, failureConditions.controllerExpired)\r\n          ));\r\n        } else {\r\n          this.next(axiumBadAction({badActions: [this.action]}));\r\n        }\r\n      }, this.expiration - Date.now());\r\n    }\r\n  }\r\n  /**\r\n   * Next fires once and then completes.\r\n   * In case someone uses next over fire.\r\n   */\r\n  next(action: Action) {\r\n    this.fire(action);\r\n  }\r\n  /**\r\n   * Fires once and then completes.\r\n   */\r\n  fire(action: Action) {\r\n    if (!this.closed) {\r\n      if (!this.expired && this.timer) {\r\n        clearTimeout(this.timer);\r\n        this.timer.unref();\r\n      }\r\n      const { observers } = this;\r\n      const len = observers.length;\r\n      for (let i = 0; i < len; i++) {\r\n        observers[i].next(action);\r\n      }\r\n      this.complete();\r\n    }\r\n  }\r\n}\r\n\r\nexport const createActionController$ = (act: Action, controlling: (controller: ActionController, action: Action) => void) => {\r\n  const ctrl = new ActionController(act);\r\n  // Needs to have timeout so that subscribers have time to attach in case the controller fires synchronously.\r\n  setTimeout(() => {\r\n    // Logically Determined axiumConclude;\r\n    if (act.semaphore[3] === 3) {\r\n      ctrl.fire(act);\r\n    } else {\r\n      controlling(ctrl, act);\r\n    }\r\n  }, 0);\r\n  return ctrl;\r\n};"},"For the graph programming framework Stratimux, define the Action Operator model file.\r\nThis file dictates the functionality of both Debounce, Throttle Methods and\r\ntheir interaction with ActionStrategy.":{"type":"project","content":"/* eslint-disable @typescript-eslint/no-non-null-assertion */\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport {\r\n  InteropObservable,\r\n  MonoTypeOperatorFunction,\r\n  Observable,\r\n  ObservableInput,\r\n  OperatorFunction,\r\n  SchedulerAction,\r\n  SchedulerLike,\r\n  Subscriber,\r\n  Subscription,\r\n  ThrottleConfig,\r\n  asyncScheduler,\r\n  timer\r\n} from 'rxjs';\r\nimport { Action } from './action';\r\nimport { axiumConclude } from '../concepts/axium/qualities/conclude.quality';\r\n\r\nfunction hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\r\n  return typeof source?.lift === 'function';\r\n}\r\nfunction isFunction(value: any): value is (...args: any[]) => any {\r\n  return typeof value === 'function';\r\n}\r\nconst observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\r\n\r\nfunction isInteropObservable(input: any): input is InteropObservable<any> {\r\n  return isFunction(input[observable]);\r\n}\r\nfunction fromInteropObservable<T>(obj: any) {\r\n  return new Observable((subscriber: Subscriber<T>) => {\r\n    const obs = obj[observable]();\r\n    if (isFunction(obs.subscribe)) {\r\n      return obs.subscribe(subscriber);\r\n    }\r\n    // Should be caught by observable subscribe function error handling.\r\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\r\n  });\r\n}\r\nfunction createInvalidObservableTypeError(input: any) {\r\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\r\n  return new TypeError(\r\n    `You provided ${\r\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\r\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\r\n  );\r\n}\r\nfunction innerFrom<T>(input: ObservableInput<T>): Observable<T> {\r\n  if (input instanceof Observable) {\r\n    return input;\r\n  }\r\n  if (input !== null) {\r\n    if (isInteropObservable(input)) {\r\n      return fromInteropObservable(input);\r\n    }\r\n  }\r\n\r\n  throw createInvalidObservableTypeError(input);\r\n}\r\nfunction operate<T, R>(\r\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\r\n): OperatorFunction<T, R> {\r\n  return (source: Observable<T>) => {\r\n    if (hasLift(source)) {\r\n      // eslint-disable-next-line consistent-return\r\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\r\n        try {\r\n          return init(liftedSource, this);\r\n        } catch (err) {\r\n          this.error(err);\r\n        }\r\n      });\r\n    }\r\n    throw new TypeError('Unable to lift unknown Observable type');\r\n  };\r\n}\r\n\r\nclass OperatorSubscriber<T> extends Subscriber<T> {\r\n  constructor(\r\n    destination: Subscriber<any>,\r\n    onNext?: (value: T) => void,\r\n    onComplete?: () => void,\r\n    onError?: (err: any) => void,\r\n    private onFinalize?: () => void,\r\n    private shouldUnsubscribe?: () => boolean\r\n  ) {\r\n    super(destination);\r\n    this._next = onNext\r\n      ? function (this: OperatorSubscriber<T>, value: T) {\r\n        try {\r\n          onNext(value);\r\n        } catch (err) {\r\n          destination.error(err);\r\n        }\r\n      }\r\n      : super._next;\r\n    this._error = onError\r\n      ? function (this: OperatorSubscriber<T>, err: any) {\r\n        try {\r\n          onError(err);\r\n        } catch (error) {\r\n          // Send any errors that occur down stream.\r\n          destination.error(error);\r\n        } finally {\r\n          // Ensure finalization.\r\n          this.unsubscribe();\r\n        }\r\n      }\r\n      : super._error;\r\n    this._complete = onComplete\r\n      ? function (this: OperatorSubscriber<T>) {\r\n        try {\r\n          onComplete();\r\n        } catch (err) {\r\n          // Send any errors that occur down stream.\r\n          destination.error(err);\r\n        } finally {\r\n          // Ensure finalization.\r\n          this.unsubscribe();\r\n        }\r\n      }\r\n      : super._complete;\r\n  }\r\n\r\n  unsubscribe() {\r\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\r\n      const { closed } = this;\r\n      super.unsubscribe();\r\n      !closed && this.onFinalize?.();\r\n    }\r\n  }\r\n}\r\n\r\nfunction createOperatorSubscriber<T>(\r\n  destination: Subscriber<any>,\r\n  onNext?: (value: T) => void,\r\n  onComplete?: () => void,\r\n  onError?: (err: unknown) => void,\r\n  onFinalize?: () => void\r\n): Subscriber<T> {\r\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\r\n}\r\n\r\n/**\r\n * This will prevent all actions for the specified duration, but will still emit actions as axiumConclude\r\n *  Thus this needs to be taken into account in the Method using debounceAction if implemented directly.\r\n *   But will be handled automatically in actionControllers and associated debounce createMethods.\r\n */\r\nexport function debounceAction(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<Action> {\r\n  return operate((source, subscriber) => {\r\n    let activeTask: Subscription | null = null;\r\n    let lastValue: Action | null = null;\r\n    let lastTime: number | null = null;\r\n\r\n    const emit = () => {\r\n      if (activeTask) {\r\n        activeTask.unsubscribe();\r\n        activeTask = null;\r\n        const value = lastValue!;\r\n        lastValue = null;\r\n        subscriber.next(value);\r\n      }\r\n    };\r\n    function emitWhenIdle(this: SchedulerAction<unknown>) {\r\n      const targetTime = lastTime! + dueTime;\r\n      const now = scheduler.now();\r\n      if (now < targetTime) {\r\n        activeTask = this.schedule(undefined, targetTime - now);\r\n        subscriber.add(activeTask);\r\n        return;\r\n      }\r\n\r\n      emit();\r\n    }\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: Action) => {\r\n          lastValue = value;\r\n          lastTime = scheduler.now();\r\n          if (!activeTask) {\r\n            activeTask = scheduler.schedule(emitWhenIdle, dueTime);\r\n            subscriber.add(activeTask);\r\n          } else {\r\n            // All this code just to place this code block.\r\n            const conclude = {\r\n              ...value,\r\n              ...axiumConclude(),\r\n            };\r\n            subscriber.next(\r\n              conclude\r\n            );\r\n          }\r\n        },\r\n        () => {\r\n          emit();\r\n          subscriber.complete();\r\n        },\r\n        undefined,\r\n        () => {\r\n          lastValue = activeTask = null;\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n\r\nfunction throttle(durationSelector: (value: Action) => ObservableInput<any>, config?: ThrottleConfig): MonoTypeOperatorFunction<Action> {\r\n  return operate((source, subscriber) => {\r\n    const { leading = true, trailing = false } = config ?? {};\r\n    let hasValue = false;\r\n    let sendValue: Action | null = null;\r\n    let throttled: Subscription | null = null;\r\n    let isComplete = false;\r\n\r\n    const endThrottling = (value: Action) => {\r\n      throttled?.unsubscribe();\r\n      throttled = null;\r\n      if (trailing) {\r\n        send();\r\n        isComplete && subscriber.complete();\r\n      } else {\r\n        passConclude(value);\r\n      }\r\n    };\r\n\r\n    const cleanupThrottling = () => {\r\n      throttled = null;\r\n      isComplete && subscriber.complete();\r\n    };\r\n\r\n    const startThrottle = (value: Action) =>\r\n      (throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));\r\n    const passConclude = (value: Action) => {\r\n      subscriber.next({\r\n        ...value,\r\n        ...axiumConclude()\r\n      });\r\n    };\r\n\r\n    const send = () => {\r\n      if (hasValue) {\r\n        hasValue = false;\r\n        const value = sendValue!;\r\n        sendValue = null;\r\n        subscriber.next(value);\r\n        !isComplete && startThrottle(value);\r\n      }\r\n    };\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          hasValue = true;\r\n          sendValue = value;\r\n          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));\r\n        },\r\n        () => {\r\n          isComplete = true;\r\n          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n/**\r\n * This will permit the first action, then filter actions for the specified duration, but will still emit actions as axiumConclude\r\n *  Thus this needs to be taken into account in the Method using throttleAction if implemented directly.\r\n *   But will be handled automatically in actionControllers and associated debounce createMethods.\r\n */\r\nexport function throttleAction(\r\n  duration: number,\r\n  scheduler: SchedulerLike = asyncScheduler,\r\n  config?: ThrottleConfig\r\n): MonoTypeOperatorFunction<Action> {\r\n  const duration$ = timer(duration, scheduler);\r\n  return throttle(() => duration$, config);\r\n}"},"For the graph programming framework Stratimux, define the ActionStrategy model file.\r\nThis file is what allows for Stratimux to be provably terminating.\r\nAs each strategy constitutes a finite set of symbols that must reach a conclusion.\r\nUsing this data structure we can constrain the Axium's recursive functionality to the length\r\nof the strategies that currently exist within it.\r\nThis file likewise defines a series of consumer functions that accept an ActionStrategy and data parameter; that\r\nthen returns a new ActionStrategy based on the inputs.":{"type":"project","content":"/*<$\r\nFor the graph programming framework Stratimux, define the ActionStrategy model file.\r\nThis file is what allows for Stratimux to be provably terminating.\r\nAs each strategy constitutes a finite set of symbols that must reach a conclusion.\r\nUsing this data structure we can constrain the Axium's recursive functionality to the length\r\nof the strategies that currently exist within it.\r\nThis file likewise defines a series of consumer functions that accept an ActionStrategy and data parameter; that\r\nthen returns a new ActionStrategy based on the inputs.\r\n$>*/\r\n/*<#*/"},"For the graph programming framework Stratimux, define the Action Strategy Data model file.\r\nThis file is what allows for the ActionStrategy data pattern to be a Universal Transformer of Data.\r\nAs each strategy is able to carry with it some set of attributes in its data field that may be\r\na combination of any number of properties. Creating a final data output that is the cumulation of all\r\nor some properties. That may utilized within a method, reducer, principle, and even in the lastStrategyData property\r\nif being observed via a plan or subscription.":{"type":"project","content":"// eslint-disable-next-line no-shadow\r\nimport { ActionStrategy } from './actionStrategy';\r\n\r\n// eslint-disable-next-line no-shadow\r\nexport enum failureConditions {\r\n  ownershipExpired = 'ownershipExpired',\r\n  ownershipBlocked = 'ownershipBlocked',\r\n  controllerExpired = 'controllerExpired',\r\n  axiumExpired = 'axiumExpired',\r\n  axiumBadGeneration = 'axiumBadGeneration'\r\n}\r\n\r\nexport const strategyData_appendFailure = (strategy: ActionStrategy, condition: failureConditions | string): Record<string, unknown> => {\r\n  if (strategy.data) {\r\n    return {\r\n      ...strategy.data,\r\n      failureCondition: condition\r\n    };\r\n  } else {\r\n    return {\r\n      failureCondition: condition\r\n    };\r\n  }\r\n};\r\n\r\nexport const strategyData_selectFailureCondition = (strategy: ActionStrategy): failureConditions | string | undefined => {\r\n  if (strategy.data) {\r\n    if (Object.keys(strategy.data).includes('failureCondition')) {\r\n      const data = strategy.data as Record<string, unknown>;\r\n      return data['failureCondition'] as failureConditions | string;\r\n    }\r\n  }\r\n  return undefined;\r\n};\r\n\r\nexport const strategyData_clearFailureCondition = (strategy: ActionStrategy): Record<string, unknown> | undefined => {\r\n  const condition = strategyData_selectFailureCondition(strategy);\r\n  const data = strategyData_select<Record<string, unknown>>(strategy);\r\n  if (condition && data) {\r\n    const newData: Record<string, unknown> = {};\r\n    for (const entry of Object.keys(data)) {\r\n      if (entry !== 'failureCondition') {\r\n        newData[entry] = data[entry];\r\n      }\r\n    }\r\n    return newData;\r\n  } else if (data && Object.keys(data).length > 0) {\r\n    return data;\r\n  } else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nexport const strategyData_select = <T>(strategy: ActionStrategy): T | undefined => {\r\n  if (strategy.data) {\r\n    return strategy.data as T;\r\n  } else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nexport const strategyData_unifyData =\r\n  <T extends Record<string, unknown>>(strategy: ActionStrategy, data: Record<string,unknown> | T): Record<string,unknown> => {\r\n    if (strategy.data) {\r\n      return {\r\n        ...strategy.data,\r\n        ...data\r\n      };\r\n    } else {\r\n      return {...data};\r\n    }\r\n  };"},"For the graph programming framework Stratimux, define the Axium model file.\r\nThis file dictates the creation of the Axium itself and engages all necessary parts to ensure its functionality\r\nas a provably recursive terminating function.":{"type":"project","content":"import {\r\n  Observable,\r\n  Subject,\r\n  withLatestFrom,\r\n  Subscriber,\r\n  catchError,\r\n} from 'rxjs';\r\nimport { Action, createCacheSemaphores } from './action';\r\nimport { strategyBegin } from './actionStrategy';\r\nimport { Concept, Concepts, Mode, forEachConcept, qualityToString } from './concept';\r\nimport {\r\n  createAxiumConcept,\r\n  AxiumState,\r\n  initializationStrategy,\r\n  axiumName,\r\n} from '../concepts/axium/axium.concept';\r\nimport {\r\n  axiumAppendActionListToDialog,\r\n} from '../concepts/axium/qualities/appendActionListToDialog.quality';\r\nimport { axiumPreClose } from '../concepts/axium/qualities/preClose.quality';\r\n\r\nexport const blockingMethodSubscription = (action$: Subject<Action>, action: Action) => {\r\n  if (\r\n    action.strategy &&\r\n    // Logical Determination: axiumConcludeType\r\n    action.semaphore[3] === 3\r\n  ) {\r\n    // Allows for reducer next in sequence\r\n    const appendToDialog = axiumAppendActionListToDialog({\r\n      actionList: action.strategy.actionList,\r\n      strategyTopic: action.strategy.topic,\r\n      strategyData: action.strategy.data,\r\n    });\r\n    action$.next(appendToDialog);\r\n    action$.next(action);\r\n  } else if (\r\n    action.strategy &&\r\n    // Logical Determination: axiumBadType\r\n    action.semaphore[3] !== 1\r\n  ) {\r\n    action$.next(action);\r\n  }\r\n};\r\n\r\nexport const defaultMethodSubscription = (action$: Subject<Action>, action: Action) => {\r\n  if (\r\n    action.strategy &&\r\n    // Logical Determination: axiumConcludeType\r\n    action.semaphore[3] === 3\r\n  ) {\r\n    // Allows for reducer next in sequence\r\n    const appendToDialog = axiumAppendActionListToDialog({\r\n      actionList: action.strategy.actionList,\r\n      strategyTopic: action.strategy.topic,\r\n      strategyData: action.strategy.data\r\n    });\r\n    setTimeout(() => {\r\n      action$.next(appendToDialog);\r\n      action$.next(action);\r\n    }, 0);\r\n  } else if (\r\n    action.strategy &&\r\n    // Logical Determination: axiumBadType\r\n    action.semaphore[3] !== 1\r\n  ) {\r\n    setTimeout(() => {\r\n      action$?.next(action);\r\n    }, 0);\r\n  }\r\n};\r\n\r\nexport function createAxium(name: string, initialConcepts: Concept[], logging?: boolean, storeDialog?: boolean) {\r\n  const concepts: Concepts = {};\r\n  const init = [createAxiumConcept(name, logging, storeDialog), ...initialConcepts];\r\n  init.forEach((concept, i) => {\r\n    concept.semaphore = i;\r\n    concepts[i] = concept;\r\n  });\r\n  let axiumState = concepts[0].state as AxiumState;\r\n  axiumState.cachedSemaphores = createCacheSemaphores(concepts);\r\n  forEachConcept(concepts, ((concept, semaphore) => {\r\n    concept.qualities.forEach(quality => {\r\n      if (quality.methodCreator) {\r\n        [quality.method, quality.subject] = quality.methodCreator(axiumState.concepts$, semaphore);\r\n        quality.method.pipe(\r\n          catchError((err: unknown, caught: Observable<Action>) => {\r\n            if (axiumState.logging) {\r\n              console.error('METHOD ERROR', err);\r\n            }\r\n            return caught;\r\n          }));\r\n        quality.toString = qualityToString(quality);\r\n        const methodSub = quality.method.subscribe((action: Action) => {\r\n          blockingMethodSubscription(axiumState.action$, action);\r\n        }) as Subscriber<Action>;\r\n        axiumState = concepts[0].state as AxiumState;\r\n        axiumState.methodSubscribers.push({\r\n          name: concept.name,\r\n          subscription: methodSub,\r\n        });\r\n      }\r\n    });\r\n    if (semaphore !== 0 && concept.mode !== undefined) {\r\n      axiumState = concepts[0].state as AxiumState;\r\n      const names = axiumState.modeNames;\r\n      const modes = concepts[0].mode as Mode[];\r\n      concept.mode.forEach((mode) => {\r\n        modes.push(mode);\r\n        names.push(concept.name);\r\n      });\r\n    }\r\n  }));\r\n  axiumState.action$\r\n    .pipe(\r\n      withLatestFrom(axiumState.innerConcepts$),\r\n      // This will be where the Ownership Principle will be Loaded\r\n      // As Such is a Unique Principle in the Scope of State Management\r\n      // This will also allow for Actions to be added to the Stream to Update to most Recent Values\r\n      catchError((err: unknown, caught: Observable<[Action, Concepts]>) => {\r\n        if (axiumState.logging) {\r\n          console.error('ACTION STREAM ERROR', err);\r\n        }\r\n        return caught;\r\n      }),\r\n    )\r\n    .subscribe(([action, _concepts]: [Action, Concepts]) => {\r\n      // Would be notifying methods\r\n      const _axiumState = _concepts[0].state as AxiumState;\r\n      const modeIndex = _axiumState.modeIndex;\r\n      // console.log('CHECK ACTION STREAM', action);\r\n      const modes = _concepts[0].mode as Mode[];\r\n      const mode = modes[modeIndex] as Mode;\r\n      mode([action, _concepts, _axiumState.action$, _axiumState.concepts$]);\r\n    });\r\n\r\n  axiumState = concepts[0].state as AxiumState;\r\n  const action$ = axiumState.action$;\r\n  const subConcepts$ = axiumState.subConcepts$;\r\n  const concepts$Sub = axiumState.concepts$.subscribe(_concepts => {\r\n    axiumState.innerConcepts$.next(_concepts);\r\n  });\r\n  axiumState.generalSubscribers.push({\r\n    name: axiumName,\r\n    subscription: concepts$Sub\r\n  });\r\n  axiumState.concepts$.next(concepts);\r\n  axiumState.action$.next(\r\n    strategyBegin(initializationStrategy(concepts)),\r\n  );\r\n  const close = (exit?: boolean) => {\r\n    action$.next(axiumPreClose({\r\n      exit: exit ? exit : false\r\n    }));\r\n  };\r\n  return {\r\n    subscribe: subConcepts$.subscribe.bind(subConcepts$),\r\n    unsubscribe: subConcepts$.unsubscribe.bind(subConcepts$),\r\n    close: close,\r\n    dispatch: (action: Action) => {\r\n      action$.next(action);\r\n    },\r\n    stage: subConcepts$.stage.bind(subConcepts$),\r\n  };\r\n}\r\n\r\nexport const getAxiumState = (concepts: Concepts) => (concepts[0].state as AxiumState);"},"For the graph programming framework Stratimux, define the Concept model file.\r\nThis file defines the Concept abstraction that the Axium uses to Transform its functionality.\r\nA concept is composed of name, unified, state, qualities, semaphore, principles, and some meta attributes if necessary.":{"type":"project","content":"import { Observable, Subject } from 'rxjs';\r\nimport { Action, ActionType } from './action';\r\nimport { PrincipleFunction } from '../model/principle';\r\nimport { strategySuccess } from './actionStrategy';\r\nimport { map } from 'rxjs';\r\nimport { KeyedSelector } from './selector';\r\nimport { axiumConcludeType } from '../concepts/axium/qualities/conclude.quality';\r\nimport { UnifiedSubject } from './stagePlanner';\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport type Reducer = (state: any, action: Action) => any;\r\n\r\nexport type Method = Observable<Action>;\r\nexport type Principle = Observable<Action>;\r\n\r\nexport type Mode = ([action, concept, action$, concepts$]: [\r\n  Action,\r\n  Concepts,\r\n  Subject<Action>,\r\n  UnifiedSubject,\r\n]) => void;\r\n\r\nexport type MethodCreator = (concept$?: UnifiedSubject, semaphore?: number) => [Method, Subject<Action>];\r\n\r\nexport type Quality = {\r\n  actionType: ActionType;\r\n  reducer: Reducer;\r\n  toString: () => string;\r\n  methodCreator?: MethodCreator;\r\n  method?: Method;\r\n  subject?: Subject<Action>;\r\n  keyedSelectors?: KeyedSelector[];\r\n  meta?: Record<string,unknown>;\r\n  analytics?: Record<string,unknown>;\r\n};\r\n\r\nexport type Concept = {\r\n  name: string;\r\n  unified: string[];\r\n  state: Record<string, unknown>;\r\n  qualities: Quality[];\r\n  semaphore: number;\r\n  principles?: PrincipleFunction[];\r\n  mode?: Mode[];\r\n  meta?: Record<string,unknown>;\r\n};\r\n\r\nexport type Concepts = Record<number, Concept>;\r\n\r\nexport function createConcept(\r\n  name: string,\r\n  state: Record<string, unknown>,\r\n  qualities?: Quality[],\r\n  principles?: PrincipleFunction[],\r\n  mode?: Mode[],\r\n  meta?: Record<string,unknown>\r\n): Concept {\r\n  if (mode) {\r\n    mode.forEach((m, i) => {\r\n      m.toString = () => `MODE: ${name} ${i}`;\r\n    });\r\n  }\r\n  if (principles) {\r\n    principles.forEach((p, i) => {\r\n      p.toString = () => `PRINCIPLE: ${name} ${i}`;\r\n    });\r\n  }\r\n  return {\r\n    name,\r\n    unified: [],\r\n    state,\r\n    qualities: qualities ? qualities : [],\r\n    semaphore: -1,\r\n    principles,\r\n    mode,\r\n    meta\r\n  };\r\n}\r\n\r\n/**\r\n * This will remove any duplicate qualities, principles, and modes.\r\n * Note that for now the check for mode and principle are based on concept name and loaded index;\r\n */\r\nfunction filterSimilarQualities(concept: Concept) {\r\n  const newQualities: Quality[] = [];\r\n  const newUnified: string[] = [];\r\n  const newPrinciples: PrincipleFunction[] = [];\r\n  const newMode: Mode[] = [];\r\n  for (let i = 0; i < concept.qualities.length; i++) {\r\n    let found = false;\r\n    for (let j = i + 1; j < concept.qualities.length; j++) {\r\n      if (concept.qualities[i].actionType === concept.qualities[j].actionType) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!found) {\r\n      newQualities.push(concept.qualities[i]);\r\n    }\r\n  }\r\n  concept.qualities = newQualities;\r\n  for (let i = 0; i < concept.unified.length; i++) {\r\n    let found = false;\r\n    for (let j = i + 1; j < concept.unified.length; j++) {\r\n      if (concept.unified[i] === concept.unified[j]) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!found) {\r\n      newUnified.push(concept.unified[i]);\r\n    }\r\n  }\r\n  concept.unified = newUnified;\r\n  if (concept.principles) {\r\n    for (let i = 0; i < concept.principles.length; i++) {\r\n      let found = false;\r\n      for (let j = i + 1; j < concept.principles.length; j++) {\r\n        if (concept.principles[i].toString() === concept.principles[j].toString()) {\r\n          found = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!found) {\r\n        newPrinciples.push(concept.principles[i]);\r\n      }\r\n    }\r\n    concept.principles = newPrinciples;\r\n  }\r\n  if (concept.mode) {\r\n    for (let i = 0; i < concept.mode.length; i++) {\r\n      let found = false;\r\n      for (let j = i + 1; j < concept.mode.length; j++) {\r\n        if (concept.mode[i].toString() === concept.mode[j].toString()) {\r\n          found = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!found) {\r\n        newMode.push(concept.mode[i]);\r\n      }\r\n    }\r\n    concept.mode = newMode;\r\n  }\r\n  return concept;\r\n}\r\n\r\nfunction unify(base: Concept, target: Concept): Concept {\r\n  if (target.name !== '') {\r\n    base.unified.push(target.name);\r\n  }\r\n  base.unified = [\r\n    ...base.unified,\r\n    ...target.unified\r\n  ];\r\n  base.state = {\r\n    ...base.state,\r\n    ...target.state,\r\n  };\r\n  base.qualities = [\r\n    ...base.qualities,\r\n    ...target.qualities,\r\n  ];\r\n  if (target.principles) {\r\n    if (base.principles) {\r\n      base.principles = [\r\n        ...base.principles,\r\n        ...target.principles\r\n      ];\r\n    } else {\r\n      base.principles = [\r\n        ...target.principles\r\n      ];\r\n    }\r\n  }\r\n  if (target.mode) {\r\n    if (base.mode) {\r\n      base.mode = [\r\n        ...base.mode,\r\n        ...target.mode\r\n      ];\r\n    } else {\r\n      base.mode = [\r\n        ...target.mode\r\n      ];\r\n    }\r\n  }\r\n  if (target.meta) {\r\n    if (base.meta) {\r\n      base.meta = {\r\n        ...base.meta,\r\n        ...target.meta\r\n      };\r\n    } else {\r\n      base.meta = {\r\n        ...target.mode\r\n      };\r\n    }\r\n  }\r\n  return base;\r\n}\r\n/**\r\n * This will unify concepts while prioritizing qualities later in the provided concepts list via recomposition.\r\n *  Then finally unify the emergent concept with final priority.\r\n */\r\nexport function unifyConcepts(\r\n  concepts: Concept[],\r\n  emergentConcept: Concept\r\n): Concept {\r\n  let newConcept = createConcept('', {});\r\n  forEachConcept(concepts, (concept => {\r\n    newConcept = unify(newConcept, concept);\r\n  }));\r\n  newConcept = unify(newConcept, emergentConcept);\r\n  newConcept.unified = newConcept.unified.filter(name => name !== emergentConcept.name);\r\n  newConcept.name = emergentConcept.name;\r\n  if (newConcept.mode) {\r\n    newConcept.mode.forEach((m, i) => {\r\n      m.toString = () => `MODE: ${newConcept.name} ${i}`;\r\n    });\r\n  }\r\n  if (newConcept.principles) {\r\n    newConcept.principles.forEach((p, i) => {\r\n      p.toString = () => `PRINCIPLE: ${newConcept.name} ${i}`;\r\n    });\r\n  }\r\n  return filterSimilarQualities(newConcept);\r\n}\r\n\r\nexport const getUnifiedName = (concepts: Concepts, semaphore: number): string | undefined => (concepts[semaphore]?.name);\r\n\r\n// Will return -1 if not found\r\nexport const getConceptSemaphore = (concepts: Concepts, conceptName: string): number => {\r\n  // eslint-disable-next-line consistent-return\r\n  forEachConcept(concepts, (concept, semaphore) => {\r\n    if (concept.name === conceptName) {\r\n      return semaphore;\r\n    }\r\n  });\r\n  return -1;\r\n};\r\n\r\nexport function createQuality(\r\n  actionType: ActionType,\r\n  reducer: Reducer,\r\n  methodCreator?: MethodCreator,\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  keyedSelectors?: KeyedSelector[],\r\n  meta?: Record<string,unknown>,\r\n  analytics?: Record<string,unknown>,\r\n): Quality {\r\n  return {\r\n    actionType,\r\n    reducer,\r\n    methodCreator,\r\n    keyedSelectors,\r\n    meta,\r\n    analytics\r\n  };\r\n}\r\n\r\nexport function defaultReducer(state: unknown, _: Action) {\r\n  return state;\r\n}\r\ndefaultReducer.toString = () => ('Default Reducer');\r\n\r\nexport const defaultMethodCreator: MethodCreator = () : [Method, Subject<Action>] =>  {\r\n  const defaultSubject = new Subject<Action>();\r\n  const defaultMethod: Method = defaultSubject.pipe(\r\n    map((action: Action) => {\r\n      if (action.strategy) {\r\n        return strategySuccess(action.strategy);\r\n      }\r\n      return {\r\n        ...action,\r\n        type: axiumConcludeType\r\n      };\r\n    }),\r\n  );\r\n\r\n  defaultMethod.toString = () => ('Default Method');\r\n  return [defaultMethod, defaultSubject];\r\n};\r\n\r\nexport const isConceptLoaded = (concepts: Concepts, conceptName: string): boolean => {\r\n  const conceptKeys = Object.keys(concepts);\r\n  for (const i of conceptKeys) {\r\n    const index = Number(i);\r\n    if (concepts[index].name === conceptName) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const areConceptsLoaded = (concepts: Concepts, conceptNames: string[]): boolean => {\r\n  let allExists = true;\r\n  const conceptKeys = Object.keys(concepts);\r\n  for (const name of conceptNames) {\r\n    let found = false;\r\n    for (const i of conceptKeys) {\r\n      const index = Number(i);\r\n      if (name === concepts[index].name) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!found) {\r\n      allExists = false;\r\n      break;\r\n    }\r\n  }\r\n  return allExists;\r\n};\r\n\r\nexport const forEachConcept = (concepts: Concepts, each: (concept: Concept, semaphore?: number) => void) => {\r\n  const conceptKeys = Object.keys(concepts);\r\n  for (const i of conceptKeys) {\r\n    const index = Number(i);\r\n    each(concepts[index], index);\r\n  }\r\n};\r\n\r\nconst stateToString = (state: Record<string, unknown>): string => {\r\n  let final = '{\\n';\r\n  const keys = Object.keys(state);\r\n  for (const key of keys) {\r\n    let input = '';\r\n    try {\r\n      input += `${key}: ${JSON.stringify(state[key])},\\n`;\r\n    } catch (err) {\r\n      input = `${key}: [CIRCULAR],\\n`;\r\n    }\r\n    final += input;\r\n  }\r\n  final += '}';\r\n  return final;\r\n};\r\n\r\nexport const conceptToString = (concept: Concept): string => {\r\n  let output = '';\r\n  output += `{\\nname: ${concept.name},`;\r\n  if (concept.unified.length > 0) {\r\n    output += `\\nunified: ${concept.unified},`;\r\n  }\r\n  output += `\\nqualities: [ ${concept.qualities.toString()}\\n],`;\r\n  output += `\\nstate: ${stateToString(concept.state)}, `;\r\n  if (concept.principles) {\r\n    output += `\\nprinciples: [ ${concept.principles.map(p => p.toString()).join(',')} ]`;\r\n  }\r\n  if (concept.mode) {\r\n    output += `\\nmode: [ ${concept.mode.map(m => m.toString()).join(',')} ]`;\r\n  }\r\n  if (concept.meta) {\r\n    output += `\\nmeta: ${JSON.stringify(concept.meta)}`;\r\n  }\r\n  output += '\\n}';\r\n  return output;\r\n};\r\n\r\nexport const conceptsToString = (concepts: Concepts): string => {\r\n  const conceptStringArray: string[] = [];\r\n  forEachConcept(concepts, (concept) => {\r\n    conceptStringArray.push(conceptToString(concept));\r\n  });\r\n  conceptStringArray.push(']');\r\n  return '[\\n' + conceptStringArray.join(',\\n');\r\n};\r\n\r\nexport const qualityToString = (quality: Quality) => () => {\r\n  const actionType = quality.actionType;\r\n  const r = quality.reducer.toString();\r\n  const reducer = r === 'Default Reducer' ? r : 'Reducer';\r\n  const method = quality.method?.toString();\r\n  return (`\\n{\\nactionType: ${actionType},\\nreducer: ${reducer},\\nmethod: ${method}\\n}`);\r\n};"},"For the graph programming framework Stratimux, define the Method model file.\r\nThis file hold a series of helper functions that enable users to quickly create specific provably terminating methods\r\nwithin their own defined qualities.":{"type":"project","content":"import { Observable, Subject, map, switchMap, withLatestFrom } from 'rxjs';\r\nimport { Concepts } from './concept';\r\nimport { UnifiedSubject } from './stagePlanner';\r\nimport { ActionController, createActionController$ } from './actionController';\r\nimport { ActionStrategy } from './actionStrategy';\r\nimport { KeyedSelector, selectUnifiedState } from './selector';\r\nimport { debounceAction, throttleAction } from './actionOperators';\r\nimport { axiumConclude } from '../concepts/axium/qualities/conclude.quality';\r\n\r\nexport type ActionType = string;\r\ntype Action = {\r\n    type: ActionType;\r\n    semaphore: [number, number, number, number];\r\n    payload?: Record<string, unknown>;\r\n    strategy?: ActionStrategy;\r\n    keyedSelectors?: KeyedSelector[];\r\n    agreement?: number;\r\n    expiration: number;\r\n    axium?: string;\r\n};\r\ntype Method = Observable<Action> & {toString: () => string};\r\n\r\nexport const createMethod =\r\n  (method: (action: Action) => Action): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      map((action: Action) => {\r\n        const methodAction = method(action);\r\n        if (methodAction.strategy) {\r\n          return methodAction;\r\n        }\r\n        const conclude = axiumConclude();\r\n        return {\r\n          ...action,\r\n          ...conclude,\r\n        };\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodWithState =\r\n  <T>(\r\n    methodWithState: (action: Action, state: T) => Action,\r\n    concepts$: UnifiedSubject,\r\n    semaphore: number\r\n  ): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      map(([act, state] : [Action, T]) => {\r\n        const methodAction = methodWithState(act, state);\r\n        if (methodAction.strategy) {\r\n          return methodAction;\r\n        }\r\n        const conclude = axiumConclude();\r\n        return {\r\n          ...act,\r\n          ...conclude,\r\n        };\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethod =\r\n  (asyncMethod: (controller: ActionController, action: Action) => void): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      switchMap(act => createActionController$(act, (controller: ActionController, action: Action) => {\r\n        asyncMethod(controller, action);\r\n      })),\r\n    );\r\n    defaultMethod.toString = () => ('Async Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodWithState =\r\n  <T>(\r\n    asyncMethodWithState: (controller: ActionController, action: Action, state: T) => void,\r\n    concepts$: UnifiedSubject,\r\n    semaphore: number\r\n  )\r\n    : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      switchMap(([act, state] : [Action, T]) => createActionController$(act, (controller: ActionController, action: Action) => {\r\n        asyncMethodWithState(controller, action, state);\r\n      })),\r\n    );\r\n    defaultMethod.toString = () => ('Async Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodDebounce =\r\n  (method: (action: Action) => Action, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      map((action: Action) => {\r\n        // Logically Determined axiumConclude\r\n        if (action.semaphore[3] !== 3) {\r\n          const methodAction = method(action);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...action,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return action;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Debounce Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodDebounceWithState =\r\n  <T>(methodWithState: (action: Action, state: T) => Action, concepts$: UnifiedSubject, semaphore: number, duration: number)\r\n    : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      map(([act, state] : [Action, T]) => {\r\n        // Logically Determined axiumConclude\r\n        if (act.semaphore[3] !== 3) {\r\n          const methodAction = methodWithState(act, state);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...act,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return act;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Debounce Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodDebounce =\r\n  (asyncMethod: (controller: ActionController, action: Action) => void, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      switchMap((act) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethod(controller, action);\r\n        });\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Async Debounce Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodDebounceWithState =\r\n  <T>(asyncMethodWithState: (controller: ActionController, action: Action, state: T) =>\r\n    void, concepts$: UnifiedSubject, semaphore: number, duration: number, ): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      switchMap(([act, state] : [Action, T]) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethodWithState(controller, action, state);\r\n        });\r\n      })\r\n    );\r\n    defaultMethod.toString = () => ('Async Debounce Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodThrottle =\r\n  (method: (action: Action) => Action, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      map((action: Action) => {\r\n        // Logically Determined axiumConclude\r\n        if (action.semaphore[3] !== 3) {\r\n          const methodAction = method(action);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...action,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return action;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Throttle Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodThrottleWithState =\r\n  <T>(methodWithState: (action: Action, state: T) => Action, concepts$: UnifiedSubject, semaphore: number, duration: number)\r\n    : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      map(([act, state] : [Action, T]) => {\r\n        // Logically Determined axiumConclude\r\n        if (act.semaphore[3] !== 3) {\r\n          const methodAction = methodWithState(act, state);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...act,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return act;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Throttle Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodThrottle =\r\n  (asyncMethod: (controller: ActionController, action: Action) => void, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      switchMap((act) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethod(controller, action);\r\n        });\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Async Throttle Method');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodThrottleWithState =\r\n  <T>(asyncMethodWithState: (controller: ActionController, action: Action, state: T) =>\r\n    void, concepts$: UnifiedSubject, semaphore: number, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      map(([act, concepts] : [Action, Concepts]): [Action, T] => ([act, selectUnifiedState<T>(concepts, semaphore) as T])),\r\n      switchMap(([act, state] : [Action, T]) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethodWithState(controller, action, state);\r\n        });\r\n      })\r\n    );\r\n    defaultMethod.toString = () => ('Async Throttle Method with State');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodWithConcepts =\r\n  (\r\n    methodWithConcepts: (action: Action, concepts: Concepts, semaphore: number) => Action,\r\n    concepts$: UnifiedSubject,\r\n    semaphore: number\r\n  ): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      map(([act, concepts] : [Action, Concepts]) => {\r\n        const methodAction = methodWithConcepts(act, concepts, semaphore);\r\n        if (methodAction.strategy) {\r\n          return methodAction;\r\n        }\r\n        const conclude = axiumConclude();\r\n        return {\r\n          ...act,\r\n          ...conclude,\r\n        };\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodWithConcepts =\r\n  (\r\n    asyncMethodWithConcepts: (controller: ActionController, action: Action, concepts: Concepts, semaphore: number) => void,\r\n    concepts$: UnifiedSubject,\r\n    semaphore: number\r\n  )\r\n    : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      switchMap(([act, concepts] : [Action, Concepts]) => createActionController$(act, (controller: ActionController, action: Action) => {\r\n        asyncMethodWithConcepts(controller, action, concepts, semaphore);\r\n      })),\r\n    );\r\n    defaultMethod.toString = () => ('Async Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodDebounceWithConcepts =\r\n  (\r\n    methodWithConcepts: (action: Action, concepts: Concepts, semaphore: number) => Action, concepts$: UnifiedSubject,\r\n    semaphore: number,\r\n    duration: number\r\n  ) : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      map(([act, concepts] : [Action, Concepts]) => {\r\n        // Logically Determined axiumConclude\r\n        if (act.semaphore[3] !== 3) {\r\n          const methodAction = methodWithConcepts(act, concepts, semaphore);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...act,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return act;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Debounce Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodDebounceWithConcepts =\r\n  (asyncMethodWithConcepts: (controller: ActionController, action: Action, concepts: Concepts, semaphore: number) =>\r\n    void, concepts$: UnifiedSubject, semaphore: number, duration: number, ): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      debounceAction(duration),\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      switchMap(([act, concepts] : [Action, Concepts]) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethodWithConcepts(controller, action, concepts, semaphore);\r\n        });\r\n      })\r\n    );\r\n    defaultMethod.toString = () => ('Async Debounce Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createMethodThrottleWithConcepts =\r\n  (\r\n    methodWithConcepts: (action: Action, concepts: Concepts, semaphore: number) => Action,\r\n    concepts$: UnifiedSubject,\r\n    semaphore: number,\r\n    duration: number\r\n  ) : [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      map(([act, concepts] : [Action, Concepts]) => {\r\n        // Logically Determined axiumConclude\r\n        if (act.semaphore[3] !== 3) {\r\n          const methodAction = methodWithConcepts(act, concepts, semaphore);\r\n          if (methodAction.strategy) {\r\n            return methodAction;\r\n          }\r\n          const conclude = axiumConclude();\r\n          return {\r\n            ...act,\r\n            ...conclude,\r\n          };\r\n        } else {\r\n          return act;\r\n        }\r\n      }),\r\n    );\r\n    defaultMethod.toString = () => ('Throttle Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };\r\nexport const createAsyncMethodThrottleWithConcepts =\r\n  (asyncMethodWithConcepts: (controller: ActionController, action: Action, concepts: Concepts, semaphore: number) =>\r\n    void, concepts$: UnifiedSubject, semaphore: number, duration: number): [Method, Subject<Action>] => {\r\n    const defaultSubject = new Subject<Action>();\r\n    const defaultMethod: Method = defaultSubject.pipe(\r\n      throttleAction(duration),\r\n      withLatestFrom(concepts$ as UnifiedSubject),\r\n      switchMap(([act, concepts] : [Action, Concepts]) => {\r\n        return createActionController$(act, (controller: ActionController, action: Action) => {\r\n          asyncMethodWithConcepts(controller, action, concepts, semaphore);\r\n        });\r\n      })\r\n    );\r\n    defaultMethod.toString = () => ('Async Throttle Method with Concepts');\r\n    return [defaultMethod, defaultSubject];\r\n  };"},"For the graph programming framework Stratimux, define the Ownership model file.\r\nThis file will dictate functionality used within the Ownership Concept to engage in its functionality.":{"type":"project","content":"/* eslint-disable max-depth */\r\nimport { Action, areSemaphoresEqual } from '../model/action';\r\nimport { OwnershipState, ownershipName } from '../concepts/ownership/ownership.concept';\r\nimport { Concepts } from './concept';\r\nimport { selectState } from './selector';\r\nimport { ActionNode, ActionStrategy } from './actionStrategy';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { randomUUID } from 'crypto';\r\n\r\nexport type OwnershipLedger = Map<string, OwnershipTicket[]>;\r\n\r\nexport type OwnershipTicket = {\r\n  ticket: string;\r\n  expiration: number;\r\n}\r\n\r\nexport type OwnershipTicketStub = {\r\n  key: string,\r\n  ticket: string,\r\n}\r\n\r\nexport const createOwnershipLedger = (): OwnershipLedger => ( new Map<string, OwnershipTicket[]>());\r\n\r\nexport const ownershipShouldBlock = (concepts: Concepts, action: Action): boolean => {\r\n  const qualityKeys = concepts[action.semaphore[0]].qualities[action.semaphore[1]].keyedSelectors;\r\n  const actionSelectors = action.keyedSelectors;\r\n  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  let shouldBlock = false;\r\n  // Quality Action no Keys, no Strategy\r\n  if (qualityKeys && !actionSelectors && action.strategy === undefined) {\r\n    for (let i = 0; i < qualityKeys.length; i++) {\r\n      if (ownershipLedger.has(`${qualityKeys[i].conceptName} ${qualityKeys[i].stateKeys}`)) {\r\n        shouldBlock = true;\r\n        break;\r\n      }\r\n    }\r\n  // ActionStrategy, with Keys\r\n  } else if (actionSelectors && action.strategy && action.strategy.stubs === undefined) {\r\n    for (let i = 0; i < actionSelectors.length; i++) {\r\n      if (ownershipLedger.has(`${actionSelectors[i].conceptName} ${actionSelectors[i].stateKeys}`)) {\r\n        shouldBlock = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  if (!shouldBlock && action?.strategy?.stubs) {\r\n    const stubs = action.strategy.stubs;\r\n    let firstOfAllLines = false;\r\n    for (let i = 0; i < stubs.length; i++) {\r\n      const line = ownershipLedger.get(action.strategy.stubs[i].key);\r\n      if (line) {\r\n        for (const [_, stub] of line.entries()) {\r\n          if (stubs[i].ticket === stub.ticket) {\r\n            firstOfAllLines = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      shouldBlock = !firstOfAllLines;\r\n    }\r\n  }\r\n  return shouldBlock;\r\n};\r\n\r\nexport const clearStubs = (concepts: Concepts, strategy: ActionStrategy): Concepts => {\r\n  const newConcepts = concepts;\r\n  const stubs = strategy.stubs;\r\n  const ownershipState = selectState(newConcepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  if (stubs) {\r\n    stubs.forEach(ticketStub => {\r\n      const line = ownershipLedger.get(ticketStub.key);\r\n      if (line) {\r\n        const newLine = [] as OwnershipTicket[];\r\n        for (const stub of line) {\r\n          if (stub.ticket !== ticketStub.ticket) {\r\n            newLine.push(stub);\r\n          }\r\n        }\r\n        if (newLine.length === 0) {\r\n          ownershipLedger.delete(ticketStub.key);\r\n        } else {\r\n          ownershipLedger.set(ticketStub.key, newLine);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  return newConcepts;\r\n};\r\n\r\nexport const editStubs = (_concepts: Concepts, oldAction: Action, newAction: Action): [Concepts, Action] => {\r\n  const concepts = _concepts;\r\n  const oldStrategy = oldAction.strategy as ActionStrategy;\r\n  const newStrategy = newAction.strategy as ActionStrategy;\r\n  newStrategy.stubs = [];\r\n  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  if (oldStrategy.stubs) {\r\n    oldStrategy.stubs.forEach((ticketStub) => {\r\n      const line = ownershipLedger.get(ticketStub.key);\r\n      if (line) {\r\n        for (const stub of line) {\r\n          if (stub.ticket === ticketStub.ticket) {\r\n            stub.expiration = newAction.expiration;\r\n            newStrategy.stubs?.push({\r\n              key: ticketStub.key,\r\n              ticket: stub.ticket\r\n            });\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n  return [concepts, newAction];\r\n};\r\n\r\nexport const checkIn =\r\n(concepts: Concepts, action: Action): [Concepts, Action] => {\r\n  const newConcepts = concepts;\r\n  const ownershipState = selectState(newConcepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  const strategy = action.strategy;\r\n  if (strategy) {\r\n    strategy.stubs = strategy.stubs ? strategy.stubs : [] as OwnershipTicketStub[];\r\n    action.keyedSelectors?.forEach(keyed => {\r\n      const key = `${keyed.conceptName} ${keyed.stateKeys}`;\r\n      const entry = ownershipLedger.get(key);\r\n      let found = false;\r\n      if (entry && action.strategy?.stubs) {\r\n        for (const ticketStub of entry) {\r\n          for (const stub of action.strategy.stubs) {\r\n            if (ticketStub.ticket === stub.ticket && stub.key === key) {\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n          if (found) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      if (!found) {\r\n        const expiration = action.expiration;\r\n        const axiumState = concepts[0].state as AxiumState;\r\n        const ticket = axiumState.name + randomUUID();\r\n        const newTicketStub = {\r\n          key,\r\n          ticket,\r\n          expiration\r\n        };\r\n        const newTicket = {\r\n          ticket,\r\n          expiration\r\n        };\r\n        strategy.stubs?.push(newTicketStub);\r\n        if (entry) {\r\n          entry.push(newTicket);\r\n        } else {\r\n          ownershipLedger.set(key, [newTicket]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  return  [\r\n    newConcepts,\r\n    action\r\n  ];\r\n};\r\n\r\nexport const isActionReady = (concepts: Concepts, _action: Action): [Concepts, boolean] => {\r\n  const action = _action;\r\n  const stubs = action.strategy?.stubs;\r\n  if (stubs) {\r\n    return stubActionStrategy(concepts, action);\r\n  } else {\r\n    return qualityAction(concepts, action);\r\n  }\r\n};\r\n\r\nconst stubActionStrategy = (concepts: Concepts, _action: Action): [Concepts, boolean] => {\r\n  const action = _action;\r\n  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  const stubs = action.strategy?.stubs as OwnershipTicketStub[];\r\n  let frontOfAllLines = true;\r\n  // let expired = false;\r\n  for (const stub of stubs) {\r\n    const positions = ownershipLedger.get(stub.key);\r\n    if (positions) {\r\n      for (const [i, pos] of positions.entries()) {\r\n        if (i === 0 && pos.ticket === stub.ticket) {\r\n          continue;\r\n        } else {\r\n          frontOfAllLines = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return [concepts, frontOfAllLines];\r\n};\r\n\r\nconst qualityAction = (concepts: Concepts, _action: Action): [Concepts, boolean] => {\r\n  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;\r\n  const ownershipLedger = ownershipState.ownershipLedger;\r\n  const action = _action;\r\n  const qualitySelectors = concepts[action.semaphore[0]].qualities[action.semaphore[1]].keyedSelectors;\r\n  let readyToGo = true;\r\n\r\n  if (qualitySelectors) {\r\n    for (const selector of qualitySelectors) {\r\n      const key = `${selector.conceptName} ${selector.stateKeys}`;\r\n      if (ownershipLedger.get(key)) {\r\n        readyToGo = false;\r\n        break;\r\n      }\r\n    }\r\n    return [concepts, readyToGo];\r\n  }\r\n  return [concepts, readyToGo];\r\n};\r\n\r\nconst areSameDepth = (first: ActionNode, second: ActionNode, count: [number, number]): boolean => {\r\n  const newCount: [number, number] = [\r\n    // Logical Determination: nullActionType\r\n    //  In addition we logically guarantee that action would be set at this point of execution\r\n    (first.lastActionNode?.action as Action).semaphore[3] !== 2 ? count[0] + 1 : count[0],\r\n    (second.lastActionNode?.action as Action).semaphore[3] !== 2 ? count[0] + 1 : count[0]\r\n  ];\r\n  if (count[0] !== newCount[0] && count[1] !== newCount[1] && newCount[0] === newCount[1]) {\r\n    return areSameDepth(first.lastActionNode as ActionNode, second.lastActionNode as ActionNode, newCount);\r\n  } else if (count[0] === newCount[0] && count[1] === newCount[1]) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const areEqual = (first: Action, second: Action ) => {\r\n  let equal = false;\r\n  const firstStrategy = first.strategy;\r\n  const secondStrategy = second.strategy;\r\n  if (firstStrategy === undefined && secondStrategy === undefined) {\r\n    if (areSemaphoresEqual(first, second)) {\r\n      if (first.payload === undefined && second.payload === undefined) {\r\n        equal = true;\r\n      } else {\r\n        equal = JSON.stringify(first.payload) === JSON.stringify(second.payload);\r\n      }\r\n    }\r\n    equal = false;\r\n  } else if (firstStrategy?.topic === secondStrategy?.topic) {\r\n    if (areSemaphoresEqual(first, second)) {\r\n      if (first.payload === undefined && second.payload === undefined) {\r\n        equal = true;\r\n      } else if (JSON.stringify(first.payload) === JSON.stringify(second.payload)) {\r\n        equal = areSameDepth(\r\n          (firstStrategy as ActionStrategy).currentNode,\r\n          (secondStrategy as ActionStrategy).currentNode,\r\n          [0,0]\r\n        );\r\n      }\r\n    }\r\n    equal = false;\r\n  }\r\n  return equal;\r\n};\r\n\r\nexport const updateAddToPendingActions = (_concepts: Concepts, _action: Action) => {\r\n  let concepts = _concepts;\r\n  const action = _action;\r\n  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;\r\n  const pendingActions = ownershipState.pendingActions;\r\n  const newPendingActions: Action[] = [];\r\n  if (pendingActions.length > 0) {\r\n    for (const pending of pendingActions) {\r\n      const equal = areEqual(action, pending);\r\n      if (equal && pending.keyedSelectors && action.keyedSelectors) {\r\n        let editedAction;\r\n        [concepts, editedAction] = editStubs(concepts, pending, action);\r\n        newPendingActions.push(editedAction);\r\n      } else if (equal) {\r\n        newPendingActions.push(action);\r\n      } else {\r\n        newPendingActions.push(pending);\r\n        newPendingActions.push(action);\r\n      }\r\n    }\r\n    ownershipState.pendingActions = [...newPendingActions];\r\n  } else {\r\n    ownershipState.pendingActions = [action];\r\n  }\r\n  return concepts;\r\n};"},"For the graph programming framework Stratimux, define the Principle model file.\r\nThis file allows for user to define Principle Functions, as well as for the axium to initialize those functions\r\nwithin its recursive run time.":{"type":"project","content":"import { Observable, Subscriber, Subscription } from 'rxjs';\r\nimport { Concepts } from './concept';\r\nimport { Action, primeAction } from './action';\r\nimport { axiumRegisterSubscriber } from '../concepts/axium/qualities/registerSubscription.quality';\r\nimport { UnifiedSubject } from './stagePlanner';\r\n\r\nexport type PrincipleFunction = (\r\n  observer: Subscriber<Action>,\r\n  concepts: Concepts,\r\n  concept$: UnifiedSubject,\r\n  semaphore: number,\r\n) => void;\r\n\r\nexport function createPrinciple$(\r\n  principleFunc: PrincipleFunction,\r\n  concepts: Concepts,\r\n  concepts$: UnifiedSubject,\r\n  semaphore: number,\r\n): Observable<Action> {\r\n  return new Observable(function (obs: Subscriber<Action>) {\r\n    principleFunc(obs, concepts, concepts$, semaphore);\r\n  });\r\n}\r\n\r\nexport function registerPrincipleSubscription(observer: Subscriber<Action>, concepts: Concepts, name: string, subscription: Subscription) {\r\n  const primedRegisterSubscriber = primeAction(concepts, axiumRegisterSubscriber({ subscription, name }));\r\n  observer.next(primedRegisterSubscriber);\r\n}"},"For the graph programming framework Stratimux, define the Selector model file.\r\nThis file will contain a series of selectors that can be used to engage with different parts of the Axium Conceptual Set.":{"type":"project","content":"import { Action } from './action';\r\nimport { Concept, Concepts } from './concept';\r\n\r\n/**\r\n * Will have such be a list of state keys separated by spaces until someone yells at me to change this.\r\n */\r\nexport type KeyedSelector = {\r\n  conceptName: string,\r\n  stateKeys: string\r\n};\r\n\r\n/**\r\n * For usage outside of the Axium, or when subscribed to other Axium'sl\r\n */\r\nexport const createConceptKeyedSelector =\r\n  (concepts: Concepts, conceptName: string, keyedSelector: KeyedSelector): KeyedSelector | undefined => {\r\n    let exists = false;\r\n    const indexes = Object.keys(concepts).map(key => Number(key));\r\n    for (const index of indexes) {\r\n      if (concepts[index].name === conceptName) {\r\n        exists = true;\r\n        break;\r\n      }\r\n    }\r\n    if (exists) {\r\n      const newSelector = {...keyedSelector};\r\n      keyedSelector.conceptName = conceptName;\r\n      return newSelector;\r\n    } else {\r\n      return undefined;\r\n    }\r\n  };\r\n\r\n/**\r\n * This will update a concepts KeyedSelector to its currently unified concept.\r\n * @Note Use this in place of createUnifiedSelector if you find yourself needing to lock deep values.\r\n */\r\nexport const updateUnifiedKeyedSelector = (concepts: Concepts, semaphore: number, keyedSelector: KeyedSelector) => {\r\n  if (concepts[semaphore]) {\r\n    const newSelector = {...keyedSelector};\r\n    keyedSelector.conceptName = concepts[semaphore].name;\r\n    return newSelector;\r\n  } else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\n/**\r\n * Will create a new KeyedSelector during runtime, for usage within your principles.\r\n * @Note Will want to expand this later, so that we can select into objects and arrays.\r\n *  This would allow us to lock parts of such in later revisions, not an immediate concern.\r\n */\r\nexport const createUnifiedKeyedSelector = <T extends Record<string, unknown>>(\r\n  concepts: Concepts,\r\n  semaphore: number,\r\n  key: keyof T\r\n): KeyedSelector | undefined => {\r\n  const concept = concepts[semaphore];\r\n  if (concept) {\r\n    const name = concept.name;\r\n    return {\r\n      conceptName: name,\r\n      stateKeys: key as string,\r\n    };\r\n  } else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nexport function selectState<T>(concepts: Concepts, name: string): T | undefined {\r\n  let concept;\r\n  const conceptKeys = Object.keys(concepts);\r\n  for (const i of conceptKeys) {\r\n    const index = Number(i);\r\n    if (concepts[index].name === name) {\r\n      concept = concepts[index];\r\n      break;\r\n    }\r\n  }\r\n  return concept?.state as T | undefined;\r\n}\r\n\r\n/**\r\n * Simple helper function that returns payload casted to T.\r\n */\r\nexport function selectPayload<T>(action: Action): T {\r\n  return action.payload as T;\r\n}\r\n\r\n// Note: The Concept Key within the selector has to be set Explicitly for now\r\nexport function selectSlice<T>(\r\n  concepts: Concepts,\r\n  selector: KeyedSelector): T | undefined {\r\n  let concept: Concept | undefined;\r\n  const conceptKey = selector.conceptName;\r\n  const conceptKeys = Object.keys(concepts);\r\n  for (const i of conceptKeys) {\r\n    const index = Number(i);\r\n    if (concepts[index].name === conceptKey) {\r\n      concept = concepts[index];\r\n      break;\r\n    } else if (index === conceptKeys.length - 1) {\r\n      return undefined;\r\n    }\r\n  }\r\n  const keys = selector.stateKeys.split(' ');\r\n  if (concept === undefined) {return undefined;}\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  const cast = concept.state as Record<string, any>;\r\n  let exists = false;\r\n  let previous = cast;\r\n  for (const k of keys) {\r\n    if (typeof previous === 'object' && previous[k] !== undefined) {\r\n      previous = previous[k];\r\n      exists = true;\r\n    } else {\r\n      exists = false;\r\n    }\r\n  }\r\n  if (exists) {\r\n    return previous as T;\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\nexport function selectConcept(concepts: Concepts, name: string): Concept {\r\n  let concept;\r\n  const conceptKeys = Object.keys(concepts);\r\n  for (const i of conceptKeys) {\r\n    const index = Number(i);\r\n    if (concepts[index].name === name) {\r\n      concept = concepts[index];\r\n      break;\r\n    }\r\n  }\r\n  return concept as Concept;\r\n}\r\n\r\n/**\r\n * Allows for the Unification of Concepts and a form of Data Oriented Functional Inheritance.\r\n * @within_principles Simply pass the supplied semaphore passed to your PrincipleFunction to gain access to that State.\r\n * @outside_selection Use selectState targeting that Unified Concept Name\r\n */\r\n\r\n// Either returns the current concept's unified state, or informs that the concept has been removed and the principles needs shutdown\r\nexport function selectUnifiedState<T>(concepts: Concepts, semaphore: number): T | undefined {\r\n  const exists = Object.keys(concepts).includes(`${semaphore}`);\r\n  if (exists) {\r\n    return concepts[semaphore].state as T;\r\n  } else {\r\n    return undefined;\r\n  }\r\n}"},"For the graph programming framework Stratimux, define the Stage Planner model file.\r\nThis file introduces the Unified Subject, that allows for users to stage plans based on observation of the Concepts stream.\r\nThe Stage Planner paradigm is what allows for the ease of working within a recursive run time, via setting plans to specific stages\r\nin order to prevent action overflow. Action overflow is when a function is stuck within a recursive loop. This paradigm\r\nalso ensures Stratimux of its own provable termination in majority of configurations.":{"type":"project","content":"/* eslint-disable complexity */\r\nimport { Subject } from 'rxjs';\r\nimport { Concepts } from './concept';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { KeyedSelector, selectSlice } from './selector';\r\nimport { Action, ActionType } from './action';\r\nimport { axiumSelectOpen } from '../concepts/axium/axium.selector';\r\nimport { ownershipSelectInitialized } from '../concepts/ownership/ownership.selector';\r\nimport { getAxiumState } from './axium';\r\n\r\nexport type Plan = {\r\n  title: string;\r\n  stages: Staging[],\r\n  stage: number;\r\n  stageFailed: number;\r\n  beat: number;\r\n  offBeat: number;\r\n  timer: NodeJS.Timeout[]\r\n}\r\n\r\nexport type NamedStagePlanner = {\r\n  name: string;\r\n  title: string;\r\n  planId: number;\r\n  conclude: () => void;\r\n}\r\n\r\nexport type StagePlanner = {\r\n  title: string;\r\n  planId: number;\r\n  conclude: () => void;\r\n}\r\n\r\nexport type dispatchOptions = {\r\n  runOnce?: boolean;\r\n  iterateStage?: boolean;\r\n  setStage?: number;\r\n  on?: {\r\n    selector: KeyedSelector,\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    expected: any\r\n  },\r\n  throttle?: number;\r\n}\r\n\r\nexport type Dispatcher = (action: Action, options: dispatchOptions) => void;\r\nexport type Staging = (\r\n  concepts: Concepts,\r\n  dispatch: (action: Action, options: dispatchOptions) => void\r\n) => void;\r\nexport type StageDelimiter = {\r\n  stage: number,\r\n  prevActions: ActionType[],\r\n  unionExpiration: number[];\r\n  runOnceMap: Map<string, boolean>\r\n}\r\n\r\nexport const stageWaitForOpenThenIterate = (action: Action): Staging => (concepts: Concepts, dispatch: Dispatcher) => {\r\n  dispatch(action, {\r\n    on: {\r\n      selector: axiumSelectOpen,\r\n      expected: true\r\n    },\r\n    iterateStage: true\r\n  });\r\n};\r\n\r\nexport const stageWaitForOwnershipThenIterate = (action: Action): Staging => (concepts: Concepts, dispatch: Dispatcher) => {\r\n  dispatch(action, {\r\n    on: {\r\n      selector: ownershipSelectInitialized,\r\n      expected: true\r\n    },\r\n    iterateStage: true\r\n  });\r\n};\r\n\r\nconst handleRun =\r\n  (value: Concepts, stageDelimiter: StageDelimiter, plan: Plan, action: Action, options?: dispatchOptions)\r\n    : [StageDelimiter, boolean] => {\r\n    if (options?.on) {\r\n      if (selectSlice(value, options?.on.selector) === options?.on.expected) {\r\n        if (options.runOnce) {\r\n          const runOnceMap = stageDelimiter.runOnceMap.get(action.type + plan.stage);\r\n          if (runOnceMap === undefined) {\r\n            stageDelimiter.runOnceMap.set(action.type + plan.stage, true);\r\n            return [\r\n              stageDelimiter, true\r\n            ];\r\n          } else {\r\n            stageDelimiter.runOnceMap.set(action.type + plan.stage, false);\r\n            return [\r\n              stageDelimiter, false\r\n            ];\r\n          }\r\n        } else {\r\n          return [\r\n            stageDelimiter, true\r\n          ];\r\n        }\r\n      } else {\r\n        const unionExpiration: number[] = [];\r\n        stageDelimiter.prevActions = stageDelimiter.prevActions.filter((at, i) => {\r\n          if (at !== action.type && stageDelimiter.unionExpiration[i] !== action.expiration) {\r\n            unionExpiration.push(unionExpiration[i]);\r\n            return true;\r\n          } else {\r\n            return false;\r\n          }\r\n        });\r\n        stageDelimiter.unionExpiration = unionExpiration;\r\n        return [\r\n          stageDelimiter, false\r\n        ];\r\n      }\r\n    } else if (options?.runOnce) {\r\n      const stageRunner = stageDelimiter.runOnceMap.get(action.type + plan.stage);\r\n      if (stageRunner === undefined) {\r\n        stageDelimiter.runOnceMap.set(action.type + plan.stage, true);\r\n        return [\r\n          stageDelimiter, true\r\n        ];\r\n      } else {\r\n        stageDelimiter.runOnceMap.set(action.type + plan.stage, false);\r\n        return [\r\n          stageDelimiter, false\r\n        ];\r\n      }\r\n    }\r\n    return [\r\n      stageDelimiter,\r\n      true\r\n    ];\r\n  };\r\n\r\nconst handleStageDelimiter =\r\n  (plan: Plan, action: Action, delimiter?: StageDelimiter, options?: dispatchOptions): [StageDelimiter, boolean] => {\r\n    let stageDelimiter = delimiter;\r\n    let goodAction = true;\r\n    if (stageDelimiter &&\r\n        stageDelimiter.prevActions.includes(action.type) &&\r\n        options?.throttle === undefined) {\r\n      if (plan.stage !== stageDelimiter?.stage) {\r\n        stageDelimiter = {\r\n          stage: plan.stage,\r\n          prevActions: [action.type],\r\n          unionExpiration: [action.expiration],\r\n          runOnceMap: new Map()\r\n        };\r\n      } else {\r\n        goodAction = false;\r\n      }\r\n    } else if (stageDelimiter) {\r\n      if (stageDelimiter.prevActions.length > 4) {\r\n        stageDelimiter = {\r\n          stage: plan.stage,\r\n          prevActions: [\r\n            stageDelimiter.prevActions[1],\r\n            stageDelimiter.prevActions[2],\r\n            stageDelimiter.prevActions[3],\r\n            stageDelimiter.prevActions[4],\r\n            action.type\r\n          ],\r\n          unionExpiration: [\r\n            stageDelimiter.unionExpiration[1],\r\n            stageDelimiter.unionExpiration[2],\r\n            stageDelimiter.unionExpiration[3],\r\n            stageDelimiter.unionExpiration[4],\r\n            action.expiration\r\n          ],\r\n          runOnceMap: new Map()\r\n        };\r\n      } else {\r\n        stageDelimiter = {\r\n          stage: plan.stage,\r\n          prevActions: [...stageDelimiter.prevActions, action.type],\r\n          unionExpiration: [...stageDelimiter.unionExpiration, action.expiration],\r\n          runOnceMap: new Map()\r\n        };\r\n      }\r\n    } else {\r\n      stageDelimiter = {\r\n        stage: plan.stage,\r\n        prevActions: [action.type],\r\n        unionExpiration: [action.expiration],\r\n        runOnceMap: new Map()\r\n      };\r\n    }\r\n    return [\r\n      stageDelimiter,\r\n      goodAction\r\n    ];\r\n  };\r\n\r\nexport class UnifiedSubject extends Subject<Concepts> {\r\n  private planId = 0;\r\n  private currentStages: Map<number, Plan> = new Map();\r\n  private stageDelimiters: Map<number, StageDelimiter> = new Map();\r\n  private concepts: Concepts = {};\r\n  constructor() {\r\n    super();\r\n  }\r\n  stage(title: string, stages: Staging[], beat?: number): StagePlanner {\r\n    const planId = this.planId;\r\n    this.planId++;\r\n    this.currentStages.set(planId, {title, stages, stage: 0, stageFailed: -1, beat: beat ? beat : -1, offBeat: -1, timer: []});\r\n    const conclude = () => {\r\n      this.currentStages.delete(planId);\r\n    };\r\n    return {\r\n      title: title,\r\n      planId: planId,\r\n      conclude: conclude.bind(this)\r\n    };\r\n  }\r\n\r\n  protected _dispatch(\r\n    axiumState: AxiumState,\r\n    key: number, plan: Plan,\r\n    value: Concepts,\r\n    action: Action,\r\n    options: dispatchOptions): void {\r\n    let stageDelimiter = this.stageDelimiters.get(key);\r\n    let throttle = false;\r\n    let goodAction = true;\r\n    let run = true;\r\n    [stageDelimiter, goodAction] = handleStageDelimiter(plan, action, stageDelimiter, options);\r\n    [stageDelimiter, run] = handleRun(value, stageDelimiter, plan, action, options);\r\n    // console.log('HIT', action, goodAction, run);\r\n    this.stageDelimiters.set(key, stageDelimiter);\r\n    if (goodAction && run) {\r\n      const action$ = axiumState.action$ as Subject<Action>;\r\n      if (options?.throttle !== undefined) {\r\n        let previousExpiration = 0;\r\n        for (let i = 0; i < stageDelimiter.prevActions.length; i++) {\r\n          if (stageDelimiter.prevActions[i] === action.type) {\r\n            previousExpiration = stageDelimiter.unionExpiration[i];\r\n            break;\r\n          }\r\n        }\r\n        if (previousExpiration !== action.expiration && action.expiration - previousExpiration < options?.throttle) {\r\n          throttle = true;\r\n        } else {\r\n          for (let i = 0; i < stageDelimiter.prevActions.length; i++) {\r\n            if (stageDelimiter.prevActions[i] === action.type) {\r\n              stageDelimiter.unionExpiration[i] = action.expiration;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      this.stageDelimiters.set(key, stageDelimiter);\r\n      if (!throttle && run) {\r\n        if (options?.iterateStage) {\r\n          plan.stage += 1;\r\n        }\r\n        if (options?.setStage) {\r\n          plan.stage = options.setStage;\r\n        }\r\n        if (options?.iterateStage || (options?.setStage && options.setStage !== plan.stage)) {\r\n          stageDelimiter.prevActions = [];\r\n          stageDelimiter.unionExpiration = [];\r\n          stageDelimiter.runOnceMap = new Map();\r\n          this.stageDelimiters.set(key, stageDelimiter);\r\n        }\r\n        // Horrifying\r\n        // Keep in place, this prevents branch prediction from creating ghost actions if there is an action overflow.\r\n        if (plan.stageFailed === -1) {\r\n          action$.next(action);\r\n        }\r\n      }\r\n    } else if (\r\n      options?.runOnce === undefined &&\r\n      (options.on === undefined ||\r\n      (options.on && (!options.throttle && (options.iterateStage === undefined || options.setStage === plan.stage)))\r\n      )) {\r\n      plan.stageFailed = plan.stage;\r\n      plan.stage = plan.stages.length;\r\n      const deleted = this.currentStages.delete(key);\r\n      if (deleted) {\r\n        axiumState.badPlans.push(plan);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected execute(plan: Plan, key: number, index: number): void {\r\n    const axiumState = getAxiumState(this.concepts);\r\n    const dispatcher: Dispatcher = (() => (action: Action, options: dispatchOptions) => {\r\n      this._dispatch(axiumState, key, plan, this.concepts, action, options);\r\n    }).bind(this)();\r\n    plan.stages[index](this.concepts, dispatcher);\r\n  }\r\n\r\n  next(value: Concepts) {\r\n    this.concepts = {\r\n      ...value\r\n    };\r\n    if (!this.closed) {\r\n      // Need a Stage Observer that would merely deconstruct to {concepts: Concepts , dispatch: Dispatcher}\r\n      // Where Dispatcher would be (action$: Subject<Action>) => {}();\r\n      this.currentStages.forEach((plan, key) => {\r\n        const index = plan.stage;\r\n        if (index < plan.stages.length) {\r\n          const timer = plan.timer;\r\n          const now = Date.now();\r\n          if (plan.beat > -1) {\r\n            if (plan.offBeat < now) {\r\n              plan.offBeat = Date.now() + plan.beat;\r\n              this.execute(plan, key, index);\r\n            } else if (timer.length === 0 && plan.offBeat > now) {\r\n              timer.push(setTimeout(() => {\r\n                plan.timer = [];\r\n                plan.offBeat = Date.now() + plan.beat;\r\n                this.execute(plan, key, index);\r\n              }, plan.offBeat - Date.now()));\r\n            }\r\n          } else {\r\n            this.execute(plan, key, index);\r\n          }\r\n        }\r\n      });\r\n      const {observers} = this;\r\n\r\n      const len = observers.length;\r\n      for (let i = 0; i < len; i++) {\r\n        if (observers[i]) {\r\n          observers[i].next(this.concepts);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}"},"For the graph programming framework Stratimux, generate a test to ensure that actions are being created as intended.":{"type":"project","content":"import { createAction } from '../model/action';\r\nimport { counterAdd, counterAddType } from '../concepts/counter/qualities/add.quality';\r\n\r\ntest('Axium add Concepts Strategy Test', (done) => {\r\n  const something = createAction('something');\r\n  expect(something.type).toBe('something');\r\n  const add = counterAdd();\r\n  expect(add.type).toBe(counterAddType);\r\n  console.log(add.type);\r\n  done();\r\n});"},"For the graph programming framework Stratimux, generate a test to ensure that the ActionController model is working as intended.":{"type":"project","content":"import { ActionController, createActionController$ } from '../model/actionController';\r\nimport { axiumBadActionType  } from '../concepts/axium/qualities/badAction.quality';\r\nimport { axiumLog, axiumLogType } from '../concepts/axium/qualities/log.quality';\r\n\r\ntest('ActionController Expired Test', (done) => {\r\n  const act = axiumLog(undefined, undefined, 200);\r\n  const cont = new ActionController(act);\r\n  cont.subscribe(action => {\r\n    expect(action.type).toBe(axiumBadActionType);\r\n    done();\r\n  });\r\n});\r\n\r\ntest('ActionController Next Test', (done) => {\r\n  const act = axiumLog(undefined, undefined, 200);\r\n  const cont = new ActionController(act);\r\n  cont.subscribe(action => {\r\n    expect(action.type).toBe(axiumLogType);\r\n    done();\r\n  });\r\n  cont.fire(act);\r\n});\r\n\r\ntest('ActionController createActionController$ Test', (done) => {\r\n  const act = axiumLog(undefined, undefined, 200);\r\n  const cont = createActionController$(act, (controller, action) => {\r\n    controller.fire(action);\r\n  });\r\n  cont.subscribe(action => {\r\n    expect(action.type).toBe(axiumLogType);\r\n    done();\r\n  });\r\n});"},"For the graph programming framework Stratimux, generate a test that ensures that the Axium can add concepts into its conceptual sets.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, countingStrategy, counterName } from '../concepts/counter/counter.concept';\r\nimport { addConceptsToAddQueThenBlockStrategy } from '../concepts/axium/strategies/addConcept.strategy';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { countingTopic } from '../concepts/counter/strategies/counting.strategy';\r\nimport { forEachConcept } from '../model/concept';\r\n\r\ntest('Axium add Concepts Strategy Test', (done) => {\r\n  const axium = createAxium('axiumAddConceptTest',[], true, true);\r\n  const plan = axium.stage('Add Concepts Stage',[\r\n    (concepts, dispatch) => {\r\n      dispatch(\r\n        strategyBegin(\r\n          addConceptsToAddQueThenBlockStrategy(concepts,[createCounterConcept()])\r\n        ),\r\n        {\r\n          iterateStage: true\r\n        }\r\n      );\r\n    },\r\n    (concepts, dispatch) => {\r\n      let exists = false;\r\n      console.log('CHECK CONCEPTS', concepts);\r\n      forEachConcept(concepts, (concept) => {\r\n        if (concept.name === counterName) {\r\n          exists = true;\r\n          dispatch(strategyBegin(countingStrategy()), {\r\n            iterateStage: true\r\n          });\r\n          expect(exists).toBe(true);\r\n        }\r\n      });\r\n    },\r\n    (concepts) => {\r\n      const axiumState = concepts[0].state as AxiumState;\r\n      if (axiumState.lastStrategy === countingTopic) {\r\n        const counter = selectState<CounterState>(concepts, counterName);\r\n        expect(counter?.count).toBe(1);\r\n        setTimeout(() => {done();}, 500);\r\n        plan.conclude();\r\n        axium.close();\r\n      }\r\n    }\r\n  ]);\r\n});"},"For the graph programming framework Stratimux,\r\ngenerate a test to ensure that the strategy consumer function strategyRecurse is functioning as intended.":{"type":"project","content":"/*<$\r\nFor the graph programming framework Stratimux,\r\ngenerate a test to ensure that the strategy consumer function strategyRecurse is functioning as intended.\r\n$>*/\r\n/*<#*/"},"For the graph programming framework Stratimux, generate a test to ensure the Axium's ability to stitch strategies together and likewise\r\nfor the getAxiumState helper function to properly return the current axium state.":{"type":"project","content":"/*<$\r\nFor the graph programming framework Stratimux, generate a test to ensure the Axium's ability to stitch strategies together and likewise\r\nfor the getAxiumState helper function to properly return the current axium state.\r\n$>*/\r\n/*<#*/"},"For the graph programming framework Stratimux and Chain Concept, generate a test ensure that chain is working as intended.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { Concepts } from '../model/concept';\r\nimport { primeAction } from '../model/action';\r\nimport { selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, counterName } from '../concepts/counter/counter.concept';\r\nimport { createChainConcept } from '../concepts/chain/chain.concept';\r\nimport { chainDispatchActions } from '../concepts/chain/qualities/prepareChain.quality';\r\nimport { counterAdd } from '../concepts/counter/qualities/add.quality';\r\nimport { counterSubtract } from '../concepts/counter/qualities/subtract.quality';\r\n\r\ntest('Axium Test', (done) => {\r\n  const axium = createAxium('chainConceptTest', [createCounterConcept(), createChainConcept()], true, true);\r\n  let count = 0;\r\n  let willDispatch = true;\r\n  const sub = axium.subscribe((concepts: Concepts) => {\r\n    count++;\r\n    if (willDispatch) {\r\n      willDispatch = false;\r\n      const primedAdd = primeAction(concepts, counterAdd());\r\n      const primedSubtract = primeAction(concepts, counterSubtract());\r\n      const primedPrepareChain =\r\n      primeAction(concepts,\r\n        chainDispatchActions({\r\n          actions: [\r\n            primedAdd,\r\n            primedAdd,\r\n            primedSubtract,\r\n            primedAdd,\r\n            primedSubtract,\r\n            primedAdd,\r\n          ]\r\n        }));\r\n      axium.dispatch(primedPrepareChain);\r\n    }\r\n    else if (count === 7) {\r\n      const counter = selectState<CounterState>(concepts, counterName);\r\n      expect(counter?.count).toBe(2);\r\n      setTimeout(() => {done();}, 500);\r\n      axium.close();\r\n      sub.unsubscribe();\r\n    }\r\n  });\r\n});"},"For the graph programming framework Stratimux,\r\ngenerate a test to that ensures the functionality of is concept loaded and are concept loaded helper functions.":{"type":"project","content":"import { counterName, createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { createAxium } from '../model/axium';\r\nimport { areConceptsLoaded, chainName, createChainConcept, isConceptLoaded } from '../index';\r\n\r\ntest('Concepts exists', (done) => {\r\n  const axium = createAxium('Mock Axium', [createCounterConcept()]);\r\n  axium.stage('Check Concepts', [\r\n    (concepts, __) => {\r\n      if (isConceptLoaded(concepts, counterName)) {\r\n        expect(true).toBe(true);\r\n        done();\r\n      } else {\r\n        expect(false).toBe(true);\r\n        done();\r\n      }\r\n    },\r\n  ]);\r\n});\r\n\r\ntest('Concepts exists', (done) => {\r\n  const axium = createAxium('Mock Axium', [createCounterConcept(), createChainConcept()]);\r\n  const stage = axium.stage('Check Concepts', [\r\n    (concepts, __) => {\r\n      if (areConceptsLoaded(concepts, [counterName, chainName])) {\r\n        expect(true).toBe(true);\r\n        stage.conclude();\r\n        axium.close();\r\n        done();\r\n      } else {\r\n        expect(false).toBe(true);\r\n        stage.conclude();\r\n        axium.close();\r\n        done();\r\n      }\r\n    },\r\n  ]);\r\n});"},"For the graph programming framework Stratimux, generate a test that logs how a concept would be parsed to a stream to the console.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { conceptsToString } from '../model/concept';\r\n\r\ntest('Axium Counting Strategy Test', (done) => {\r\n  const axium = createAxium('axiumStrategyTest', [createCounterConcept()], true, true);\r\n  const sub = axium.subscribe(concepts => {\r\n    console.log('CONCEPTS:', conceptsToString(concepts));\r\n    expect(true).toBe(true);\r\n    sub.unsubscribe();\r\n    setTimeout(() => {\r\n      done();\r\n    }, 500);\r\n  });\r\n});"},"For the graph programming framework Stratimux, generate a tests and demonstrates how debouncing methods perform their functionality.":{"type":"project","content":"import { axiumSelectLastStrategy, axiumSelectLastStrategyData } from '../concepts/axium/axium.selector';\r\nimport { axiumKick } from '../concepts/axium/qualities/kick.quality';\r\nimport { CounterState, counterName, createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { ExperimentState, createExperimentConcept, createExperimentState, experimentName } from '../concepts/experiment/experiment.concept';\r\nimport {\r\n  experimentDebounceAsyncIterateIdThenReceiveInMethodQuality\r\n} from '../concepts/experiment/qualities/debounceAsyncIterateIdThenReceiveInMethod.quality';\r\nimport { asyncDebounceNextActionNodeQuality } from '../concepts/experiment/qualities/debounceAsyncNextActionNode.quality';\r\nimport {\r\n  ExperimentDebounceIterateIdThenReceiveInMethodPayload,\r\n  experimentDebounceIterateIdThenReceiveInMethodQuality\r\n} from '../concepts/experiment/qualities/debounceIterateIdThenReceiveInMethod.quality';\r\nimport { debounceNextActionNodeQuality } from '../concepts/experiment/qualities/debounceNextActionNode.quality';\r\nimport { experimentAsyncDebounceAddOneStrategy } from '../concepts/experiment/strategies/asyncDebounceAddOne.strategy';\r\nimport { experimentDebounceAddOneStrategy } from '../concepts/experiment/strategies/debounceAddOne.strategy';\r\nimport {\r\n  experimentDebounceAsyncIterateIdThenAddToData,\r\n  experimentDebounceAsyncIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/debounceAsyncIterateIdThenAddToData.strategy';\r\nimport {\r\n  experimentDebounceIterateIdThenAddToData,\r\n  experimentDebounceIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/debounceIterateIdThenAddToData.strategy';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { createAxium } from '../model/axium';\r\nimport { selectSlice, selectState } from '../model/selector';\r\n\r\ntest('Debounce method prevent excess count', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [debounceNextActionNodeQuality]);\r\n  const axium = createAxium('Experiment async method creator with State', [createCounterConcept(), experiment]);\r\n  const plan = axium.stage('Experiment debounce add one', [\r\n    (_, dispatch) => {\r\n      dispatch(strategyBegin(experimentDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (_, dispatch) => {\r\n      dispatch(strategyBegin(experimentDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (_, dispatch) => {\r\n      dispatch(strategyBegin(experimentDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (concepts, _) => {\r\n      const counterState = selectState<CounterState>(concepts, counterName);\r\n      console.log('Debounce HIT 4', counterState);\r\n      if (counterState?.count === 1) {\r\n        console.log('Final Debounce HIT 4', counterState);\r\n        expect(counterState.count).toBe(1);\r\n        plan.conclude();\r\n        done();\r\n      }\r\n    }\r\n  ]);\r\n});\r\n\r\ntest('Async debounce method prevent excess count', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [asyncDebounceNextActionNodeQuality]);\r\n  const axium = createAxium('Experiment async debounce', [createCounterConcept(), experiment]);\r\n  const plan = axium.stage('Experiment async debounce add one', [\r\n    (_, dispatch) => {\r\n      dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (_, dispatch) => {\r\n      dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (_, dispatch) => {\r\n      dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (concepts, _) => {\r\n      const counterState = selectState<CounterState>(concepts, counterName);\r\n      console.log('Async Debounce HIT 4', counterState);\r\n      if (counterState?.count === 1) {\r\n        console.log('FINAL Async Debounce HIT 4', counterState);\r\n        expect(counterState.count).toBe(1);\r\n        plan.conclude();\r\n      }\r\n    }\r\n  ]);\r\n  setTimeout(() => {\r\n    const secondPlan = axium.stage('Second experiment async debounce add one', [\r\n      (_, dispatch) => {\r\n        dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n          iterateStage: true\r\n        });\r\n      },\r\n      (_, dispatch) => {\r\n        dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n          iterateStage: true\r\n        });\r\n      },\r\n      (_, dispatch) => {\r\n        dispatch(strategyBegin(experimentAsyncDebounceAddOneStrategy()), {\r\n          iterateStage: true\r\n        });\r\n      },\r\n      (concepts, _) => {\r\n        const counterState = selectState<CounterState>(concepts, counterName);\r\n        console.log('Async 2 Debounce HIT 4', counterState);\r\n        if (counterState?.count === 2) {\r\n          console.log('FINAL Async 2 Debounce HIT 4', counterState);\r\n          expect(counterState.count).toBe(2);\r\n          secondPlan.conclude();\r\n          axium.close();\r\n          setTimeout(() => {\r\n            done();\r\n          }, 500);\r\n        }\r\n      }\r\n    ]);\r\n    // Axium must be primed, therefore we kick it back into gear.\r\n    // Downside of halting quality.\r\n    axium.dispatch(axiumKick());\r\n  }, 1000);\r\n});\r\n\r\ntest('Debounce Method Test with State id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentDebounceIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.stage('Debounce Iterate id with concepts', [\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Debounce: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Debounce: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, _) => {\r\n      const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const data = selectSlice<ExperimentState & ExperimentDebounceIterateIdThenReceiveInMethodPayload>(\r\n          concepts,\r\n          axiumSelectLastStrategyData\r\n        );\r\n        console.log('Debounce: ', experimentState.id, lastStrategy, data);\r\n        if (lastStrategy === experimentDebounceIterateIdThenAddToDataTopic) {\r\n          if (data) {\r\n            console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n            expect(data.id).toBe(3);\r\n            expect(data.setId).toBe(2);\r\n            expect(experimentState.id).toBe(3);\r\n            plan.conclude();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  ]);\r\n  setTimeout(() => {\r\n    console.log('BEGIN 2ND PLAN');\r\n    const secondPlan = axium.stage('Second experiment debounce add one', [\r\n      (concepts, dispatch) => {\r\n        console.log('2 Debounce initial dispatch');\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      },\r\n      (concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('2 Debounce: ', experimentState.id, lastStrategy, data);\r\n          dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      },\r\n      (concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('2 Debounce: ', experimentState.id, lastStrategy, data);\r\n          dispatch(strategyBegin(experimentDebounceIterateIdThenAddToData(experimentState.id)), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      },\r\n      (concepts, _) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState & ExperimentDebounceIterateIdThenReceiveInMethodPayload>(\r\n            concepts,\r\n            axiumSelectLastStrategyData\r\n          );\r\n          console.log('2 Debounce: ', experimentState.id, lastStrategy, data);\r\n          if (lastStrategy === experimentDebounceIterateIdThenAddToDataTopic) {\r\n            if (data && data.id === 6) {\r\n              console.log('2 Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n              expect(data.id).toBe(6);\r\n              expect(data.setId).toBe(5);\r\n              expect(experimentState.id).toBe(6);\r\n              secondPlan.conclude();\r\n              axium.close();\r\n              done();\r\n            }\r\n          }\r\n        }\r\n      }\r\n    ]);\r\n    // Kick\r\n    axium.dispatch(axiumKick());\r\n  }, 1000);\r\n});\r\n\r\ntest('Debounce Async Method Test with State id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentDebounceAsyncIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.stage('Debounce Async Iterate id with concepts', [\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        dispatch(strategyBegin(experimentDebounceAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Async Debounce: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentDebounceAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Async Debounce: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentDebounceAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState & ExperimentDebounceIterateIdThenReceiveInMethodPayload>(\r\n          concepts,\r\n          axiumSelectLastStrategyData\r\n        );\r\n        console.log('Async Debounce: ', experimentState.id, lastStrategy, data);\r\n        if (lastStrategy === experimentDebounceAsyncIterateIdThenAddToDataTopic) {\r\n          if (data) {\r\n            console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n            expect(data.id).toBe(3);\r\n            expect(data.setId).toBe(2);\r\n            expect(experimentState.id).toBe(3);\r\n            plan.conclude();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  ]);\r\n  setTimeout(() => {\r\n    console.log('BEGIN 2ND PLAN');\r\n    const secondPlan = axium.stage('Second experiment async debounce add one', [\r\n      (concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const strategy = experimentDebounceAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      },\r\n      (concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('2 Async Debounce: ', experimentState.id, lastStrategy, data);\r\n          const strategy = experimentDebounceAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      },\r\n      (concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('2 Async Debounce: ', experimentState.id, lastStrategy, data);\r\n          const strategy = experimentDebounceAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      },\r\n      (concepts, _) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState & ExperimentDebounceIterateIdThenReceiveInMethodPayload>(\r\n            concepts,\r\n            axiumSelectLastStrategyData\r\n          );\r\n          console.log('2 Async Debounce: ', experimentState.id, lastStrategy, data);\r\n          if (lastStrategy === experimentDebounceAsyncIterateIdThenAddToDataTopic + 2) {\r\n            if (data) {\r\n              console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n              expect(data.id).toBe(6);\r\n              expect(data.setId).toBe(5);\r\n              expect(experimentState.id).toBe(6);\r\n              secondPlan.conclude();\r\n              axium.close();\r\n              done();\r\n            }\r\n          }\r\n        }\r\n      }\r\n    ]);\r\n    // Kick\r\n    axium.dispatch(axiumKick());\r\n  }, 1000);\r\n});"},"For the graph programming framework Stratimux, generate a test to ensure that method helpers are working as intended.":{"type":"project","content":"import { axiumSelectLastStrategy, axiumSelectLastStrategyData } from '../concepts/axium/axium.selector';\r\nimport { ExperimentState, createExperimentConcept, createExperimentState, experimentName } from '../concepts/experiment/experiment.concept';\r\nimport {\r\n  experimentAsyncIterateIdThenReceiveInMethod,\r\n  experimentAsyncIterateIdThenReceiveInMethodQuality\r\n} from '../concepts/experiment/qualities/asyncIterateIdThenReceiveInMethod.quality';\r\nimport { experimentIterateIdThenReceiveInMethodQuality } from '../concepts/experiment/qualities/iterateIdThenReceiveInMethod.quality';\r\nimport { mockToTrueQuality } from '../concepts/experiment/qualities/mockTrue.quality';\r\nimport { timerEmitActionQuality } from '../concepts/experiment/qualities/timerEmitAction.quality';\r\nimport { timerEmitActionWithStateQuality } from '../concepts/experiment/qualities/timerEmitActionWithState.quality';\r\nimport {\r\n  experimentAsyncIterateIdThenAddToData,\r\n  experimentAsyncIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/asyncIterateIdThenAddToData.strategy';\r\nimport {\r\n  iterateIdThenAddToData,\r\n  experimentIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/iterateIdThenAddToData.strategy';\r\nimport { experimentTimedMockToTrue } from '../concepts/experiment/strategies/timedMockToTrue.strategy';\r\nimport {\r\n  timedMockToTrueWithState,\r\n  experimentTimedMockToTrueWithStateTopic\r\n} from '../concepts/experiment/strategies/timedMockToTrueWithState.strategy';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { createAxium } from '../model/axium';\r\nimport { selectSlice, selectState } from '../model/selector';\r\n\r\ntest('Async Method Test', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [timerEmitActionQuality, mockToTrueQuality]);\r\n  const axium = createAxium('Experiment async method creator', [experiment]);\r\n  const plan = axium.stage('timed mock to true', [\r\n    (_, dispatch) => {\r\n      dispatch(strategyBegin(experimentTimedMockToTrue()), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState?.mock) {\r\n        expect(experimentState.mock).toBe(true);\r\n        plan.conclude();\r\n        axium.close();\r\n        done();\r\n      }\r\n    }\r\n  ]);\r\n});\r\n\r\ntest('Async Method Plain Iterate Id Test', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentAsyncIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment async method creator', [experiment]);\r\n  const plan = axium.stage('timed mock to true', [\r\n    (_, dispatch) => {\r\n      dispatch(experimentAsyncIterateIdThenReceiveInMethod(), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      console.log(experiment.state);\r\n      if (experimentState?.id) {\r\n        expect(experimentState.id).toBe(1);\r\n        setTimeout(() => {\r\n          plan.conclude();\r\n          axium.close();\r\n        }, 50);\r\n        done();\r\n      }\r\n    }\r\n  ]);\r\n});\r\n\r\ntest('Async Method with State Test', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [timerEmitActionWithStateQuality, mockToTrueQuality]);\r\n  const axium = createAxium('Experiment async method creator with State', [experiment]);\r\n  const plan = axium.stage('timed mock to true', [\r\n    (_, dispatch) => {\r\n      dispatch(strategyBegin(timedMockToTrueWithState()), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        if (lastStrategy === experimentTimedMockToTrueWithStateTopic) {\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          if (data) {\r\n            expect(data.mock).toBe(false);\r\n            expect(experimentState.mock).toBe(true);\r\n            plan.conclude();\r\n            axium.close();\r\n            done();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  ]);\r\n});\r\n\r\ntest('Method Test with State id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.stage('Iterate id', [\r\n    (_, dispatch) => {\r\n      dispatch(strategyBegin(iterateIdThenAddToData()), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        if (lastStrategy === experimentIterateIdThenAddToDataTopic) {\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          if (data) {\r\n            console.log('Strategy Data: ', data.id, 'Experiment State ID: ', experimentState.id);\r\n            expect(data.id).toBe(0);\r\n            expect(experimentState.id).toBe(1);\r\n            plan.conclude();\r\n            axium.close();\r\n            done();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  ]);\r\n});\r\n\r\ntest('Async Method Test with State id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentAsyncIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.stage('Iterate id', [\r\n    (_, dispatch) => {\r\n      dispatch(strategyBegin(experimentAsyncIterateIdThenAddToData()), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (concepts, _) => {\r\n      const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        if (lastStrategy === experimentAsyncIterateIdThenAddToDataTopic) {\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          if (data) {\r\n            console.log('Async Strategy Data: ', data.id, 'Experiment State ID: ', experimentState.id);\r\n            expect(data.id).toBe(0);\r\n            expect(experimentState.id).toBe(1);\r\n            plan.conclude();\r\n            axium.close();\r\n            done();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  ]);\r\n});"},"For the graph programming framework Stratimux and Ownership Concept, devise a test that will ensure that the concept is working as intended.":{"type":"project","content":"import { createAxium  } from '../model/axium';\r\nimport { Concepts } from '../model/concept';\r\nimport { selectState } from '../model/selector';\r\nimport { OwnershipState, createOwnershipConcept, ownershipName } from '../concepts/ownership/ownership.concept';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { ownershipSetOwnerShipModeTopic } from '../concepts/ownership/strategies/setOwnerShipMode.strategy';\r\nimport { CounterState, counterName, createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { createExperimentState, createExperimentConcept } from '../concepts/experiment/experiment.concept';\r\nimport { experimentPuntCountingStrategy } from '../concepts/experiment/strategies/puntCounting.strategy';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport {\r\n  experimentPrimedCountingStrategy,\r\n  experimentCountingTopic,\r\n  experimentPrimedCountingTopic\r\n} from '../concepts/experiment/strategies/experimentCounting.strategy';\r\nimport { axiumLog } from '../concepts/axium/qualities/log.quality';\r\nimport { counterSetCount } from '../concepts/counter/qualities/setCount.quality';\r\nimport { checkInStrategyQuality } from '../concepts/experiment/qualities/checkInStrategy.quality';\r\nimport { experimentActionQuePrinciple } from '../concepts/experiment/experiment.principle';\r\n\r\ntest('Ownership Test', (done) => {\r\n  const orderOfTopics: string[] = [];\r\n  let finalRun = true;\r\n  const axium = createAxium('ownershipTest', [\r\n    createOwnershipConcept(),\r\n    createCounterConcept(),\r\n    createExperimentConcept(createExperimentState(), [checkInStrategyQuality], [experimentActionQuePrinciple])\r\n  ], true, true);\r\n  const plan = axium.stage(\r\n    'Testing Ownership Staging', [\r\n      (cpts, dispatch) => {\r\n        const axiumState = cpts[0].state as AxiumState;\r\n        if (axiumState.lastStrategy === ownershipSetOwnerShipModeTopic) {\r\n          const ownership = selectState<OwnershipState>(cpts, ownershipName);\r\n          if (ownership) {\r\n            console.log('Stage 1', ownership.ownershipLedger, ownership.pendingActions);\r\n            const counter = selectState<CounterState>(cpts, counterName);\r\n            console.log('Count: ', counter?.count);\r\n            // This will place a counting strategy in the experiment actionQue to be later dispatched.\r\n            //    Via its principle, to simulate an action moving off premise.\r\n            dispatch(strategyBegin(experimentPuntCountingStrategy()), {\r\n              iterateStage: true\r\n            });\r\n          }\r\n        }\r\n      },\r\n      // Comment out if testing log and the halting quality of the Unified Turing Machine.\r\n      (cpts, dispatch) => {\r\n        // Will be ran after both counting strategies conclude.\r\n        const ownership = selectState<OwnershipState>(cpts, ownershipName);\r\n        if (ownership) {\r\n          console.log('Stage 2', ownership.ownershipLedger, ownership.pendingActions);\r\n          dispatch(counterSetCount({newCount: 1000}, undefined, undefined, 7000), { iterateStage: true});\r\n        }\r\n      },\r\n      (cpts, dispatch) => {\r\n        const ownership = selectState<OwnershipState>(cpts, ownershipName);\r\n        if (ownership) {\r\n          console.log('Stage 3', ownership.ownershipLedger, ownership.pendingActions);\r\n          const counter = selectState<CounterState>(cpts, counterName);\r\n          console.log('Count: ', counter?.count);\r\n          dispatch(strategyBegin(experimentPrimedCountingStrategy(cpts)), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      },\r\n      (cpts, dispatch) => {\r\n        const axiumState = cpts[0].state as AxiumState;\r\n        const counter = selectState<CounterState>(cpts, counterName);\r\n        if (counter) {\r\n          console.log('Stage 4', axiumState.lastStrategy, orderOfTopics);\r\n          if (orderOfTopics.length === 2 && finalRun) {\r\n            finalRun = false;\r\n            // This will be the final test to be triggered by a log action.\r\n            console.log('Stage 3, If #3 | Count: ', counter.count, orderOfTopics);\r\n            expect(orderOfTopics[0]).toBe(experimentCountingTopic);\r\n            expect(counter.count).toBe(3);\r\n            // Comment in if testing the halting ability of log and setCount stage is commented out.\r\n            // setTimeout(() => {done();}, 1000);\r\n            plan.conclude();\r\n          } else if (\r\n            (axiumState.lastStrategy === experimentCountingTopic ||\r\n            axiumState.lastStrategy === experimentPrimedCountingTopic) &&\r\n            orderOfTopics.length === 0) {\r\n            console.log('Stage 3, If #1 | Count: ', counter.count);\r\n            orderOfTopics.push(axiumState.lastStrategy);\r\n          } else if (\r\n            (axiumState.lastStrategy === experimentCountingTopic ||\r\n            axiumState.lastStrategy === experimentPrimedCountingTopic) &&\r\n            orderOfTopics.length === 1) {\r\n            if (orderOfTopics[0] !== axiumState.lastStrategy) {\r\n              console.log('Stage 3, If #2 | Count: ', counter.count);\r\n              orderOfTopics.push(axiumState.lastStrategy);\r\n              // Due to the halting behavior of a Unified Turing Machine, this will trigger before set Count at step 2.\r\n              //  If commented out, set Count will trigger the the \"If #3\" check.\r\n              //  If commenting out setCount stage, disable the test in the subscription\r\n              //    Then be sure to enabled the final done check in \"If #3\".\r\n              //    Then enabling the axiumLog dispatch will allow the test to conclude.\r\n              //    But disabling the axiumLog will never trigger the \"If #3\" check and disallow the test to conclude.\r\n              //      This proves Stratimux as a Unified Turing Machine and this configuration Halting Complete.\r\n              dispatch(axiumLog(), {\r\n                runOnce: true\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    ]);\r\n  const sub = axium.subscribe((concepts: Concepts) => {\r\n    const state = selectState<OwnershipState>(concepts, ownershipName);\r\n    if (state) {\r\n      const _axiumState = concepts[0].state as AxiumState;\r\n      if (state.initialized && _axiumState.lastStrategy === ownershipSetOwnerShipModeTopic) {\r\n        expect(state.initialized).toBe(true);\r\n      }\r\n      const counter = selectState<CounterState>(concepts, counterName);\r\n      // This will run last, despite setCount being the second staged dispatch.\r\n      if (counter && counter.count >= 1000) {\r\n        console.log('Subscription, Final Count: ', counter.count, orderOfTopics);\r\n        expect(counter.count).toBe(1000);\r\n        // Comment out if setCount stage is disabled and instead testing axiumLogs of \"If #2\" halting interaction.\r\n        setTimeout(() => {done();}, 1000);\r\n        sub.unsubscribe();\r\n        axium.close();\r\n      }\r\n    }\r\n  });\r\n});"},"For the graph programming framework Stratimux, generate a test to ensure that the axium can properly remove concepts from its current load.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { createCounterConcept, counterName } from '../concepts/counter/counter.concept';\r\nimport {\r\n  addConceptsToRemovalQueThenBlockStrategy,\r\n  removeConceptsViaQueThenUnblockTopic\r\n} from '../concepts/axium/strategies/removeConcept.strategy';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { forEachConcept } from '../model/concept';\r\n\r\ntest('Axium remove Concepts Strategy Test', (done) => {\r\n  const axium = createAxium('axiumRemoveConceptsTest', [createCounterConcept()], true, true);\r\n  const plan = axium.stage('Remove Concepts Stage',[\r\n    (concepts, dispatch) => {\r\n      dispatch(\r\n        strategyBegin(\r\n          addConceptsToRemovalQueThenBlockStrategy(concepts,[createCounterConcept()])\r\n        ), {\r\n          iterateStage: true\r\n        }\r\n      );\r\n    },\r\n    (concepts) => {\r\n      const axiumState = concepts[0].state as AxiumState;\r\n      if (axiumState.lastStrategy === removeConceptsViaQueThenUnblockTopic) {\r\n        let exists = false;\r\n        forEachConcept(concepts, (concept => {\r\n          if (concept.name === counterName) {\r\n            exists = true;\r\n          }\r\n        }));\r\n        expect(exists).toBe(false);\r\n        setTimeout(() => {done();}, 500);\r\n        plan.conclude();\r\n        axium.close();\r\n      }\r\n    }\r\n  ]);\r\n});"},"For the graph programming framework Stratimux,\r\ngenerate a test to that selectSlice is capable of performing shallow and deep state selections.":{"type":"project","content":"import { Concepts, createConcept } from '../model/concept';\r\nimport { KeyedSelector, createUnifiedKeyedSelector, selectSlice } from '../model/selector';\r\n\r\nexport type BaseDataSet = {\r\n  prompt: string,\r\n  content: string,\r\n}\r\n\r\nexport type NamedDataSet = {\r\n  name: string,\r\n  dataSet: BaseDataSet[]\r\n}\r\n\r\nexport const generateBaseDataSetEntry = (): BaseDataSet => {\r\n  return {\r\n    prompt: '#insert prompt#',\r\n    content: '#insert chosen output#',\r\n  };\r\n};\r\n\r\nexport const generateDefaultNamedDataSet = (name: string): NamedDataSet => ({\r\n  name,\r\n  dataSet: [generateBaseDataSetEntry()]\r\n});\r\n\r\ntest('userInterfaceBindingsToString', (done) => {\r\n  const simulated = {\r\n    trainingData: [generateDefaultNamedDataSet('something')],\r\n    shallow: true,\r\n  };\r\n  const experiment = createConcept(\r\n    'experiment',\r\n    simulated\r\n  );\r\n  const concepts: Concepts = {\r\n    1: experiment\r\n  };\r\n  const entry = generateBaseDataSetEntry();\r\n  const selector = createUnifiedKeyedSelector(concepts, 1, 'trainingData 0 dataSet 0 prompt') as KeyedSelector;\r\n  const shallow = createUnifiedKeyedSelector(concepts, 1, 'shallow') as KeyedSelector;\r\n  const getUndefined = {...selector};\r\n  getUndefined.conceptName = 'something';\r\n  expect(selectSlice(concepts, selector)).toBe(entry.prompt);\r\n  expect(selectSlice(concepts, shallow)).toBe(true);\r\n  expect(selectSlice(concepts, getUndefined)).toBe(undefined);\r\n  done();\r\n});"},"For the graph programming framework Stratimux, generate a test to ensure that the base selector consumer functions are working as intended.":{"type":"project","content":"import { createAxium  } from '../model/axium';\r\nimport { Concepts } from '../model/concept';\r\nimport { selectPayload, selectSlice, selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, counterName  } from '../concepts/counter/counter.concept';\r\nimport { counterSelectCount } from '../concepts/counter/counter.selector';\r\nimport { CounterSetCountPayload, counterSetCount } from '../concepts/counter/qualities/setCount.quality';\r\n\r\ntest('Axium Selector Test', (done) => {\r\n  const counter = createCounterConcept();\r\n  const counterState = counter.state as CounterState;\r\n  counterState.count = 10;\r\n  const axium = createAxium('axiumSelectorTest', [counter], true, true);\r\n  axium.subscribe((concepts: Concepts) => {\r\n    const state = selectState<CounterState>(concepts, counterName);\r\n    console.log('CHECK COUNT', state?.count);\r\n    expect(state?.count).toBe(10);\r\n    done();\r\n  });\r\n});\r\n\r\ntest('Axium Selector State Slice Test', (done) => {\r\n  const counter = createCounterConcept();\r\n  const counterState = counter.state as CounterState;\r\n  counterState.count = 10;\r\n  const axium = createAxium('axiumSelectorStateSlicedTest', [counter], true, true);\r\n  axium.subscribe((concepts: Concepts) => {\r\n    const count = selectSlice<number>(concepts, counterSelectCount);\r\n    expect(count).toBe(10);\r\n    setTimeout(() => {done();}, 500);\r\n  });\r\n});\r\n\r\ntest('Axium Selector Payload Test', (done) => {\r\n  const setCount = counterSetCount({newCount: 10 });\r\n  const payload = selectPayload<CounterSetCountPayload>(setCount);\r\n  expect(payload.newCount).toBe(10);\r\n  done();\r\n});"},"For the graph programming framework Stratimux, generate a test to ensure the stage planner and its options are working as intended.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, counterName } from '../concepts/counter/counter.concept';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { counterAdd } from '../concepts/counter/qualities/add.quality';\r\nimport { counterSubtract } from '../concepts/counter/qualities/subtract.quality';\r\nimport { counterSelectCount } from '../concepts/counter/counter.selector';\r\n\r\ntest('Axium Stage Dispatch Options Test', (done) => {\r\n  let runCount = 0;\r\n  const axium = createAxium('axiumStageDispatchOptionsTest', [createCounterConcept()], true);\r\n  const sub = axium.subscribe((concepts) => {\r\n    const axiumState = concepts[0].state as AxiumState;\r\n    if (axiumState.badPlans.length > 0) {\r\n      const badPlan = axiumState.badPlans[0];\r\n      const counter = selectState<CounterState>(concepts, counterName);\r\n      console.log('Stage Ran Away, badPlans.length: ', axiumState.badPlans.length, 'Count: ', counter?.count);\r\n      plan.conclude();\r\n      sub.unsubscribe();\r\n      expect(badPlan.stageFailed).toBe(2);\r\n      expect(counter?.count).toBe(2);\r\n      setTimeout(() => {done();}, 500);\r\n    }\r\n  });\r\n  const plan = axium.stage('Stage DispatchOptions Test',\r\n    [\r\n      (concepts, dispatch) => {\r\n        const counter = selectState<CounterState>(concepts, counterName);\r\n        console.log('Stage 1 ', counter, runCount);\r\n        dispatch(counterAdd(), {\r\n          iterateStage: true\r\n        });\r\n      }, (concepts, dispatch) => {\r\n        runCount++;\r\n        const counter = selectState<CounterState>(concepts, counterName);\r\n        console.log('Stage 2 ', counter, runCount);\r\n        // Sets count to 2 and only runs once per state update\r\n        dispatch(counterAdd(), {\r\n          runOnce: true\r\n        });\r\n        // Will wait until count is set to 2, then set the Stage Explicitly to the third Step counting from 0.\r\n        dispatch(counterAdd(), {\r\n          setStage: 2,\r\n          on: {\r\n            selector: counterSelectCount,\r\n            expected: 2\r\n          },\r\n          // Requires throttle, because the previous action is of the same type, but runs only once.\r\n          throttle: 1\r\n        });\r\n        // }\r\n      }, (concepts, dispatch) => {\r\n        runCount++;\r\n        const counter = selectState<CounterState>(concepts, counterName);\r\n        console.log('Should run twice, Stage 3 ', counter, runCount);\r\n        // Will cause an action overflow forcing the stage to close and add itself to badPlans\r\n        dispatch(counterSubtract(), {\r\n          // Enabling will cause this test to timeout via the subscription watching for badPlans to never be ran.\r\n          // throttle: 500\r\n          // This demonstrates the fault resistance of the Stage paradigm, despite Stratimux's recursive functionality.\r\n        });\r\n        // This dispatch will be invalidated and never dispatched due to the effect of action overflow of the above.\r\n        dispatch(counterAdd(), {});\r\n        console.log(\r\n          'Will also run twice. 1st will be before \"Stage Ran Away,\"',\r\n          'and after \"Should run twice.\" The 2nd will be final console log output.'\r\n        );\r\n      }\r\n    ]);\r\n});"},"For the graph programming framework Stratimux, generate a test to ensure that you can create a stage planner within a concept's principle.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { selectState } from '../model/selector';\r\nimport { createExperimentConcept, experimentName } from '../concepts/experiment/experiment.concept';\r\nimport { PrincipleFunction } from '../model/principle';\r\nimport { Action, ActionType, prepareActionCreator } from '../model/action';\r\nimport { Subscriber } from 'rxjs';\r\nimport { Concepts, createQuality } from '../model/concept';\r\nimport { UnifiedSubject } from '../model/stagePlanner';\r\nimport { axiumSelectOpen } from '../concepts/axium/axium.selector';\r\nimport { axiumPreClose } from '../concepts/axium/qualities/preClose.quality';\r\n\r\ntype ExperimentState = {\r\n  mock: boolean;\r\n};\r\n\r\nconst createExperimentState = (): ExperimentState => ({ mock: false });\r\n\r\nconst experimentMockToTrueType: ActionType = 'Experiment set mock to True';\r\nconst experimentMockToTrue = prepareActionCreator(experimentMockToTrueType);\r\nfunction experimentMockToTrueReducer(state: ExperimentState, action: Action): ExperimentState {\r\n  return {\r\n    ...state,\r\n    mock: true\r\n  };\r\n}\r\nconst experimentMockToTrueQuality = createQuality(experimentMockToTrueType, experimentMockToTrueReducer);\r\n\r\ntest('Axium Principle Stage', (done) => {\r\n  const experimentPrinciple: PrincipleFunction = (_: Subscriber<Action>, __: Concepts, concept$: UnifiedSubject) => {\r\n    const plan = concept$.stage('Experiment Principle', [\r\n      (___, dispatch) => {\r\n        dispatch(experimentMockToTrue(), {\r\n          iterateStage: true,\r\n          on: {\r\n            selector: axiumSelectOpen,\r\n            expected: true\r\n          },\r\n        });\r\n      },\r\n      (concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState?.mock) {\r\n          expect(experimentState.mock).toBe(true);\r\n          setTimeout(() => done(), 1000);\r\n          dispatch(axiumPreClose({exit: false}), {\r\n            iterateStage: true\r\n          });\r\n          plan.conclude();\r\n        }\r\n      },\r\n      () => {\r\n        //\r\n      }\r\n    ]);\r\n  };\r\n  createAxium('axiumStrategyTest', [\r\n    createExperimentConcept(createExperimentState(), [experimentMockToTrueQuality], [experimentPrinciple])\r\n  ], true, true);\r\n});"},"For the graph programming framework Stratimux, generate a test to ensure that you can create a stage planner that sets the beat parameter\r\nof the plan. The beat will ensure that within a span of time the first notification of state change will be observed.\r\nBut any new additional changes to state will be debounced for the beat duration.\r\nBut if the beat has not been notified for a period. The first notification will go through and start this process over again.\r\nThis is a combination of throttle and debounce.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { selectState } from '../model/selector';\r\nimport { axiumSelectOpen } from '../concepts/axium/axium.selector';\r\nimport { axiumPreClose } from '../concepts/axium/qualities/preClose.quality';\r\nimport { axiumKick } from '../concepts/axium/qualities/kick.quality';\r\nimport { CounterState, counterName, createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { counterAdd } from '../concepts/counter/qualities/add.quality';\r\n\r\ntest('Stage Planner Beat Test', (done) => {\r\n  let timerActive = false;\r\n  const axium = createAxium('axium test stage planner beat', [\r\n    createCounterConcept()\r\n  ], true, true);\r\n  const plan = axium.stage('Stage Planner Beat Test', [\r\n    (___, dispatch) => {\r\n      timerActive = true;\r\n      setTimeout(() => {\r\n        timerActive = false;\r\n      }, 1000);\r\n      dispatch(axiumKick(), {\r\n        iterateStage: true,\r\n        on: {\r\n          selector: axiumSelectOpen,\r\n          expected: true\r\n        },\r\n      });\r\n    },\r\n    (___, dispatch) => {\r\n      dispatch(counterAdd(), {\r\n        iterateStage: true\r\n      });\r\n    },\r\n    (concepts, dispatch) => {\r\n      if (!timerActive) {\r\n        const state = selectState<CounterState>(concepts, counterName);\r\n        if (state) {\r\n          expect(state.count).toBe(10);\r\n          setTimeout(() => done(), 1000);\r\n          dispatch(axiumPreClose({exit: false}), {\r\n            iterateStage: true\r\n          });\r\n          plan.conclude();\r\n        }\r\n      } else {\r\n        dispatch(counterAdd(), {\r\n          throttle: 1\r\n        });\r\n      }\r\n    },\r\n    () => {\r\n      //\r\n    }\r\n  ], 93);\r\n});"},"For the graph programming framework Stratimux, generate a test that ensures that ActionStrategies are working as intended.":{"type":"project","content":"import { createAxium } from '../model/axium';\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { selectState } from '../model/selector';\r\nimport { CounterState, createCounterConcept, countingStrategy, counterName } from '../concepts/counter/counter.concept';\r\nimport { AxiumState } from '../concepts/axium/axium.concept';\r\nimport { countingTopic } from '../concepts/counter/strategies/counting.strategy';\r\n\r\ntest('Axium Counting Strategy Test', (done) => {\r\n  const axium = createAxium('axiumStrategyTest', [createCounterConcept()], true, true);\r\n  const plan = axium.stage('Counting Strategy Stage',\r\n    [\r\n      (_, dispatch) => {\r\n        dispatch(strategyBegin(countingStrategy()), {\r\n          iterateStage: true\r\n        });\r\n      }, (concepts) => {\r\n        const axiumState = concepts[0].state as AxiumState;\r\n        if (axiumState.lastStrategy === countingTopic) {\r\n          const counter = selectState<CounterState>(concepts, counterName);\r\n          expect(counter?.count).toBe(1);\r\n          setTimeout(() => {done();}, 500);\r\n          plan.conclude();\r\n          axium.close();\r\n        }\r\n      }\r\n    ]);\r\n});"},"For the graph programming framework Stratimux, generate a test that ensures that throttle method helper functions are working as intended.":{"type":"project","content":"import { axiumSelectLastStrategy, axiumSelectLastStrategyData } from '../concepts/axium/axium.selector';\r\nimport { axiumKick } from '../concepts/axium/qualities/kick.quality';\r\nimport { ExperimentState, createExperimentConcept, createExperimentState, experimentName } from '../concepts/experiment/experiment.concept';\r\nimport {\r\n  experimentThrottleAsyncIterateIdThenReceiveInMethodQuality\r\n} from '../concepts/experiment/qualities/throttleAsyncIterateIdThenReceiveInMethod.quality';\r\nimport {\r\n  ExperimentThrottleIterateIdThenReceiveInMethodPayload,\r\n  experimentThrottleIterateIdThenReceiveInMethodQuality\r\n} from '../concepts/experiment/qualities/throttleIterateIdThenReceiveInMethod.quality';\r\n\r\nimport {\r\n  experimentThrottleAsyncIterateIdThenAddToData,\r\n  experimentThrottleAsyncIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/throttleAsyncIterateIdThenAddToData.strategy';\r\nimport {\r\n  experimentThrottleIterateIdThenAddToData,\r\n  experimentThrottleIterateIdThenAddToDataTopic\r\n} from '../concepts/experiment/strategies/throttleIterateIdThenAddToData.strategy';\r\n\r\nimport { strategyBegin } from '../model/actionStrategy';\r\nimport { createAxium } from '../model/axium';\r\nimport { selectSlice, selectState } from '../model/selector';\r\n\r\ntest('Action Throttle Method Test with Concepts id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentThrottleIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.stage('Throttle Iterate id with Concepts', [\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        dispatch(strategyBegin(experimentThrottleIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Action Throttle: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentThrottleIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Action Throttle: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentThrottleIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState & ExperimentThrottleIterateIdThenReceiveInMethodPayload>(\r\n          concepts,\r\n          axiumSelectLastStrategyData\r\n        );\r\n        console.log('Action Throttle: ', experimentState.id, lastStrategy, data);\r\n        if (lastStrategy === experimentThrottleIterateIdThenAddToDataTopic) {\r\n          if (data) {\r\n            console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n            expect(data.id).toBe(0);\r\n            expect(data.setId).toBe(0);\r\n            expect(experimentState.id).toBe(3);\r\n            plan.conclude();\r\n            axium.close();\r\n            done();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  ]);\r\n});\r\n\r\njest.setTimeout(7000);\r\ntest('Action Throttle Async Method Test with Concepts id comparison', (done) => {\r\n  const experiment = createExperimentConcept(createExperimentState(), [experimentThrottleAsyncIterateIdThenReceiveInMethodQuality]);\r\n  const axium = createAxium('Experiment observe how concepts updates via reducer and method', [experiment]);\r\n  const plan = axium.stage('Action Throttle Async Iterate id with Concepts', [\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        dispatch(strategyBegin(experimentThrottleAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Async Action Throttle: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentThrottleAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, dispatch) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n        console.log('Async Action Throttle: ', experimentState.id, lastStrategy, data);\r\n        dispatch(strategyBegin(experimentThrottleAsyncIterateIdThenAddToData(experimentState.id)), {\r\n          iterateStage: true\r\n        });\r\n      }\r\n    },\r\n    (concepts, _) => {\r\n      const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n      if (experimentState) {\r\n        const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n        const data = selectSlice<ExperimentState & ExperimentThrottleIterateIdThenReceiveInMethodPayload>(\r\n          concepts,\r\n          axiumSelectLastStrategyData\r\n        );\r\n        console.log('Last Async Action Throttle: ', experimentState.id, lastStrategy, data);\r\n        if (lastStrategy === experimentThrottleAsyncIterateIdThenAddToDataTopic) {\r\n          if (data) {\r\n            console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n            expect(data.id).toBe(0);\r\n            expect(data.setId).toBe(0);\r\n            expect(experimentState.id).toBe(3);\r\n            plan.conclude();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  ]);\r\n  setTimeout(() => {\r\n    const secondPlan = axium.stage('Action Throttle Async Iterate id with Concepts', [\r\n      (concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const strategy = experimentThrottleAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      },\r\n      (concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('Async Action Throttle: ', experimentState.id, lastStrategy, data);\r\n          const strategy = experimentThrottleAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      },\r\n      (concepts, dispatch) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState>(concepts, axiumSelectLastStrategyData);\r\n          console.log('Async Action Throttle: ', experimentState.id, lastStrategy, data);\r\n          const strategy = experimentThrottleAsyncIterateIdThenAddToData(experimentState.id);\r\n          strategy.topic += 2;\r\n          dispatch(strategyBegin(strategy), {\r\n            iterateStage: true\r\n          });\r\n        }\r\n      },\r\n      (concepts, _) => {\r\n        const experimentState = selectState<ExperimentState>(concepts, experimentName);\r\n        if (experimentState) {\r\n          const lastStrategy = selectSlice(concepts, axiumSelectLastStrategy);\r\n          const data = selectSlice<ExperimentState & ExperimentThrottleIterateIdThenReceiveInMethodPayload>(\r\n            concepts,\r\n            axiumSelectLastStrategyData\r\n          );\r\n          console.log('2 Last Async Action Throttle: ', experimentState.id, lastStrategy, data);\r\n          if (lastStrategy === experimentThrottleAsyncIterateIdThenAddToDataTopic + 2) {\r\n            if (data) {\r\n              console.log('Strategy Data: ', data, 'Experiment State ID: ', experimentState.id);\r\n              expect(data.id).toBe(3);\r\n              expect(data.setId).toBe(3);\r\n              expect(experimentState.id).toBe(6);\r\n              secondPlan.conclude();\r\n              axium.close();\r\n              done();\r\n            }\r\n          }\r\n        }\r\n      }\r\n    ]);\r\n    axium.dispatch(axiumKick());\r\n  }, 1000);\r\n});"},"For the graph programming framework Stratimux, generate a test that ensures that unified concepts inherit their unified names as intended.":{"type":"project","content":"import { createConcept, unifyConcepts } from '../model/concept';\r\n\r\ntest('Unified Names Test', (done) => {\r\n  const one = createConcept(\r\n    'one',\r\n    {},\r\n  );\r\n  const two = createConcept(\r\n    'two',\r\n    {},\r\n  );\r\n  const three = createConcept(\r\n    'three',\r\n    {},\r\n  );\r\n  const four = createConcept(\r\n    'four',\r\n    {},\r\n  );\r\n  const five = createConcept(\r\n    'five',\r\n    {},\r\n  );\r\n  const unified = unifyConcepts([\r\n    one, two, two, three, four, five, five\r\n  ],\r\n  createConcept('unified', {})\r\n  );\r\n  console.log('CHECK UNIFIED', unified.unified, unified);\r\n  expect(unified.unified.length).toBe([one, two, three, four, five].length);\r\n  done();\r\n});"},"For the graph programming framework Stratimux,\r\ngenerate a test that ensures that the functionality of different state selector consumer functions.\r\nThat specifically you can utilize the incoming semaphore to create new KeyedSelectors, or update old ones.":{"type":"project","content":"import { CounterState, counterName, createCounterConcept } from '../concepts/counter/counter.concept';\r\nimport { counterSelectCount } from '../concepts/counter/counter.selector';\r\nimport { createAxium } from '../model/axium';\r\nimport {\r\n  KeyedSelector,\r\n  createConceptKeyedSelector,\r\n  createUnifiedKeyedSelector,\r\n  selectSlice,\r\n  updateUnifiedKeyedSelector\r\n} from '../model/selector';\r\n\r\ntest('Unified Selector Test', (done) => {\r\n  const axium = createAxium('Selector Test via Counter', [\r\n    createCounterConcept()\r\n  ], true, true);\r\n  const plan = axium.stage('Plan: Counter Selector', [\r\n    (concepts, _) => {\r\n      const concept = createConceptKeyedSelector(concepts, counterName, counterSelectCount) as KeyedSelector;\r\n      const updated = updateUnifiedKeyedSelector(concepts, 1, concept) as KeyedSelector;\r\n      const unified = createUnifiedKeyedSelector<CounterState>(concepts, 1, 'count') as KeyedSelector;\r\n      expect(selectSlice(concepts, updated)).toBe(0);\r\n      expect(selectSlice(concepts, concept)).toBe(0);\r\n      expect(selectSlice(concepts, unified)).toBe(0);\r\n      setTimeout(() => done(), 0);\r\n      plan.conclude();\r\n    },\r\n  ]);\r\n});"}}